<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vue的小重点</title>
    <link href="/2025/02/21/Vue%E7%9A%84%E5%B0%8F%E9%87%8D%E7%82%B9/"/>
    <url>/2025/02/21/Vue%E7%9A%84%E5%B0%8F%E9%87%8D%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue的小重点"><a href="#Vue的小重点" class="headerlink" title="Vue的小重点"></a>Vue的小重点</h1><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502220003757.png" alt="image-20250222000316715"></p><h2 id="一、生命周期"><a href="#一、生命周期" class="headerlink" title="一、生命周期"></a>一、生命周期</h2><h3 id="1、生命周期过程"><a href="#1、生命周期过程" class="headerlink" title="1、生命周期过程"></a>1、生命周期过程</h3><p>Vue的生命周期是指Vue实例从创建到销毁的过程。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502212357925.png" alt="image-20250220211840274"></p><p><strong>Vue2生命周期</strong></p><ul><li>创建阶段<ul><li>beforeCreate：实例尚未完成初始化，不能访问data、computed、methods等。</li><li>created：data、computed、methods 等已经初始化，可以访问和修改。DOM还未渲染。</li></ul></li><li>挂载阶段<ul><li>beforeMount：已经编译好模版，但还没有渲染到页面。</li><li>Mounted：组件已被渲染，可以通过$el获取到真实DOM</li></ul></li><li>更新阶段<ul><li>beforeUpdate：组件的数据变化，DOM还没有更新。</li><li>Updated：DOM已经重新渲染。</li></ul></li><li>销毁阶段<ul><li>beforeDestroy：组件即将被销毁，仍然可以访问data、methos、computed等</li><li>destroyed：实例已经销毁。</li></ul></li></ul><h3 id="2、子组件和父组件执行顺序"><a href="#2、子组件和父组件执行顺序" class="headerlink" title="2、子组件和父组件执行顺序"></a>2、子组件和父组件执行顺序</h3><p><strong>组件创建时</strong></p><p>父组件挂载的时候，要先完成子组件的创建和挂载。</p><p>子组件的 mounted 先执行，然后才是父组件的 mounted。</p><blockquote><p><strong>父组件 <code>beforeCreate</code></strong></p><p><strong>父组件 <code>created</code></strong></p><p><strong>父组件 <code>beforeMount</code></strong></p><p><strong>子组件 <code>beforeCreate</code></strong></p><p><strong>子组件 <code>created</code></strong></p><p><strong>子组件 <code>beforeMount</code></strong></p><p><strong>子组件 <code>mounted</code></strong></p><p><strong>父组件 <code>mounted</code></strong></p></blockquote><p><strong>组件更新时</strong></p><p>也是父组件开始和收尾</p><blockquote><ol><li><strong>父组件 <code>beforeUpdate</code></strong></li><li><strong>子组件 <code>beforeUpdate</code></strong></li><li><strong>子组件 <code>updated</code></strong></li><li><strong>父组件 <code>updated</code></strong></li></ol></blockquote><p><strong>组件销毁时</strong></p><p>也是父组件开始和收尾</p><blockquote><p><strong>父组件 <code>beforeDestroy</code></strong></p><p><strong>子组件 <code>beforeDestroy</code></strong></p><p><strong>子组件 <code>destroyed</code></strong></p><p><strong>父组件 <code>destroyed</code></strong></p></blockquote><h3 id="3、created和mounted的区别"><a href="#3、created和mounted的区别" class="headerlink" title="3、created和mounted的区别"></a>3、created和mounted的区别</h3><p>当组件被创建时，<code>created</code> <strong>比</strong> <code>mounted</code> 早执行：</p><ol><li><code>beforeCreate</code></li><li><code>created</code> ✅ （数据已可用，但 DOM 还未生成）</li><li><code>beforeMount</code></li><li><code>mounted</code> ✅ （DOM 已生成）</li></ol><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502212357937.png" alt="image-20250220232239355"></p><h3 id="4、一般在哪个生命周期请求异步数据"><a href="#4、一般在哪个生命周期请求异步数据" class="headerlink" title="4、一般在哪个生命周期请求异步数据"></a>4、一般在哪个生命周期请求异步数据</h3><p>可以选择created、beforeMount、mounted ，因为在这三个钩子函数中，data 已经创建，可以将服务端返回的数据进行赋值。</p><p>首选：<code>created</code>：组件实例已经创建，data、computed、methods可用，适合在页面渲染前提前获取数据，数据和 DOM 交互无关，只需要存入 <code>data</code>。</p><p>如果需要与DOM交互，选择 <code>mounted</code>。</p><p>如果使用 Vue 3，推荐在 <code>setup</code> 里请求数据，并使用 <code>onMounted</code> 处理 DOM 相关逻辑。</p><h3 id="5、keep-alive-中的生命周期哪些"><a href="#5、keep-alive-中的生命周期哪些" class="headerlink" title="5、keep-alive 中的生命周期哪些"></a>5、keep-alive 中的生命周期哪些</h3><p>keep-alive组件用于缓存动态组件，防止它们被销毁后重建，从而提升性能。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502212357964.png" alt="image-20250220233328029"></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir">&lt;keep-alive&gt;<br>  &lt;component <span class="hljs-symbol">:is=<span class="hljs-string">&quot;currentView&quot;</span>&gt;&lt;/component&gt;</span><br>&lt;/keep-alive&gt;<br></code></pre></td></tr></table></figure><p>当从 <code>A</code> 切换到 <code>B</code>：</p><ol><li><code>A</code> 触发 <code>deactivated</code></li><li><code>B</code> 触发 <code>created</code> → <code>mounted</code> → <code>activated</code></li></ol><p>当从 <code>B</code> 切换回 <code>A</code>：</p><ol><li><code>B</code> 触发 <code>deactivated</code></li><li><code>A</code> 触发 <code>activated</code>（不会重新 <code>created</code> 和 <code>mounted</code>）</li></ol><p><strong>数据请求</strong>：在 <code>activated</code> 请求数据，避免重复请求。</p><p><strong>计时器</strong>：在 <code>activated</code> 开启，在 <code>deactivated</code> 清除。</p><p><strong>滚动恢复</strong>：在 <code>deactivated</code> 记录滚动，在 <code>activated</code> 恢复。</p><h2 id="二、组件通信"><a href="#二、组件通信" class="headerlink" title="二、组件通信"></a>二、组件通信</h2><h3 id="1、props，父传子"><a href="#1、props，父传子" class="headerlink" title="1、props，父传子"></a>1、props，父传子</h3><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;Hello Vue!&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> </span></span><span class="hljs-template-variable">&#123; components: &#123; ChildComponent &#125;</span><span class="language-xml"> &#125;;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>接收到的消息：</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">message</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">message</span>: <span class="hljs-title class_">String</span> &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="2、-emit，子传父"><a href="#2、-emit，子传父" class="headerlink" title="2、$emit，子传父"></a>2、$emit，子传父</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendMessage&quot;</span>&gt;</span>点击发送<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&quot;send-message&quot;</span>, <span class="hljs-string">&quot;Hello from Child!&quot;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> @<span class="hljs-attr">send-message</span>=<span class="hljs-string">&quot;receiveMessage&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">ChildComponent</span> &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">receiveMessage</span>(<span class="hljs-params">msg</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;收到子组件的消息:&quot;</span>, msg);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3、v-model，父子双向"><a href="#3、v-model，父子双向" class="headerlink" title="3、v-model，父子双向"></a>3、v-model，父子双向</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;modelValue&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&quot;modelValue&quot;</span>]</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">ChildComponent</span> &#125;,</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello Vue!&quot;</span> &#125;;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 Vue 中，<code>v-model</code> 是一个语法糖，它背后做了两件事：</p><ol><li><strong>绑定值</strong>：将父组件的数据绑定到子组件的 <code>props</code>。</li><li><strong>监听事件</strong>：自动监听子组件发出的特定事件（<code>update:modelValue</code>），并更新父组件的数据。</li></ol><h3 id="4、provide-inject：祖传后代"><a href="#4、provide-inject：祖传后代" class="headerlink" title="4、provide&#x2F;inject：祖传后代"></a>4、provide&#x2F;inject：祖传后代</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 祖先组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">ChildComponent</span> &#125;,</span><br><span class="language-javascript">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">provide</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;Hello from Parent&quot;</span>);</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-comment">&lt;!-- 后代组件 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>接收到的消息：</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">message</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> message = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&quot;message&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123; message &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="5、ref，父操作子"><a href="#5、ref，父操作子" class="headerlink" title="5、ref，父操作子"></a>5、ref，父操作子</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>子组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;子组件方法被调用&quot;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;child&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;callChildMethod&quot;</span>&gt;</span>调用子组件方法<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">ChildComponent</span> &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">callChildMethod</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">child</span>.<span class="hljs-title function_">sayHello</span>();</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6、Event-Bus（Vue2）：任意组件通信"><a href="#6、Event-Bus（Vue2）：任意组件通信" class="headerlink" title="6、Event Bus（Vue2）：任意组件通信"></a>6、Event Bus（Vue2）：任意组件通信</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// eventBus.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">EventBus</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>();<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 组件 A（发送消息） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendMessage&quot;</span>&gt;</span>发送消息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">EventBus</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./eventBus&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-title class_">EventBus</span>.$emit(<span class="hljs-string">&quot;custom-event&quot;</span>, <span class="hljs-string">&quot;Hello from A&quot;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-comment">&lt;!-- 组件 B（接收消息） --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">message</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">EventBus</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./eventBus&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;&quot;</span> &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">EventBus</span>.$on(<span class="hljs-string">&quot;custom-event&quot;</span>, <span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = msg;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="7、Vuex-Pinia（全局状态管理）"><a href="#7、Vuex-Pinia（全局状态管理）" class="headerlink" title="7、Vuex &#x2F; Pinia（全局状态管理）"></a>7、Vuex &#x2F; Pinia（全局状态管理）</h3><p>Vue2</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pf">// store.js<br>import Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span>;<br>export <span class="hljs-keyword">default</span> new Vuex.Store(&#123;<br>  <span class="hljs-keyword">state</span>: &#123; count: <span class="hljs-number">0</span> &#125;,<br>  mutations: &#123;<br>    increment(<span class="hljs-keyword">state</span>) &#123;<br>      <span class="hljs-keyword">state</span>.count++;<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 组件 A --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$store.commit(&#x27;increment&#x27;)&quot;</span>&gt;</span>增加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-comment">&lt;!-- 组件 B --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>计数: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">$store.state.count</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>Pinia（Vue3 推荐）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// store.js</span><br><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;pinia&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&quot;main&quot;</span>, &#123;<br>  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;),<br>  <span class="hljs-attr">actions</span>: &#123; <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++; &#125; &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-comment">&lt;!-- 组件 --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;store.increment()&quot;</span>&gt;</span>增加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>计数: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">store.count</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./store&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>();</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123; store &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="三、Vue-Router-路由"><a href="#三、Vue-Router-路由" class="headerlink" title="三、Vue Router 路由"></a>三、Vue Router 路由</h2><h3 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h3><p>Vue Router 是 Vue.js 官方的 前端路由管理工具，用于构建单页面应用（SPA）。可以在不重新加载页面的情况下，实现不同页面（视图）之间的切换。</p><p><strong>为什么要用 Vue Router？</strong></p><ol><li>单页面应用（SPA）：让 Vue 应用可以像多页面网站一样切换视图，而无需刷新整个页面。</li><li>管理 URL 显示：基于 URL 变化动态渲染组件，使页面可以直接分享。</li><li>前进&#x2F;后退：支持浏览器的前进、后退功能。</li><li>嵌套路由：支持多级路由嵌套，适用于复杂的页面结构。</li><li>路由守卫：可以拦截路由导航，实现权限控制或全局前置处理。</li></ol><p><strong>怎么使用</strong></p><p>1、npm install 安装</p><p>2、创建 <code>router/index.js</code>，配置路由</p><p>3、在 <code>main.js</code> 里注册 <code>router</code></p><p>4、在组件中使用 Vue Router</p><ul><li>路由链接</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> |<br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>关于我们<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>  // 路由出口，用于渲染匹配到的组件<br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>动态路由</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const routes</span> = [<br>  &#123; path: <span class="hljs-string">&#x27;/user/:id&#x27;</span>, component: User &#125; // <span class="hljs-string">`:id`</span> 表示动态参数<br>];<br></code></pre></td></tr></table></figure><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>用户 ID: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">$route.params.id</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>路由守卫</li></ul><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">router.beforeEach(<span class="hljs-function"><span class="hljs-params">(to, <span class="hljs-keyword">from</span>, <span class="hljs-built_in">next</span>)</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (to.path === <span class="hljs-string">&#x27;/admin&#x27;</span> &amp;&amp; !isLoggedIn()) &#123;<br>    <span class="hljs-built_in">next</span>(<span class="hljs-string">&#x27;/login&#x27;</span>); // 未登录时跳转到登录页<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">next</span>(); // 继续导航<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>编程式导航</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-built_in">this</span>.<span class="hljs-variable">$router</span>.push(<span class="hljs-string">&#x27;/about&#x27;</span>); <span class="hljs-comment">// 跳转</span><br><span class="hljs-built_in">this</span>.<span class="hljs-variable">$router</span>.replace(<span class="hljs-string">&#x27;/home&#x27;</span>); <span class="hljs-comment">// 不保留历史记录</span><br><span class="hljs-built_in">this</span>.<span class="hljs-variable">$router</span>.go(<span class="hljs-number">-1</span>); <span class="hljs-comment">// 返回上一页</span><br></code></pre></td></tr></table></figure><h3 id="2、-Vue-Router-的懒加载如何实现"><a href="#2、-Vue-Router-的懒加载如何实现" class="headerlink" title="2、 Vue-Router 的懒加载如何实现"></a>2、 Vue-Router 的懒加载如何实现</h3><p>懒加载，指按需加载，需要的时候才加载路由对应的组件，而不是在应用加载时一次性加载所有组件。这样可以减少首屏加载时间，提高应用性能，特别适用于大型项目。</p><p><strong>传统的静态导入</strong>：所有组件在页面加载时都会被打包进 <code>bundle.js</code>，即使用户不会访问某些页面，也会加载对应组件。首屏加载慢，影响性能。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/Home.vue&#x27;</span>;<br><span class="hljs-keyword">import</span> About <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/About.vue&#x27;</span>;<br><br>const routes = [<br>  &#123; <span class="hljs-type">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, component: Home &#125;,<br>  &#123; <span class="hljs-type">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>, component: About &#125;<br>];<br></code></pre></td></tr></table></figure><p><strong>懒加载（动态导入）</strong></p><p>import()：组件会在访问对应路由时才加载，而不是在应用启动时全部加载。减小首屏 JS 体积，提升应用性能。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const routes = [<br>  &#123; path: <span class="hljs-string">&#x27;/&#x27;</span>, component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/Home.vue&#x27;</span>) &#125;,<br>  &#123; path: <span class="hljs-string">&#x27;/about&#x27;</span>, component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/About.vue&#x27;</span>) &#125;<br>];<br></code></pre></td></tr></table></figure><h3 id="3、两种路由模式"><a href="#3、两种路由模式" class="headerlink" title="3、两种路由模式"></a>3、两种路由模式</h3><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502212357946.png" alt="image-20250221011049252"></p><p><strong><code>hash</code> 模式</strong>（默认）：使用 URL 的 <code>#</code> 符号（锚点）实现路由。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">http:</span>//example.com/<span class="hljs-meta">#/home</span><br><span class="hljs-symbol">http:</span>//example.com/<span class="hljs-meta">#/about</span><br></code></pre></td></tr></table></figure><p><strong><code>history</code> 模式</strong>：使用 HTML5 的 <code>History API</code> 进行路由管理，没有 <code>#</code> 符号，看起来像正常的 URL。</p><p>依赖 <strong>HTML5 History API</strong> (<code>pushState</code> 和 <code>replaceState</code>) 进行路由管理。</p><p>Vue 监听 <code>popstate</code> 事件进行视图切换，而不是依赖 <code>#</code> 符号。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//example.com/home</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//example.com/about</span><br></code></pre></td></tr></table></figure><p><strong>如何切换模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueRouter</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/Home.vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/About.vue&#x27;</span>;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueRouter</span>);<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;history&#x27;</span>, <span class="hljs-comment">// 或 默认&#x27;hash&#x27;</span><br>  <span class="hljs-attr">routes</span>: [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span> &#125;,<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">About</span> &#125;<br>  ]<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br><br></code></pre></td></tr></table></figure><h3 id="4、获取页面hash变化"><a href="#4、获取页面hash变化" class="headerlink" title="4、获取页面hash变化"></a>4、获取页面hash变化</h3><p>监听 <code>hashchange</code> 事件，使用<code>window.location.hash</code>或者<code>$route.hash</code>获取</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;hashchange&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleHashChange</span>);</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">handleHashChange</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;当前 hash:&#x27;</span>, <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-title function_">beforeUnmount</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;hashchange&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleHashChange</span>);</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5、route-和router-的区别"><a href="#5、route-和router-的区别" class="headerlink" title="5、route 和router 的区别"></a>5、route 和router 的区别</h3><p>$route用于获取当前路由信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;当前路径:&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">path</span>);</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;查询参数:&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">query</span>);</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;路由参数:&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">params</span>);</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>$router用于跳转页面</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 跳转到新的路由（会新增一条历史记录）</span><br><span class="hljs-built_in">this</span>.<span class="hljs-variable">$router</span>.push(<span class="hljs-string">&#x27;/home&#x27;</span>);<br><br><span class="hljs-comment">// 替换当前路由（不会新增历史记录）</span><br><span class="hljs-built_in">this</span>.<span class="hljs-variable">$router</span>.replace(<span class="hljs-string">&#x27;/profile&#x27;</span>);<br><br><span class="hljs-comment">// 后退一步</span><br><span class="hljs-built_in">this</span>.<span class="hljs-variable">$router</span>.back();<br><br><span class="hljs-comment">// 前进一步</span><br><span class="hljs-built_in">this</span>.<span class="hljs-variable">$router</span>.forward();<br><br><span class="hljs-comment">// 前进或后退 n 步</span><br><span class="hljs-built_in">this</span>.<span class="hljs-variable">$router</span>.go(<span class="hljs-number">-1</span>); <span class="hljs-comment">// 相当于 this.$router.back()</span><br><span class="hljs-built_in">this</span>.<span class="hljs-variable">$router</span>.go(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 前进两步</span><br></code></pre></td></tr></table></figure><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502212357954.png" alt="image-20250221012525120"></p><h3 id="6、Vue-router-路由守卫（钩子函数）"><a href="#6、Vue-router-路由守卫（钩子函数）" class="headerlink" title="6、Vue-router 路由守卫（钩子函数）"></a>6、Vue-router 路由守卫（钩子函数）</h3><p>路由钩子（导航守卫）可以控制组件或者页面在路由变化时的行为。比如跳转前身份验证、拦截、保存数据等。</p><p>路由守卫比生命周期更早执行，因为 Vue Router 需要先确定路由是否允许访问，然后才会创建组件。</p><p><strong>全局守卫、路由独享守卫、组件内守卫</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502212357898.png" alt="image-20250221143105753"></p><p>从A跳转到B的守卫执行顺序：</p><p>全局前置守卫 beforeEach<br>路由独享守卫 beforeEnter<br>组件前置守卫 beforeRouteEnter<br>组件生命周期 created → mounted<br>全局解析守卫 beforeResolve<br>全局后置守卫 afterEach</p><h3 id="7、Vue-router跳转和location-href有什么区别"><a href="#7、Vue-router跳转和location-href有什么区别" class="headerlink" title="7、Vue-router跳转和location.href有什么区别"></a>7、Vue-router跳转和location.href有什么区别</h3><p>Vue-router提供了前端路由管理，不会刷新整个页面，而是更新url并且切换组件，实现单页应用的无刷新导航。</p><p><strong>router跳转方式</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-built_in">this</span>.<span class="hljs-variable">$router</span>.push(<span class="hljs-string">&#x27;/about&#x27;</span>); <span class="hljs-comment">// 添加历史记录</span><br><span class="hljs-built_in">this</span>.<span class="hljs-variable">$router</span>.replace(<span class="hljs-string">&#x27;/about&#x27;</span>); <span class="hljs-comment">// 替换当前历史记录</span><br><span class="hljs-built_in">this</span>.<span class="hljs-variable">$router</span>.go(<span class="hljs-number">-1</span>); <span class="hljs-comment">// 后退一步</span><br></code></pre></td></tr></table></figure><p><strong><code>window.location.href</code> 直接跳转</strong></p><p>会刷新页面，重新加载所有资源，无法使用router提供的钩子，适用于跳转到其他网站，或强制刷新页面。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">window.location.href</span> = <span class="hljs-string">&#x27;/about&#x27;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="8、params和query的区别"><a href="#8、params和query的区别" class="headerlink" title="8、params和query的区别"></a>8、params和query的区别</h3><p><strong>params：</strong>动态路由参数，使用动态段（例如&#x2F;user&#x2F;:id）,其中:id表示一个变量，路由匹配时必须提供这个参数。</p><p>对路由匹配有直接影响。如果参数缺失，路由匹配可能失败。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const routes</span> = [<br>  &#123; path: <span class="hljs-string">&#x27;/user/:id&#x27;</span>, <br>  name: <span class="hljs-string">&#x27;user&#x27;</span>, <br>  component: UserComponent &#125;<br>];<br></code></pre></td></tr></table></figure><p>可以通过对象传递：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">this.<span class="hljs-variable">$router</span>.<span class="hljs-title function_ invoke__">push</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">123</span> &#125; &#125;);<br></code></pre></td></tr></table></figure><p>也可以直接构造url：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 直接跳转到 /user/123</span><br>this.<span class="hljs-symbol">$router</span>.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;/user/123&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>query：</strong>查询参数，无需在路由配置预先定义，查询参数通过?后面的键值对传递。</p><p>适用于可选参数，如搜索关键词、排序方式、过滤条件等，这些参数不会影响路由匹配，仅作为额外的信息传递给组件。</p><p>可以通过对象传递：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php">this.<span class="hljs-variable">$router</span>.<span class="hljs-title function_ invoke__">push</span>(<br>&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/search&#x27;</span>, <br>  <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">keyword</span>: <span class="hljs-string">&#x27;vue&#x27;</span>, <span class="hljs-attr">sort</span>: <span class="hljs-string">&#x27;desc&#x27;</span> &#125; <br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="四、Vuex"><a href="#四、Vuex" class="headerlink" title="四、Vuex"></a>四、Vuex</h2><h3 id="1、基本原理"><a href="#1、基本原理" class="headerlink" title="1、基本原理"></a>1、基本原理</h3><p>官方状态管理库，核心思想是集中式存储所有组件的共享状态，通过单向数据流来确保状态以可预测的方式发生改变。</p><p><strong>state：</strong>存储所有共享数据，整个应用只有一个状态树（单一数据源）。支持将 store 分割成多个模块，便于管理大型应用。</p><p><strong>mutations：</strong>唯一修改state的方式，必须是同步函数，这样所有状态的变更有明确的记录通过commit调用。</p><p>**actions:**处理异步操作，比如异步请求数据。不能直接修改state，通过mutations修改。使用dispatch调用。<br>**getters:**派生状态。类似于computed属性，对state进行加工计算或者过滤后再用。state变化时，依赖state的getters也会自动更新。</p><blockquote><p>状态存储store是一个响应式对象，所有组件都从这个单一的数据源读取数据，保存数据一致性。内部利用vue的响应式系统，当state变化，所有依赖该状态的组件都会自动更新视图。</p></blockquote><p>单向数据流：</p><p>读取：组件从store里读取state或者通过getters获取派生状态。</p><p>更新：触发actions，actions执行异步操作，再通过commit mutations改变state。</p><p>所有状态的改变都可以被 Vue 开发者工具监控。</p><h3 id="2、Vuex中actions和mutations的区别"><a href="#2、Vuex中actions和mutations的区别" class="headerlink" title="2、Vuex中actions和mutations的区别"></a>2、Vuex中actions和mutations的区别</h3><p>它们都是更改状态相关的。</p><p>mutation必须是同步函数，确保状态变化可追踪。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> mutations = &#123;<br>  increment(<span class="hljs-keyword">state</span>, payload) &#123;<br>    <span class="hljs-keyword">state</span>.count += payload.amount;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>调用mutations使用：<code>this.$store.commit(&#39;increment&#39;, &#123; amount: 1 &#125;)</code></p><p>actions主要处理异步操作。如API调用，然后再通过commit调用mutations修改状态。</p><p>接收的参数一般为 <code>state</code> 和传入的 payload（数据）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> actions = &#123;<br>  <span class="hljs-title function_">asyncIncrement</span>(<span class="hljs-params">&#123; commit &#125;, payload</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>, payload);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>调用actions，使用<code>this.$store.dispatch(&#39;asyncIncrement&#39;, &#123; amount: 1 &#125;)</code></p><p>接收一个 context 对象，其中包含 <code>commit</code>、<code>state</code>、<code>dispatch</code> 等属性，便于在异步操作中调用其他 action 或 mutation。</p><h3 id="3、Vuex-和-localStorage-的区别"><a href="#3、Vuex-和-localStorage-的区别" class="headerlink" title="3、Vuex 和 localStorage 的区别"></a>3、Vuex 和 localStorage 的区别</h3><p>vuex：存储在内存，随页面刷新、关闭而丢失。适用管理实时、响应式数据，组件共享的数据。是专为 Vue 应用设计的集中式状态管理库，适用于管理和共享实时的、响应式的数据，但数据不会自动持久化。</p><p>localstorage：持久化存储在客户端，刷新页面、关闭浏览器后依然存在。适合用户设置、缓存数据。是浏览器内置的持久化存储解决方案，用于保存跨会话数据，但它不是响应式的，不会自动更新 Vue 组件。</p><h3 id="4、Redux-和-Vuex-有什么区别，它们的共同思想"><a href="#4、Redux-和-Vuex-有什么区别，它们的共同思想" class="headerlink" title="4、Redux 和 Vuex 有什么区别，它们的共同思想"></a>4、Redux 和 Vuex 有什么区别，它们的共同思想</h3><p>两者都是负责状态管理的。</p><p><strong>Redux ：</strong> JavaScript 状态管理库，最初为 React 生态设计，但也可用于其他框架。</p><p>单一数据源：整个应用只有一个全局 store。<br>状态只读：状态只能通过派发（dispatch）一个 action 来触发状态变化。<br>纯函数 Reducers：状态的更新由纯函数（reducers）完成，保证同样的输入总会有同样的输出。<br>中间件支持：借助中间件（如 redux-thunk、redux-saga），可以处理异步操作和副作用。</p><p><strong>Vuex：</strong>专为 Vue.js 设计</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502212357438.png" alt="image-20250221175755701"></p><h3 id="5、Vuex有哪几种属性？"><a href="#5、Vuex有哪几种属性？" class="headerlink" title="5、Vuex有哪几种属性？"></a>5、Vuex有哪几种属性？</h3><p>state：整个应用的共享数据，唯一数据源</p><p>mutations：唯一修改state的方法，必须是同步函数，每个mutation接受state为第一个参数</p><p>actions：用于处理异步操作，不能直接修改state，接收一个context对象（commit,state,dispatch,getters等属性），通过commit调用mutation修改。</p><p>getters：类似于计算属性，用来对state进行计算、过滤，加工</p><p>modules：可以把store分成多个模块，每个模块有自己的state、getters、mutations、actions。</p><p>此外，Vuex 的 store 实例还提供了一些方法，如：</p><ul><li><strong>commit</strong>：用于触发 mutations。</li><li><strong>dispatch</strong>：用于触发 actions。</li><li><strong>subscribe</strong>：订阅每次 mutation 后的状态变更。</li><li><strong>watch</strong>：监听 store 中的 state 变化。</li></ul><h3 id="6、Vuex和单纯的全局对象有什么区别？"><a href="#6、Vuex和单纯的全局对象有什么区别？" class="headerlink" title="6、Vuex和单纯的全局对象有什么区别？"></a>6、Vuex和单纯的全局对象有什么区别？</h3><p><strong>响应式自动更新：</strong></p><p>Vuex：利用vue的响应式系统构建，store里面的数据变化时，所有依赖该状态的组件会自动更新</p><p>全局对象：普通的JS对象，不具备内置的响应式机制。</p><p><strong>状态管理：</strong></p><p>Vuex：集中式状态管理，通过单一状态树管理所有共享状态，保证数据来源唯一。</p><p>全局对象：数据分散在各个模块中，缺乏集中管理，容易导致状态难以追踪和维护。</p><p><strong>单向数据流：</strong></p><p>Vuex：强调单向数据流，状态只能通过提交 mutations 或 dispatch actions 修改。</p><p>全局对象：任何地方都可以任意修改全局对象的数据，容易出现数据不一致和难以调试的问题。</p><h3 id="7、为什么-Vuex-的-mutation-中不能做异步操作？"><a href="#7、为什么-Vuex-的-mutation-中不能做异步操作？" class="headerlink" title="7、为什么 Vuex 的 mutation 中不能做异步操作？"></a>7、为什么 Vuex 的 mutation 中不能做异步操作？</h3><p>调试工具依赖同步的mutation记录每一次的状态变化，如果有异步操作，状态更新的顺序就无法确定。</p><p>同步操作保证每次提交 mutation 时，状态都会立即且确定地更新。</p><h3 id="8、Vuex的严格模式"><a href="#8、Vuex的严格模式" class="headerlink" title="8、Vuex的严格模式"></a>8、Vuex的严格模式</h3><p>strict: true, </p><p>严格模式会对 state 进行深度监控。一旦检测到 state 在 mutation 之外发生了变化，就会触发错误或警告。</p><p><strong>保证单向数据流</strong></p><p>通过严格模式，可以确保所有的状态变更都是通过同步的 mutation 来进行！</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> store = new Vuex.Store(&#123;<br>  strict: true, // 开启严格模式<br>  <span class="hljs-keyword">state</span>: &#123;<br>    count: <span class="hljs-number">0</span><br>  &#125;,<br>  mutations: &#123;<br>    increment(<span class="hljs-keyword">state</span>, payload) &#123;<br>      <span class="hljs-keyword">state</span>.count += payload.amount;<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="9、如何在组件中使用Vuex的getter属性"><a href="#9、如何在组件中使用Vuex的getter属性" class="headerlink" title="9、如何在组件中使用Vuex的getter属性"></a>9、如何在组件中使用Vuex的getter属性</h3><p><strong>直接访问</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-built_in">this</span>.<span class="hljs-variable">$store</span>.getters<br></code></pre></td></tr></table></figure><p><strong>mapGetters</strong></p><p>将 getter 映射为组件的计算属性</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>计算后的计数值：</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">doubledCount</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; mapGetters &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">computed</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 使用展开运算符将 getter 映射到计算属性中</span></span></span><br><span class="language-javascript"><span class="language-xml">    ...<span class="hljs-title function_">mapGetters</span>([<span class="hljs-string">&#x27;doubledCount&#x27;</span>])</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 如果需要映射多个 getter：</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// ...mapGetters([&#x27;doubledCount&#x27;, &#x27;someOtherGetter&#x27;])</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 你也可以使用对象形式重新命名：</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// ...mapGetters(&#123; double: &#x27;doubledCount&#x27; &#125;)</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="10、如何在组件中使用Vuex的mutation"><a href="#10、如何在组件中使用Vuex的mutation" class="headerlink" title="10、如何在组件中使用Vuex的mutation"></a>10、如何在组件中使用Vuex的mutation</h3><p><strong>直接使用commit</strong></p><p> <code>this.$store.commit(&#39;mutationName&#39;, payload)</code> </p><p><strong>使用mapMutations</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123; mapMutations &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">methods: &#123;<br>   <span class="hljs-comment">// 将 store 中的 mutation 映射为组件内的方法</span><br>   ..<span class="hljs-selector-class">.mapMutations</span>(<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;increment&#x27;</span>]</span>)<br>   <span class="hljs-comment">// 如果需要重命名，也可以用对象形式：</span><br>   <span class="hljs-comment">// ...mapMutations(&#123; add: &#x27;increment&#x27; &#125;)</span><br> &#125;<br></code></pre></td></tr></table></figure><h2 id="五、Vue3-0"><a href="#五、Vue3-0" class="headerlink" title="五、Vue3.0"></a>五、Vue3.0</h2><h3 id="1、Vue3-0有什么更新"><a href="#1、Vue3-0有什么更新" class="headerlink" title="1、Vue3.0有什么更新"></a>1、Vue3.0有什么更新</h3><p><strong>基于proxy的响应式系统</strong></p><p>vue2依赖Object.defineProperty()实现响应式，但是不能检测对象属性的新增、删除以及数组索引的变化，只能使用Vue.set和Vue.delete动态添加删除。Vue3使用**proxy  API **重写响应式系统，可以自动捕获对象属性的新增和删除。</p><p><strong>Composition API</strong></p><p>Options API (选项式API）是 Vue 2 中的主要编程范式：</p><p>基于组件的选项：data、methods、computed、watch等选项。</p><p>Composition API 是 Vue 3 引入的一种新的编程范式（保留 Options API ）：</p><p>基于setup函数，将相关的功能组合在一起。</p><blockquote><p><code>setup</code> 是 Vue 3 中组件的入口函数：</p><ul><li>定义组件的响应式状态（如 <code>ref</code>、<code>reactive</code>）。</li><li>定义计算属性（<code>computed</code>）。</li><li>定义方法（<code>methods</code>）。</li><li>使用生命周期钩子（如 <code>onMounted</code>、<code>onUpdated</code>）。</li><li>返回需要在模板中使用的数据、方法或计算属性。</li></ul></blockquote><p><strong>性能优化与体积减小</strong></p><p>Vue 3 在运行速度上比 Vue 2 更快，很多内部机制经过优化，渲染速度提升 2~3 倍左右。</p><p>核心库体积比 Vue 2 小约 50%，更适合现代前端项目，且更易进行 Tree Shaking。</p><p>编译器优化，提前提取静态节点，减少运行时计算，优化了虚拟 DOM 更新策略，使得整体性能更佳。</p><p><strong>新特性</strong></p><p>允许组件返回多个根节点，不再强制要求组件模板必须只有一个根元素；</p><p>允许将组件内容渲染到 DOM 的任意位置，使得组件层级结构与渲染位置解耦。</p><p>可以在异步组件加载过程中显示备用内容（如加载动画）</p><p><strong>更好的 TypeScript 支持</strong></p><h3 id="2、Object-defineProperty和proxy的区别"><a href="#2、Object-defineProperty和proxy的区别" class="headerlink" title="2、Object.defineProperty和proxy的区别"></a>2、Object.defineProperty和proxy的区别</h3><p><strong>拦截范围</strong></p><p>Object.defineProperty只能对对象中已存在的属性进行拦截，包括读取和写入。</p><p>proxy可以拦截整个对象的所有操作，包括读取、写入、新增、删除、枚举、函数调用等。</p><p><strong>使用方式</strong></p><p>Object.defineProperty为每个属性单独定义getter和setter</p><p>proxy只需要一次性包装整个对象，通过handler对象统一处理操作</p><p><strong>局限性和优势</strong></p><p>Object.defineProperty性能稳定但无法自动响应新属性的添加删除和数组索引变化。</p><p>proxy功能更全面，可以捕获所有操作，适用范围更广，但在某些极端场景下可能会有额外开销。</p><h2 id="六、虚拟DOM"><a href="#六、虚拟DOM" class="headerlink" title="六、虚拟DOM"></a>六、虚拟DOM</h2><h3 id="1、对虚拟DOM的理解"><a href="#1、对虚拟DOM的理解" class="headerlink" title="1、对虚拟DOM的理解"></a>1、对虚拟DOM的理解</h3><p>虚拟 DOM 是一种用 JavaScript 对象描述真实 DOM 结构的轻量级表示。当数据变化时，框架会生成一个新的虚拟 DOM 树，并与旧的虚拟 DOM 进行对比（使用 Diff 算法），只将发生变化的部分更新到真实 DOM 上，从而提高页面更新的效率，减少直接操作 DOM 带来的性能消耗。</p><p>多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。</p><h3 id="2、虚拟DOM的解析过程"><a href="#2、虚拟DOM的解析过程" class="headerlink" title="2、虚拟DOM的解析过程"></a>2、虚拟DOM的解析过程</h3><p>模板 → AST 生成 → AST 优化 → 代码生成（渲染函数） → 虚拟 DOM 生成 → Diff 算法 → 最小化 DOM 更新</p><p><strong>模板编译</strong>：编译器将模板字符串解析成抽象语法树（AST），AST 节点中包含了元素的类型、属性、子节点以及可能的指令（如 v-if、v-for 等）。</p><p><strong>AST 优化：</strong>在生成 AST 后，Vue 编译器会遍历这棵树，标记出静态节点。这种优化可以在重新渲染时跳过对静态节点的比对，从而提升整体性能。</p><p><strong>生成渲染函数：</strong>优化后的 AST 会被转换成一个渲染函数（render function）。渲染函数中会使用类似 <code>createElement</code> 或者 <code>h()</code> 的 API 来创建虚拟节点（VNode）。这些虚拟节点是轻量的 JavaScript 对象，描述了最终真实 DOM 的结构。</p><p><strong>首次渲染</strong>：当组件实例化时，渲染函数会被调用，生成初始的虚拟 DOM 树，随后 Vue 会利用这个虚拟 DOM 来构建实际的 DOM 结构。</p><p><strong>响应式更新与 Diff 算法：</strong></p><p>当组件中的数据发生变化时：</p><ul><li>Vue 的响应式系统会触发重新调用渲染函数，生成新的虚拟 DOM 树。</li><li>Vue 会将新旧虚拟 DOM 树进行对比（diff 算法），找出需要更新的部分。</li><li>最后，只将必要的差异更新到真实的 DOM 上，这种“最小更新”策略极大提高了性能。</li></ul><h3 id="3、为什么要用虚拟DOM"><a href="#3、为什么要用虚拟DOM" class="headerlink" title="3、为什么要用虚拟DOM"></a>3、为什么要用虚拟DOM</h3><p><strong>性能优化</strong></p><p>直接操作真实 DOM 通常涉及浏览器的重排（reflow）和重绘（repaint），这些操作开销较大，频繁更新可能导致性能瓶颈。虚拟 DOM 作为内存中的 JavaScript 对象，更新速度非常快，通过 Diff 算法对比新旧虚拟 DOM，可以精确计算出实际需要更新的部分，然后只对这部分进行真实 DOM 操作，从而大大减少不必要的重渲染。</p><p>直接修改真实 DOM 时，浏览器需要经过以下几个步骤：<br>解析 HTML 字符串 → 生成新的 DOM 节点 → 构建 CSSOM → 进行 Layout（重排）和 Paint（重绘）。</p><p>虽然构建 vNode 和进行 Diff 的过程会在 JS 层面多消耗一些时间，但相比直接重建整个 DOM 所带来的浏览器重排重绘开销，这部分消耗要便宜很多。</p><p><strong>跨平台</strong>：</p><p>Virtual DOM 仅仅是 JavaScript 中的对象描述，它不依赖于具体的浏览器 DOM 实现。它只是一种抽象的、平台无关的描述方式。</p><ul><li><strong>服务端渲染（SSR）</strong><br>在服务器上，由于没有浏览器的 DOM 环境，直接操作真实 DOM 是不可能的。使用 Virtual DOM，可以先在服务器端生成一个虚拟的 DOM 树，再将其转换为 HTML 字符串发送给客户端。</li><li><strong>解耦视图和平台</strong><br>虚拟 DOM 使得视图的生成和具体平台渲染机制解耦，开发者只需要关注组件逻辑和数据变化，框架会根据不同平台的特性将虚拟 DOM 转换为对应平台的实际视图。</li></ul><h3 id="4、DIFF算法的原理"><a href="#4、DIFF算法的原理" class="headerlink" title="4、DIFF算法的原理"></a>4、DIFF算法的原理</h3><p>Diff 算法通过比较新旧虚拟 DOM 树，找出它们之间的差异，只对发生变化的节点进行更新，而不是重建整个 DOM 树。这就避免了频繁的重排（layout）和重绘（paint）。</p><p><strong>具体比较流程</strong></p><ol><li><p><strong>节点级别的比较：</strong></p><ul><li><strong>节点类型判断：</strong><br>如果新旧 节点的类型不同（例如 <code>&lt;div&gt;</code> 与 <code>&lt;span&gt;</code>），则直接替换整个节点。</li><li><strong>属性对比：</strong><br>对于相同类型的节点，会逐一比较它们的属性（包括 class、style、事件绑定等），只更新发生变化的属性。</li></ul></li><li><p><strong>子节点的比较：</strong></p><ul><li><p><strong>递归对比：</strong><br>对比相同节点下的子节点，递归地采用相同的比较策略。</p></li><li><p>数组和 Key 优化：</p><p>当子节点是一个数组（例如列表）时，通常会使用 key 来标识每个子节点。</p><ul><li><strong>双端比较：</strong><br>通过同时从数组的头尾开始比较，可以快速找出新增、删除或位置变化的节点，从而减少不必要的遍历和重新创建。</li></ul></li></ul></li><li><p><strong>生成差异补丁：</strong></p><ul><li>根据对比的结果，Diff 算法会生成一系列的“补丁”（patches），描述每个需要更新的部分。</li><li>这些补丁最终会被应用到真实 DOM 上，完成局部更新。</li></ul></li></ol><h3 id="5、key的作用"><a href="#5、key的作用" class="headerlink" title="5、key的作用"></a>5、key的作用</h3><p><code>key</code> 为每个元素提供了一个唯一的标识符，帮助 Vue 跟踪每个节点的身份。当列表中的数据发生变化时（如添加、删除或重新排序），Vue 可以通过 <code>key</code> 快速找到对应的节点，从而进行高效的更新操作。</p><p>当列表中的元素顺序发生变化时，没有 <code>key</code> 的情况下，Vue 无法准确判断哪些元素被移动或替换，从而可能导致错误的渲染结果。</p><ol><li><strong>唯一性</strong>：<code>key</code> 应该是唯一的，否则 Vue 无法准确区分元素。</li><li><strong>稳定性</strong>：<code>key</code> 应该是稳定的，即在列表中，同一个元素的 <code>key</code> 值不应该改变。</li><li>**避免使用索引作为 <code>key</code>**：如果列表中的元素顺序可能会变化，建议不要使用数组索引作为 <code>key</code>，因为索引可能会随着元素的增删而改变，导致 Vue 无法准确跟踪元素。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>组件通信</tag>
      
      <tag>生命周期</tag>
      
      <tag>Router路由</tag>
      
      <tag>Vuex</tag>
      
      <tag>虚拟DOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue基础</title>
    <link href="/2025/02/20/Vue%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/02/20/Vue%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue基础"><a href="#Vue基础" class="headerlink" title="Vue基础"></a>Vue基础</h1><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502201826772.png" alt="image-20250220182539746"></p><h2 id="1、Vue的基本原理"><a href="#1、Vue的基本原理" class="headerlink" title="1、Vue的基本原理"></a>1、Vue的基本原理</h2><p>Vue是一款用于构建用户界面的 JavaScript 框架。采用的MVVM架构（Model-View-ViewModel），通过<strong>数据驱动</strong>和<strong>组件化开发</strong>来构建用户界面。</p><p><strong>MVVM架构</strong></p><p>Model，数据层，存储应用的状态数据</p><p>View，视图层，即DOM，展示数据的UI</p><p>VIewModel，视图模型，Vue实例充当ViewModel，负责把View和Model绑定，实现数据的双向绑定，这样数据变化的时候，自动更新视图。视图更新输入，数据也更新。</p><p><strong>响应式系统</strong></p><p>这是Vue的核心，通过观察数据的变换，自动更新视图。</p><p>Vue 2.x 的实现原理：</p><blockquote><p>1、 初始化响应式数据：Vue实例化时，它会遍历<code>data</code>对象的每个属性，并使用<code>Object.defineProperty</code>为每个属性添加<code>getter</code>和<code>setter</code>。</p><p>2、依赖收集：当组件的模版里使用某个数据属性，例如<code>&#123;&#123;name&#125;&#125;</code>，Vue会通过<code>getter</code>读取该属性。在读取属性时，Vue会将当前的视图与该属性关联，这个过程称为依赖收集。</p><p>3、触发更新：当数据属性被修改，<code>setter</code>会触发，并通知所有依赖该属性的视图进行更新。</p></blockquote><p>Vue 3.x 的改进：</p><blockquote><p>使用了ES6的<code>proxy</code> API 来实现响应式系统。优势在于可以拦截更多操作。</p><p>当访问响应式对象的属性时，<code>Proxy</code> 的 <code>get</code> 操作会触发依赖收集。</p><p>当修改响应式对象的属性时，<code>Proxy</code> 的 <code>set</code> 操作会触发更新。</p><p><code>Proxy</code> 可以拦截对象的所有操作，包括新增属性、删除属性、数组操作等，而 <code>Object.defineProperty</code> 无法监听这些操作。</p></blockquote><p><strong>模版编译</strong></p><p>Vue的模板语法（<strong>HTML模板</strong>）是一种声明式语法，用于描述组件的结构和行为。</p><p>在Vue应用运行之前，这些模板会被编译器（Vue Complier）转换成<strong>渲染函数</strong>。</p><p>模版编译的过程：</p><p>1、解析模版：Vue编译器解析模版字符串，将其转换为一个抽象语法树（AST）。</p><p>2、优化AST：对AST抽象语法树进行优化，例如标记静态节点（不随数据变化的节点），以便在后续的渲染过程中减少不必要的操作。</p><p>3、生成渲染函数：将优化后的AST转换为一个JavaScript渲染函数。</p><p><strong>渲染函数</strong></p><p>纯函数，接受组件的上下文<code>_ctx</code>作为参数，返回一个虚拟DOM树。当数据变化时，Vue会重新调用渲染函数，生成新的虚拟DOM树。</p><p><strong>虚拟DOM</strong></p><p>数据变化时，Vue的响应式系统会触发渲染函数重新执行，生成新的虚拟DOM树。然后，Vue的渲染器Render会比较新旧虚拟DOM树，使用 Diff 算法找出差异，将差异应用到真实DOM上。</p><p><strong>组件化</strong></p><p>Vue是基于组件开发的，每个组件都是一个独立的Vue实例，有自己的模版、数据、逻辑、样式。组件之间可以嵌套、组合，实现复杂的分层和模块化管理。</p><p>特点：</p><ul><li>封装性</li><li>可复用性</li><li>可维护性</li><li>声明式语法</li></ul><p><strong>组件通信</strong></p><p>父传子：子用<code>props</code>接收</p><p>子传父： <code>$emit</code> 触发自定义事件</p><p>兄弟通信：事件总线（Event Bus）， <code>EventBus.$emit</code>、  <code>EventBus.$on</code></p><p>跨层级通信：<code>provide</code> 和 <code>inject</code></p><p>全局状态管理：<code>Vuex Store</code></p><p><strong>生命周期</strong></p><p>Vue的生命周期阶段：</p><p>1、创建阶段（组件实例被创建，数据初始化)</p><ul><li>**<code>beforeCreate</code>**：在实例初始化之后被调用，此时实例的数据（data）和事件还未初始化。</li><li>**<code>created</code>**：在实例的数据和事件初始化之后被调用，此时可以访问 data 和 methods。</li></ul><p>2、挂载阶段（组件被插入到 DOM 中）</p><ul><li>**<code>beforeMount</code>**：在组件挂载之前被调用，此时模板已编译，但尚未插入到 DOM 中。</li><li>**<code>mounted</code>**：在组件挂载到 DOM 之后被调用，此时可以访问 DOM 元素。</li></ul><p>3、更新阶段（组件的数据或状态发生变化，导致组件重新渲染）</p><ul><li>**<code>beforeUpdate</code>**：在组件数据更新之前被调用，此时可以访问旧的 DOM 和数据。</li><li>**<code>updated</code>**：在组件数据更新并重新渲染之后被调用，此时可以访问新的 DOM。</li></ul><p>4、销毁阶段（组件被销毁，从 DOM 中移除）</p><ul><li>**<code>beforeDestroy</code>**（Vue 2.x）&#x2F; **<code>beforeUnmount</code>**（Vue 3.x）：在组件销毁之前被调用，此时可以访问组件的所有数据和方法。</li><li>**<code>destroyed</code>**（Vue 2.x）&#x2F; **<code>unmounted</code>**（Vue 3.x）：在组件销毁之后被调用，此时组件已经从 DOM 中移除。</li></ul><h2 id="2、computed-和-watch-的区别"><a href="#2、computed-和-watch-的区别" class="headerlink" title="2、computed 和 watch 的区别"></a>2、computed 和 watch 的区别</h2><p>两种不同的响应式机制，用来处理数据变化时的逻辑。</p><blockquote><p>所有响应式数据都会经过劫持，即Vue会给每个属性设置getter和setter（Vue2使用<code>Object.defineProperty</code>，Vue3使用<code>Proxy</code>），以便在数据读取时收集依赖（订阅者），在数据修改时通知这些依赖进行更新。</p><p>Watcher：Vue内部会为需要响应式更新的操作创建Watcher对象，负责在依赖的数据变化时触发回调（例如重新渲染视图、重新计算computed等）</p></blockquote><p><strong>computed（计算属性）</strong></p><p>基于响应式数据动态派生的值，具有缓存机制，只有当依赖项发生变化时才会重新计算。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">computed</span>: &#123;<br>  <span class="hljs-comment">// 当 firstName 或 lastName 变化时，这个 computed watcher会重新求值</span><br>  <span class="hljs-title function_">fullName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;计算 fullName&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.firstName&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.lastName&#125;</span>`</span>;<br>  &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><blockquote><p>Vue实例初始化时，会遍历computed选项，对每个计算属性创建一个Watcher实例，在模版或者代码中访问计算属性时，会调用其getter。如果 computed watcher 被标记为dirty，则调用getter重新计算值，并缓存结果。如果没有变化，则直接返回缓存值。当依赖的数据变化时，对应的 getter 中调用的响应式数据触发 setter，进而通知相关的 Watcher，将其 <code>dirty</code> 标记为 <code>true</code>。</p></blockquote><p><strong>watch（侦听器）</strong></p><p>用于监听响应式数据的变化，并在数据变化时执行特定的逻辑。当被监听的数据发生变化时，<code>watch</code> 中定义的回调函数会被触发。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe">watch: <span class="hljs-type"></span>&#123;<br>    <span class="hljs-comment">// 当 query 发生变化时，调用 fetchData 函数（可以是异步操作）</span><br>    query(<span class="hljs-keyword">new</span><span class="hljs-type">Val</span>, oldVal) &#123;<br>      console.log(`query 从 $&#123;oldVal&#125; 变为 $&#123;<span class="hljs-keyword">new</span><span class="hljs-type">Val</span>&#125;`);<br>      <span class="hljs-built_in">this</span>.fetchData(<span class="hljs-keyword">new</span><span class="hljs-type">Val</span>);<br>    &#125;<br>  &#125;,<br></code></pre></td></tr></table></figure><blockquote><p>定义一个watch属性时，Vue会为它创建一个普通的Watcher，这个 watcher 会在数据变化时（即 getter 求值时检测到新旧值不同）调用指定的回调函数，并传入新值和旧值。</p></blockquote><p><strong>主要区别</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502201826801.png" alt="image-20250219222115148"></p><p><strong>使用配置对象</strong></p><p>handler：当被监视的源发生变化时，执行的回调函数，接收新值、旧值作为参数。</p><p>immdiate：指示是否在 watcher 初始化后立即调用一次回调</p><p>deep：指定是否对对象或数组进行深度侦听，从而捕捉到所有嵌套属性的变化</p><p>flush（Vue 3）：控制 watcher 回调的执行时机，可选 “pre”（更新前）、”post”（更新后）或 “sync”（同步执行）</p><h2 id="3、methods"><a href="#3、methods" class="headerlink" title="3、methods"></a>3、methods</h2><p><strong>methods</strong></p><p>用于定义组件的方法。它们可以在模板中通过事件绑定或表达式调用，也可以在组件内部直接调用。与data或者computed不同，这些方法不会被Vue自动进行响应式处理、缓存或依赖收集。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta">methods: &#123;<br>    <span class="hljs-comment">// 定义一个方法，用于反转消息</span><br>    reverseMessage() &#123;<br>      <span class="hljs-comment">// 这里的 this 指向 Vue 实例，可以访问 data 中的 message 属性</span><br>      <span class="hljs-keyword">this</span>.message = <span class="hljs-keyword">this</span>.message.split(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-keyword">reverse</span>().<span class="hljs-keyword">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><blockquote><p>创建Vue实例时，Vue会遍历配置对象中的methods，并把每个方法挂载到Vue实例上。可以通过<code>this.methodName</code>调用方法，也可以用事件绑定<code>@click=&quot;methodName&quot;</code>的形式调用方法。</p><p>所有在<code>methods</code>中定义的函数上下文（this）绑定到实例上。这样方法内部的this就都指向Vue实例，从而可以访问<code>data</code>、<code>computed</code>、<code>props</code>等属性。</p></blockquote><h2 id="4、slot"><a href="#4、slot" class="headerlink" title="4、slot"></a>4、slot</h2><p>slot是一种内容分发机制（内容插槽机制），用于在组件内部预留“占位符”，让父组件能够将内容插入到子组件预留的位置，从而实现内容的分发和复用。</p><p><strong>解决的问题</strong>：<br>组件封装的同时仍然允许外部传入 HTML 或其他组件，使得组件既能保持内部逻辑封装，又能灵活地展示外部内容。</p><p><strong>插槽的类型</strong></p><ul><li><p>默认插槽：父组件没有给子组件提供具名插槽内容时，默认插槽会渲染默认内容，或者渲染父组件传入的内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>默认主体内容<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>具名插槽：通过 <code>name</code> 属性指定插槽名称。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span>默认头部内容<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br></code></pre></td></tr></table></figure><p>父组件要使用 <code>template</code> 标签，并通过 <code>v-slot</code> 指令（或简写 <code>#</code>）指定插槽名称：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>这是自定义头部<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>作用域插槽：作用域插槽允许子组件向父组件传递数据。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">// 子<br><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">:user</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span>默认内容<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">// 父 </span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>接收到的内容：</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">slotProps.content</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul><h2 id="5、filters过滤器"><a href="#5、filters过滤器" class="headerlink" title="5、filters过滤器"></a>5、filters过滤器</h2><p>是一种用于格式化数据的工具，用于在模板中对数据进行格式化。例如格式化日期、货币、字符串大小写转换等。它们可以被定义为全局过滤器或局部过滤器，在模板中通过管道符号（<code>|</code>）使用。</p><p>过滤器是 Vue 2.x 中的一个特性，但在 Vue 3.x 中已被移除。</p><p><strong>过滤器是一个函数</strong>，接收原始数据作为输入，并返回格式化后的数据。</p><p><strong>局部过滤器：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">filters</span>: &#123;<br>  <span class="hljs-title function_">capitalize</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!value) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>() + value.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>全局过滤器：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Vue.<span class="hljs-built_in">filter</span>(<span class="hljs-string">&#x27;capitalize&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!value) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">return</span> value.charAt(<span class="hljs-number">0</span>).toUpperCase() + value.<span class="hljs-built_in">slice</span>(<span class="hljs-number">1</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>在模板中使用过滤器</strong></p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">message</span> | capitalize &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="6、如何保存页面的当前的状态"><a href="#6、如何保存页面的当前的状态" class="headerlink" title="6、如何保存页面的当前的状态"></a>6、如何保存页面的当前的状态</h2><p>页面状态是指页面在某一时刻的所有数据和配置信息的集合。</p><p><strong>可能包括：</strong><br>用户输入：如表单字段的内容。<br>显示内容：如列表数据、文本内容等。<br>加载状态：如是否正在加载数据、加载进度等。<br>UI 状态：如是否显示某个弹窗、是否折叠某个面板等。<br>路由信息：如当前页面的 URL、路由参数等。</p><p><strong>为什么要保存</strong></p><p>1、<strong>用户体验</strong>：当用户离开页面后再次返回时，页面能够恢复到用户离开时的状态，避免用户重新操作。</p><p>2、<strong>数据持久化</strong>：将页面状态保存到本地存储（如 <code>localStorage</code> 或 <code>sessionStorage</code>），以便在页面刷新或关闭后仍能恢复。</p><p>3、<strong>跨页面共享</strong>：将页面状态传递给其他页面或组件，实现数据共享。</p><p><strong>方法</strong></p><p><strong>1、使用浏览器存储（localStorage &#x2F; sessionStorage）</strong></p><blockquote><p><strong>localStorage</strong>：数据会一直保存，即使浏览器关闭也不丢失，除非主动清除。</p><p><strong>sessionStorage</strong>：数据在当前会话（tab 或 window）中保存，关闭页面或浏览器后数据会丢失。</p><p>数据以键值对的形式存储，通常以字符串格式保存（需要用 JSON.stringify&#x2F;JSON.parse 进行转换）。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 存储到 localStorage 中</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;pageState&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(state));<br><br><span class="hljs-comment">// 读取状态（通常在页面加载时执行）</span><br><span class="hljs-keyword">const</span> savedState = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;pageState&#x27;</span>) || <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>2、使用 URL 参数或 Hash</strong></p><blockquote><p>将页面状态编码在 URL 的查询字符串或哈希值中。用户在刷新或分享 URL 时，状态可以通过解析 URL 得到。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 保存状态到 URL 查询参数中</span><br><span class="hljs-keyword">const</span> pageState = &#123; currentPage: <span class="hljs-number">3</span>, filter: <span class="hljs-string">&#x27;active&#x27;</span> &#125;;<br><span class="hljs-keyword">const</span> queryString = <span class="hljs-keyword">new</span> URLSearchParams(pageState).toString();<br>window.history.replaceState(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;?&#x27;</span> + queryString);<br><br><span class="hljs-comment">// 读取 URL 参数恢复状态</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">params</span> = <span class="hljs-keyword">new</span> URLSearchParams(window.location.search);<br><span class="hljs-keyword">const</span> currentPage = <span class="hljs-keyword">params</span>.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;currentPage&#x27;</span>);<br><span class="hljs-keyword">const</span> filter = <span class="hljs-keyword">params</span>.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;filter&#x27;</span>);<br>console.log(currentPage, filter);<br></code></pre></td></tr></table></figure><p><strong>3、 利用 History API 的 State 对象</strong></p><blockquote><p>TML5 提供了 History API（如 <code>history.pushState</code> 和 <code>history.replaceState</code>），可以将状态对象与历史记录关联。当用户使用浏览器的前进后退按钮时，可以通过 <code>history.state</code> 获取之前保存的状态。</p></blockquote><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pf">// 保存状态到当前历史记录中<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">state</span> = &#123; tab: &#x27;<span class="hljs-keyword">profile</span>&#x27;, scrollTop: window.pageYOffset &#125;;<br>history.replaceState(<span class="hljs-keyword">state</span>, &#x27;&#x27;, window.location.href);<br><br>// 读取历史记录中的状态<br><span class="hljs-keyword">const</span> savedState = history.<span class="hljs-keyword">state</span>;<br>if (savedState) &#123;<br>  console.<span class="hljs-keyword">log</span>(&#x27;当前激活的 tab：&#x27;, savedState.tab);<br>  window.scrollTo(<span class="hljs-number">0</span>, savedState.scrollTop);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4、 在 Vue 应用中的状态管理</strong></p><blockquote><p><strong>Vuex</strong>：集中存储应用的所有状态，通过 mutations 和 actions 修改状态，并且可以利用插件（如 vuex-persistedstate）将状态持久化到 localStorage。</p><p><strong>Pinia</strong>：Vue 3 推荐的状态管理库，具有类似 Vuex 的特性，也支持状态持久化。</p></blockquote><p>1、安装插件</p><p>2、在VueX store中配置</p><p>3、在组件中使用</p><h2 id="7、常见的事件修饰符及其作用"><a href="#7、常见的事件修饰符及其作用" class="headerlink" title="7、常见的事件修饰符及其作用"></a>7、常见的事件修饰符及其作用</h2><p>事件修饰符，是一种语法糖，用于在模板中对事件处理器进行预处理，从而实现简单的事件行为操作。</p><ul><li><p>.stop：调用<code>event.stopPropagation()</code>，阻止事件向父级元素冒泡。点击事件只在当前元素上触发，不再传递给父组件或父元素时使用。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">&lt;button @click.stop=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;点击我&lt;/button&gt;<br></code></pre></td></tr></table></figure></li><li><p>.prevent：调用 <code>event.preventDefault()</code>，阻止事件的默认行为（如提交表单、链接跳转）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>=<span class="hljs-string">&quot;handleSubmit&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>.stop.prevent：同时阻止事件冒泡和默认行为，可以连写。</p></li></ul>  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">&lt;<span class="hljs-keyword">a</span> href=<span class="hljs-string">&quot;https://example.com&quot;</span> @click.<span class="hljs-built_in">stop</span>.prevent=<span class="hljs-string">&quot;handleLinkClick&quot;</span>&gt;点击链接&lt;/<span class="hljs-keyword">a</span>&gt;<br></code></pre></td></tr></table></figure><ul><li><p>.capture：在事件捕获阶段触发事件处理器，而不是等待事件冒泡到目标元素时使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click.capture</span>=<span class="hljs-string">&quot;handleCapture&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleButtonClick&quot;</span>&gt;</span>点击按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>.self：只有事件的目标（event.target）是绑定事件的元素本身时才触发处理器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 只有点击 div 自身才触发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click.self</span>=<span class="hljs-string">&quot;handleSelfClick&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;padding: 20px; border: 1px solid #ccc;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>点击我不会触发 div 的事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>点击空白区域才触发 div 的事件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>.once：事件处理器只触发一次，触发后自动解绑。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.once</span>=<span class="hljs-string">&quot;handleOnce&quot;</span>&gt;</span>只点击一次有效<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>.passive(vue3)：告诉浏览器，这个事件监听器不会调用 <code>event.preventDefault()</code>。监听器是“被动”的（passive），浏览器可以放心地继续执行默认操作（如页面滚动）。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">touchmove.passive</span>=<span class="hljs-string">&quot;handleTouchMove&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 200px; overflow: scroll;&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-comment">&lt;!-- 内容很多的区域 --&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;i in 50&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;i&quot;</span>&gt;</span>第 </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">i</span> &#125;&#125;</span><span class="language-xml"> 行<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>.native：用于自定义组件上，想监听该组件根元素的原生 DOM 事件时使用。</p><blockquote><p><strong>区分自定义事件和原生事件</strong>：<br>创建一个自定义组件时，可以在组件内部通过 <code>$emit(&#39;click&#39;)</code> 发出一个事件。父组件如果写 <code>&lt;my-component @click=&quot;handler&quot;&gt;</code>，默认是监听这个自定义事件，而不是组件根元素的 DOM 事件。</p><p>使用 <code>.native</code> 修饰符时，Vue 会将事件监听器直接绑定到自定义组件的根 DOM 元素上（即组件模板的最外层元素），从而捕获该 DOM 元素上触发的原生事件。</p></blockquote><p>在 Vue 3.x 中，<code>.native</code> 修饰符已被移除，Vue 3 提供了更灵活的事件监听机制，可以直接在自定义组件上监听原生事件。Vue 3 会自动将 <code>@click</code> 绑定到 <code>&lt;CustomButton&gt;</code> 的根元素上，无需 <code>.native</code> 修饰符。</p></li></ul><h2 id="8、v-if、v-show、v-html-指令的原理"><a href="#8、v-if、v-show、v-html-指令的原理" class="headerlink" title="8、v-if、v-show、v-html 指令的原理"></a>8、v-if、v-show、v-html 指令的原理</h2><p><strong>1、v-if</strong>：决定是否在DOM中创建、销毁元素。</p><blockquote><p>当条件为 <strong>true</strong> 时，Vue 会生成该元素的虚拟 DOM，并挂载到真实 DOM 上。</p><p>当条件为 <strong>false</strong> 时，该元素及其子节点完全不会出现在 DOM 中，也不会占用任何内存。</p></blockquote><p>使用场景：切换频率低、大量DOM节点。使用 v-if 可以避免不必要的渲染开销。但由于每次切换都需要重新创建或销毁 DOM，所以切换频繁时性能可能不如 v-show。</p><p><strong>2、v-show</strong>：基于 CSS 的显示隐藏。</p><blockquote><p>无论条件是否为 true，都始终会在 DOM 中渲染该元素。只是通过修改元素的 CSS 属性（<code>display</code>）来控制元素的可见性。相当于display 属性被设置为 <code>none</code>。</p></blockquote><p><strong>3、v-html</strong>：将一个字符串解析为 HTML，然后插入到元素内部。</p><blockquote><p>会将绑定的字符串直接设置为元素的 <code>innerHTML</code>，从而渲染出相应的 HTML 内容。</p></blockquote><h2 id="9、-v-model-是如何实现的"><a href="#9、-v-model-是如何实现的" class="headerlink" title="9、 v-model 是如何实现的"></a>9、 v-model 是如何实现的</h2><p>v-model实现了数据的双向绑定。</p><p>语法糖：在表单模板中写 <code>&lt;input v-model=&quot;message&quot;&gt;</code> 实际上是 Vue 内部自动转换成类似下面的代码：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;input :<span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;message&quot;</span> @<span class="hljs-attribute">input</span>=<span class="hljs-string">&quot;message = <span class="hljs-variable">$event</span>.target.value&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>父组件使用 v-model：本质通过prop和$.emit实现。在自定义组件上使用 <code>v-model</code> 时，Vue 会默认将其绑定到组件的 <code>value</code> prop 上，并监听组件发出的 <code>input</code> 事件。</p><h2 id="10、data为什么是一个函数而不是对象"><a href="#10、data为什么是一个函数而不是对象" class="headerlink" title="10、data为什么是一个函数而不是对象"></a>10、data为什么是一个函数而不是对象</h2><p>让每个组件都有自己独立的数据副本，而不是共享一个对象，有利于组件的复用！</p><p><strong>组件数据隔离</strong>：<br>将 <code>data</code> 定义为函数可以确保每个组件实例拥有独立的数据副本，避免状态共享带来的副作用。‘</p><p><strong>根实例特殊性</strong>：<br>由于根实例只有一个，所以可以将 <code>data</code> 定义为对象；但组件（可复用、多实例）必须使用函数返回数据对象。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">data</span>() &#123;</span><br><span class="hljs-class">   <span class="hljs-title">return</span> &#123;</span><br><span class="hljs-class">     <span class="hljs-title">count</span>: 0</span><br><span class="hljs-class">   &#125;;</span><br> &#125;,<br></code></pre></td></tr></table></figure><h2 id="11、对keep-alive的理解"><a href="#11、对keep-alive的理解" class="headerlink" title="11、对keep-alive的理解"></a>11、对keep-alive的理解</h2><p>包装器组件，不渲染实际的DOM元素，而是作为一个抽象组件，通过内部机制缓存子组件的实例状态。</p><p>缓存动态组件的实例，避免反复创建与销毁。</p><blockquote><p><code>&lt;keep-alive&gt;</code> 内部会维护一个缓存对象，当子组件第一次渲染时，会把其 VNode 存储起来；当切换到其他组件时，被缓存的组件不会调用销毁钩子（如 <code>beforeDestroy</code>、<code>destroyed</code>），而是调用 <code>deactivated</code> 钩子；当组件再次激活时，则调用 <code>activated</code> 钩子。</p><p><strong>activated</strong>：当组件被激活（即从缓存中恢复显示）时调用。</p><p><strong>deactivated</strong>：当组件被停用（即离开视图，但缓存保留）时调用。</p></blockquote><p>通过 <code>include</code> 和 <code>exclude</code> 属性精确控制哪些组名称需要缓存。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs elixir">// <span class="hljs-symbol">:is</span> 属性用于动态绑定组件的名称或对象<br>&lt;keep-alive include=<span class="hljs-string">&quot;Home,About&quot;</span>&gt;<br>  &lt;component <span class="hljs-symbol">:is=<span class="hljs-string">&quot;view&quot;</span>&gt;&lt;/component&gt;</span><br>&lt;/keep-alive&gt;<br><br>&lt;keep-alive exclude=<span class="hljs-string">&quot;Login&quot;</span>&gt;<br>  &lt;component <span class="hljs-symbol">:is=<span class="hljs-string">&quot;view&quot;</span>&gt;&lt;/component&gt;</span><br>&lt;/keep-alive&gt;<br></code></pre></td></tr></table></figure><h2 id="12、-nextTick-原理及作用"><a href="#12、-nextTick-原理及作用" class="headerlink" title="12、$nextTick 原理及作用"></a>12、$nextTick 原理及作用</h2><p>修改了响应式数据后，数据更新后，DOM 可能还没有完成更新。</p><p><code>$nextTick</code> 允许在 DOM 更新完成后执行回调函数。确保在回调函数执行时，DOM 已经完成了所有由当前数据变化引起的更新。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// DOM 更新并不是立即完成的</span><br><span class="hljs-comment">// 使用 $nextTick 来确保在 DOM 更新后执行操作</span><br>this.$nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.<span class="hljs-symbol">$refs</span>.<span class="hljs-built_in">text</span>.textContent); <span class="hljs-comment">// 此时会输出最新的文本内容</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="13、给-data-中的对象属性添加一个新的属性"><a href="#13、给-data-中的对象属性添加一个新的属性" class="headerlink" title="13、给 data 中的对象属性添加一个新的属性"></a>13、给 data 中的对象属性添加一个新的属性</h2><p>Vue 2 采用 <code>Object.defineProperty</code> 对已存在的属性进行响应式处理，而无法检测后续新增的属性。自然就不会触发视图的更新。</p><p>使用<strong>Vue.set</strong>、<strong>this.$set</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 使用 $set 方法添加新属性 b，并赋值 2</span><br><span class="hljs-keyword">this</span>.$<span class="hljs-keyword">set</span>(<span class="hljs-keyword">this</span>.myObject, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>);<br><span class="hljs-comment">// 或者使用 Vue.set(this.myObject, &#x27;b&#x27;, 2);</span><br></code></pre></td></tr></table></figure><p>在 Vue 3 中，由于采用了 ES6 的 <code>Proxy</code> 实现响应式，所以直接添加新属性也能被拦截，从而实现响应式更新，因此这个问题在 Vue 3 中不存在。</p><h2 id="14、Vue封装数组的方法"><a href="#14、Vue封装数组的方法" class="headerlink" title="14、Vue封装数组的方法"></a>14、Vue封装数组的方法</h2><p>为了实现数组的响应式更新，Vue对数组的方法进行封装或者重写，确保调用他它们的时候能通知依赖更新，让视图随着数组的变化得到更新。调用方法时，Vue会在执行原有逻辑的同时触发依赖收集器的通知，让所有依赖该数组的watcher得到更新，从而重新渲染视图。</p><blockquote><ul><li><strong>push</strong>：向数组末尾添加一个或多个元素。</li><li><strong>pop</strong>：从数组末尾移除最后一个元素。</li><li><strong>shift</strong>：从数组头部移除第一个元素。</li><li><strong>unshift</strong>：向数组头部添加一个或多个元素。</li><li><strong>splice</strong>：在数组的指定位置添加或删除元素。</li><li><strong>sort</strong>：对数组进行排序。</li><li><strong>reverse</strong>：反转数组中元素的顺序。</li></ul></blockquote><p>使用索引修改数组元素，不会被响应式系统检测到。需要使用set。</p><p><code>Vue.set(this.items, index, newValue)</code> 或 <code>this.$set(this.items, index, newValue)</code>。</p><p>在 Vue 3 中，由于采用了 ES6 的 <code>Proxy</code> 实现响应式，所以可以直接检测数组的新增、修改等操作，无需像 Vue 2 那样重写数组方法。</p><h2 id="15、Vue-单页应用与多页应用的区别"><a href="#15、Vue-单页应用与多页应用的区别" class="headerlink" title="15、Vue 单页应用与多页应用的区别"></a>15、Vue 单页应用与多页应用的区别</h2><p>单页应用SPA：通常只有一个HTML文件，整个应用在首次加载时通过JS加载所有必要资源（HTML，CSS，JS，图片等）。使用Vue Router路由库在客户端进行路由管理，根据URI变化加载不同的组件或者视图，无需刷新整个页面。根据用户操作动态切换视图，所有页面切换都在当前页面完成，不会触发页面重新加载。整个应用由一个根实例管理，数据状态可以在各个组件之间共享和传递。</p><p>多页应用MPA：每个页面都有独立的HTML文件，页面切换依赖服务器加载不同的页面。页面导航也是由服务器处理，每次跳转要完整刷新页面，每个页面都是相对独立的应用，数据状态不会跨页面共享，依赖后端管理或者浏览器存储。</p><h2 id="16、Vue自定义指令"><a href="#16、Vue自定义指令" class="headerlink" title="16、Vue自定义指令"></a>16、Vue自定义指令</h2><p>指令：带有v-前缀的特殊属性，用来操作DOM的（条件渲染v-if、绑定-bind等）</p><p>自定义指令：封装DOM操作逻辑</p><p>定义对象时，可以包含多个钩子函数：</p><blockquote><p>Vue 2 自定义指令的钩子名称:</p><p><strong>bind</strong>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性初始化设置，但此时还没有插入 DOM。</p><p><strong>inserted</strong>：被绑定元素插入到 DOM 时调用，此时可以操作 DOM。</p><p><strong>update</strong>：所在组件的 VNode 更新时调用，但可能发生在子节点更新之前。</p><p><strong>componentUpdated</strong>：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</p><p><strong>unbind</strong>：只调用一次，指令与元素解绑时调用，用于清理工作。</p></blockquote><blockquote><p>Vue 3 自定义指令的钩子名称一般为：</p><ul><li><strong>created</strong>：指令第一次绑定到元素时调用，且在挂载前调用。</li><li><strong>beforeMount</strong>：在元素插入 DOM 前调用。</li><li><strong>mounted</strong>：在元素插入 DOM 后调用（通常用来操作 DOM）。</li><li><strong>beforeUpdate</strong>：在组件更新前调用。</li><li><strong>updated</strong>：在组件更新后调用。</li><li><strong>beforeUnmount</strong>：在指令解绑前调用。</li><li><strong>unmounted</strong>：在指令解绑后调用。</li></ul></blockquote><h2 id="17、子组件可以直接改变父组件的数据吗"><a href="#17、子组件可以直接改变父组件的数据吗" class="headerlink" title="17、子组件可以直接改变父组件的数据吗"></a>17、子组件可以直接改变父组件的数据吗</h2><p>在 Vue 中，子组件不能直接修改父组件的数据，因为父组件通过 props 向子组件传递的数据是只读的。</p><p>父组件向子组件传递数据时，子组件通过 props 接收。Vue 将这些 props 设置为只读属性，目的是防止子组件直接修改父组件的数据，以保持数据流向的清晰和可预测。</p><p>如果子组件需要改变父组件的数据，应该通过触发事件（例如使用 <code>this.$emit</code>）来通知父组件，由父组件在接收到事件后进行数据修改。这样既遵循了单向数据流，也保持了组件间的解耦。</p><h2 id="18、-Vue是如何收集依赖的"><a href="#18、-Vue是如何收集依赖的" class="headerlink" title="18、 Vue是如何收集依赖的"></a>18、 Vue是如何收集依赖的</h2><p>每个data属性在初始化时会被遍历，被<code>Object.defineProperty</code>劫持，给每个属性添加getter和setter。这样读取属性时会执行getter，修改属性时，会执行setter。</p><p>Dep依赖管理器：每个响应式属性都有一个关联的Dep对象，负责维护依赖列表，保存所有依赖的引用。</p><p>Watcher：每个组件渲染过程都会创建一个Watcher，代表了组件的渲染函数。渲染的时候，Watcher会访问data中的响应式属性，从而触发这些属性的getter。</p><p><strong>依赖收集的流程</strong></p><p>1、设置Watcher：组件渲染时，把当前watcher赋值给全局的Dep.target。</p><p>2、读取数据，触发getter：渲染过程中，在模板读取data中的属性时，调用该属性的getter。getter内部会调用Dep.depend。</p><p>3、注册依赖：depend方法检查当前有没有Dep.target，有就把Watcher添加到当前属性对应的Dep中，Watcher也会把这个Dep收集起来。</p><p>4、数据更新通知：数据变化时，setter被调用，通知对应的Dep对象。然后Dep会遍历所有订阅的watcher，触发它们的更新，进而重新渲染组件或者重新计算计算属性。</p><h2 id="19、assets和static的区别"><a href="#19、assets和static的区别" class="headerlink" title="19、assets和static的区别"></a>19、assets和static的区别</h2><p>两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下。</p><p>如果资源需要在组件中动态引用、参与模块化打包、优化、缓存控制，建议放在 <strong>assets</strong> 文件夹中。</p><p>如果资源不需要经过打包处理，且希望保持原始文件名和内容（例如外部库、静态 HTML、favicon 等），则放在 <strong>static&#x2F;public</strong> 文件夹中。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502201826748.png"></p><h2 id="20、Vue如何做性能优化"><a href="#20、Vue如何做性能优化" class="headerlink" title="20、Vue如何做性能优化"></a>20、Vue如何做性能优化</h2><p>1、异步批量更新</p><p>利用 <code>this.$nextTick()</code> 确保在 DOM 更新后执行依赖最新 DOM 状态的逻辑。</p><p>2、合理使用计算属性</p><p>将复杂的衍生数据计算封装为 computed 属性，而不是放在 methods 中每次调用时重新计算。计算属性具有缓存特性，只在依赖数据发生变化时重新计算，避免重复计算。</p><p>3、合理选择 v-if 与 v-show</p><p><strong>v-if</strong>：适用于不频繁切换的场景，因为每次切换会创建或销毁 DOM。</p><p><strong>v-show</strong>：适用于频繁切换的场景，因为它只改变 CSS 的 display 属性，不会销毁 DOM。</p><p>4、使用 keep-alive 缓存组件</p><p><code>&lt;keep-alive&gt;</code> 会缓存被包裹的动态组件实例，避免重复创建，保留组件状态。</p><p>5、动态 import &amp; 路由懒加载</p><p>在路由配置中使用动态 import，减少初始加载文件大小，按需加载，提升首屏加载速度。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const Home = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./components/Home.vue&#x27;</span>);<br></code></pre></td></tr></table></figure><p>6、Tree Shaking：利用 webpack 移除未使用的代码，减小打包文件体积。</p><p>7、图片与静态资源优化：使用合适的 Loader 对图片、字体等资源进行压缩、优化，生成带 hash 值的文件名以利于缓存。将无需处理的静态资源放在 public 文件夹中，直接复制到输出目录，减少构建时间。</p><p>8、全局状态管理：使用 Vuex 或 Pinia 集中管理状态，避免不必要的组件间数据传递和重复渲染。</p><p>9、服务端渲染（SSR）：对于需要 SEO 和快速首屏加载的应用，可以使用 Nuxt.js 等解决方案进行服务端渲染，将初始内容在服务器端生成并发送给浏览器。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MVVM</tag>
      
      <tag>响应式数据</tag>
      
      <tag>模版编译</tag>
      
      <tag>组件通信</tag>
      
      <tag>computed</tag>
      
      <tag>watch</tag>
      
      <tag>slot</tag>
      
      <tag>保存页面状态</tag>
      
      <tag>事件修饰符</tag>
      
      <tag>v-if</tag>
      
      <tag>v-show</tag>
      
      <tag>v-model</tag>
      
      <tag>keep-alive</tag>
      
      <tag>$nextTick</tag>
      
      <tag>Vue.set</tag>
      
      <tag>自定义指令</tag>
      
      <tag>依赖收集</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS里面的一些重点</title>
    <link href="/2025/02/19/JS%E9%87%8C%E9%9D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E9%87%8D%E7%82%B9/"/>
    <url>/2025/02/19/JS%E9%87%8C%E9%9D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E9%87%8D%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="JS里面的一些重点"><a href="#JS里面的一些重点" class="headerlink" title="JS里面的一些重点"></a>JS里面的一些重点</h1><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502191546818.png" alt="image-20250219154522454"></p><h2 id="1、原型和原型链"><a href="#1、原型和原型链" class="headerlink" title="1、原型和原型链"></a>1、原型和原型链</h2><p>JavaScript 中所有的对象都有一个内置属性，称为它的 <strong>prototype</strong>（原型）。它本身是一个对象，故原型对象也会有它自己的原型，逐渐构成了<strong>原型链</strong>。原型链终止于拥有 <code>null</code> 作为其原型的对象上。</p><blockquote><p>末端通常是 <code>Object.prototype</code>，其 <code>[[Prototype]]</code> 为 <code>null</code>）</p></blockquote><p><strong>函数的prototype属性</strong></p><p>当我们定义函数时，JS会自动为它创建一个<code>prototype</code>属性，这是一个对象，里面存放了通过该构造函数创建实例时共享的属性和方法。</p><p><strong>对象的内部原型链接</strong></p><p>每个对象都有一个内部属性，通常用<code>[[Prototype]]</code>表示，指向原型对象，也就是构造该对象的模版对象。可以通过<code>__proto__</code>访问这个链接，也可以使用<code>Object.getPropertyOf(obj</code>)来获取。</p><p><strong>对象创建时，自动设置原型对象</strong></p><p>当使用构造函数创建对象时（使用new关键字），新对象的<code>[[Prototype]]</code>会自动设置为构造函数的<code>prototype</code>对象。</p><p><strong>原型链</strong></p><p>原型链就是对象及其内部属性<code>[[Prototype]]</code>属性形成的一条链。</p><p>当我们访问一个对象的属性时，JS引擎首先在对象自身查找。如果没有找到，沿着原型链依次查找其原型、原型的原型…直到找到该属性或者达到链的末端（通常是 <code>Object.prototype</code>，其 <code>[[Prototype]]</code> 为 <code>null</code>）</p><p><strong>修改原型</strong></p><ul><li><p>在原型对象上添加或修改属性：所有实例都会通过原型链获得最新的值。</p></li><li><p>直接替换原型：会丢失自动生成的<code>constructor</code>属性。需要手动修复。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>  <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Person</span>,  <span class="hljs-comment">// 修复 constructor 属性</span><br>  <span class="hljs-attr">sayHi</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hi, I&#x27;m &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p><strong>获取对象上非原型链上的属性</strong>：<code>obj.hasOwnProperty(key)</code></p><h2 id="2、闭包-Closure"><a href="#2、闭包-Closure" class="headerlink" title="2、闭包 Closure"></a>2、闭包 Closure</h2><p><strong>闭包的定义</strong>：是指一个函数和其创建时的词法环境的组合。闭包允许函数记住并访问它定义时所在的作用域，即使这个函数在其作用域外执行。</p><p>例如，下面的内部函数能够访问外部函数的局部变量，即使外部函数执行结束，局部变量<code>a</code>仍然存在于闭包中。内部函数和其引用的变量<code>a</code> 共同构成了一个闭包。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>; <span class="hljs-comment">// outer 的局部变量</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a); <span class="hljs-comment">// inner 能访问 a</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> inner;<br>&#125;<br><br><span class="hljs-keyword">var</span> closureFn = outer(); <span class="hljs-comment">// outer 执行后返回 inner</span><br>closureFn(); <span class="hljs-comment">// 输出 1，inner 依然可以访问 a</span><br></code></pre></td></tr></table></figure><p><strong>闭包的形成和原理</strong></p><ul><li>词法作用域：函数定义时就确定了作用域，不是运行时决定的。闭包依赖了这个特性，内部函数保存了其创建时的作用域环境。</li><li>函数和环境的绑定：当函数被创建，JS引擎会为其生成一个隐式属性，指向其定义时的作用域链。这样即使外部函数已经执行完毕，内部函数仍然可以通过这条作用域链访问到外部函数的局部变量。</li><li>内存和声明周期：闭包持有对外部变量的引用，所以外部变量不会被垃圾回收器立即回收。</li></ul><p><strong>闭包的常见用途</strong></p><ul><li><p>私有变量，数据封装</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) &#123;<br>  let <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 私有变量</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">increment</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-built_in">count</span>++;<br>      <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">count</span>);<br>    &#125;,<br>    <span class="hljs-attr">decrement</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-built_in">count</span>--;<br>      <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">count</span>);<br>    &#125;<br>  &#125;;<br>&#125;<br><br>let counter = createCounter();<br>counter.increment(); <span class="hljs-comment">// 输出 1</span><br>counter.decrement(); <span class="hljs-comment">// 输出 0</span><br><span class="hljs-comment">// 无法直接访问 count</span><br></code></pre></td></tr></table></figure></li><li><p>函数工厂，创建定制化的函数</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeAdder</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">y</span>) &#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>  &#125;;<br>&#125;<br><br>let add5 = makeAdder(<span class="hljs-number">5</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(add5(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 8</span><br><br></code></pre></td></tr></table></figure></li><li><p>实现模块化，封装变量和函数，暴露有限的接口</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> Module = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> privateVar = <span class="hljs-string">&quot;I am private&quot;</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">privateMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(privateVar);<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">publicMethod</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      privateMethod();<br>    &#125;<br>  &#125;;<br>&#125;)();<br><br>Module.publicMethod(); <span class="hljs-comment">// 输出 &quot;I am private&quot;</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>注意事项</strong></p><ul><li>内存泄露：闭包会让外部变量在闭包一直存在，消耗内存，要注意及时解除不再需要的引用，</li><li>性能问题：大量的闭包引用大量的数据，可能导致额外的内存占用</li><li>调试难度：涉及作用域链，可能会增加调试复杂度</li></ul><p><strong>？</strong> 循环中使用闭包解决 var 定义函数的问题</p><blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  setTimeout(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(i)<br>  &#125;, i * <span class="hljs-number">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>1、var修改为let</p><p>2、闭包+立即执行函数</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) &#123;<br>    setTimeout(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(j);<br>    &#125;, j * <span class="hljs-number">1000</span>);<br>  &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="3、作用域和作用域链"><a href="#3、作用域和作用域链" class="headerlink" title="3、作用域和作用域链"></a>3、作用域和作用域链</h2><p><strong>概念</strong></p><p>作用域指的是代码中定义变量和函数的区域，以及这些变量和函数能够被访问的范围。</p><p>JS使用的是词法作用域，代码编写时就确定，不是运行时动态决定的。</p><p><strong>主要类型</strong></p><p>全局作用域：在代码的最外层定义的变量和函数，在整个程序中都可以访问</p><blockquote><ul><li><p>最外层函数和最外层函数外面定义的变量拥有全局作用域</p></li><li><p>所有未定义直接赋值的变量自动声明为全局作用域</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>  bar = <span class="hljs-number">10</span>; <span class="hljs-comment">// bar 未用 var/let/const 声明，将自动成为全局变量</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>所有window对象的属性拥有全局作用域</p></li><li><p>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</p></li></ul></blockquote><p>函数作用域：每个函数创建一个独立的作用域，函数内部定义的变量只在函数内可见</p><p>块级作用域：使用<code>let</code>和<code>const</code>定义的变量具有块级作用域，在大括号内有效</p><blockquote><ul><li>let和const声明的变量不会有变量提升，也不可以重复声明</li><li>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li></ul></blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 全局作用域</span><br><span class="hljs-keyword">var</span> globalVar = <span class="hljs-string">&quot;global&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// outer 的作用域</span><br>  <span class="hljs-keyword">var</span> outerVar = <span class="hljs-string">&quot;outer&quot;</span>;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// inner 的作用域</span><br>    <span class="hljs-keyword">var</span> innerVar = <span class="hljs-string">&quot;inner&quot;</span>;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(globalVar); <span class="hljs-comment">// 可访问全局变量</span><br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(outerVar);  <span class="hljs-comment">// 可访问外层函数变量</span><br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(innerVar);  <span class="hljs-comment">// 可访问自身变量</span><br>  &#125;<br><br>  inner();<br>  <span class="hljs-comment">// console.log(innerVar); // 会报错，innerVar 不在 outer 的作用域内</span><br>&#125;<br><br>outer();<br><span class="hljs-comment">// console.log(outerVar); // 会报错，outerVar 不在全局作用域内</span><br><br></code></pre></td></tr></table></figure><p><strong>作用域链</strong></p><p>作用域链是指在变量查找时形成的一系列作用域的链条。</p><p>当JS引擎在某个作用域内查找一个变量，没有找到，就会沿着作用域链向外层查找，直到查找到全局作用域为止。如果最终在全局作用域中也找不到，就返回<code>undefined</code>。（严格模式会报错）</p><p><strong>形成过程</strong></p><p>每当函数被调用，会创建一个执行上下文，其中包含该函数的变量对象。每个执行上下文还会保存一个指向外层作用域的引用（父作用域），多个执行上下文按嵌套关系构成一个链条，这就是作用域链。</p><p><strong>特点</strong></p><ul><li>静态性（词法作用域）</li><li>嵌套查找</li></ul><p><strong>作用</strong></p><p>保证对执行环境有权访问的所有变量和函数的<strong>有序访问</strong>，通过作用域链，可以访问到外层环境的变量和函数。</p><p><strong>底层原理</strong></p><p>在 JavaScript 中，每个执行环境（比如函数执行时的环境或全局执行环境）都会有一个与之关联的<strong>变量对象</strong>（Variable Object），它存储了该环境内所有的变量和函数。作用域链实际上就是一个由这些变量对象组成的链表，用于在查找变量时依次搜索各个执行环境。</p><p>1、当前执行上下文的变量对象在最前面</p><p>2、向上查找外层执行环境</p><p>3、全局执行上下文的变量对象始终位于最后</p><h2 id="4、执行上下文"><a href="#4、执行上下文" class="headerlink" title="4、执行上下文"></a>4、执行上下文</h2><p><strong>概念</strong></p><p>每一段代码在执行时，都必须在某个执行上下文中运行。无论是全局代码、函数代码，还是 <code>eval</code> 执行的代码，都有对应的执行上下文。执行上下文保存了代码运行时需要的一切信息。</p><ul><li><strong>变量环境&#x2F;词法环境（Variable&#x2F; Lexical Environment）</strong>：存储变量、函数声明、参数等数据。</li><li><strong>作用域链（Scope Chain）</strong>：用于解析变量、函数名的查找顺序，保证内部代码可以访问外部环境的变量。</li><li><strong><code>this</code> 绑定</strong>：定义当前上下文中 <code>this</code> 的值。</li></ul><p><strong>三种类型</strong></p><ul><li><p>全局执行上下文（Global Execution Context）</p><p>当 JavaScript 脚本首次加载时，首先会创建一个全局执行上下文。全局执行上下文对应全局对象。在全局上下文中定义的变量和函数，都会成为全局对象的属性或方法。</p></li><li><p>函数执行上下文（Function Execution Context）</p><p>每次调用函数时，都会为该函数创建一个新的执行上下文。函数上下文拥有自己的变量环境、作用域链和 <code>this</code> 值（通常由函数调用的方式决定）。当函数调用结束后，对应的执行上下文会被销毁（前提是没有被闭包引用，从而延长其生命周期）。</p></li><li><p>Eval 执行上下文（Eval Execution Context）</p><p>当使用 <code>eval</code> 函数执行字符串形式的代码时，会创建一个特殊的执行上下文（实际使用中较少）。</p></li></ul><p><strong>执行上下文的创建过程</strong></p><p><strong>1、创建阶段（Creation Phase）</strong>：</p><blockquote><p><strong>变量对象（Variable Object）</strong>：在这个阶段，解析器会扫描整个上下文，处理所有的变量和函数声明，将它们存储到变量对象中。这个过程也包括“提升”（Hoisting）的行为，即变量和函数声明会提前注册，但变量的赋值不会提前。</p><p><strong>建立作用域链</strong>：确定当前执行上下文的作用域链，通常是由当前上下文的变量对象和所有外层上下文的变量对象构成的列表。</p><p><strong>确定 <code>this</code> 的绑定</strong>：根据调用方式确定当前上下文中 <code>this</code> 的值。</p></blockquote><p><strong>2、执行阶段（Execution Phase）</strong>：</p><blockquote><p>代码开始按顺序执行，此时变量对象已经准备好，所有标识符的查找将沿着作用域链进行。</p></blockquote><p> <strong>执行上下文的调用栈（Call Stack）</strong></p><p><strong>全局执行上下文</strong> 总是最先进入调用栈，并且在整个程序生命周期内保持在栈底。每当调用函数时，都会创建一个新的函数执行上下文并推入调用栈；函数执行结束后，其上下文会从调用栈中弹出。</p><h2 id="5、this-call-apply-bind"><a href="#5、this-call-apply-bind" class="headerlink" title="5、this&#x2F;call&#x2F;apply&#x2F;bind"></a>5、this&#x2F;call&#x2F;apply&#x2F;bind</h2><p><strong>this</strong>：函数执行时所关联的上下文对象。它的具体值取决于函数被调用的方式，而不是函数定义的位置。</p><blockquote><p>构造函数调用：<code>this</code> 指向新创建的实例对象</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> Person(<span class="hljs-type">name</span>) &#123;<br>  this.name = <span class="hljs-type">name</span>;<br>&#125;<br>const person = <span class="hljs-built_in">new</span> Person(<span class="hljs-string">&#x27;Bob&#x27;</span>);<br>console.log(person.name); // 输出 &quot;Bob&quot;<br></code></pre></td></tr></table></figure><p>间接调用（call&#x2F;apply&#x2F;bind）：显式指定 <code>this</code> 的值</p><p>对象方法调用：<code>this</code> 指向调用该方法的对象</p><p>全局环境：<code>this</code> 通常指向全局对象（在浏览器中是 <code>window</code>；在 Node.js 中是 <code>global</code>）</p></blockquote><p><strong>箭头函数</strong>：不创建自己的 <code>this</code>，它的 <code>this</code> 值继承自外部作用域，即定义时的上下文。</p><p><strong><code>call</code>、<code>apply</code> 和 <code>bind</code> 的介绍</strong></p><p>1、call：立即调用函数，并显式指定 <code>this</code> 的值，同时依次传入参数。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">greet.<span class="hljs-built_in">call</span>(person, <span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;!&#x27;</span>)<span class="hljs-comment">; </span><br></code></pre></td></tr></table></figure><p>2、apply：与 <code>call</code> 类似，立即调用函数，并显式指定 <code>this</code>，但参数以数组（或类数组对象）的形式传入。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">greet<span class="hljs-selector-class">.apply</span>(person, <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Hi&#x27;</span>, <span class="hljs-string">&#x27;!!!&#x27;</span>]</span>); <br></code></pre></td></tr></table></figure><p>3、bind：返回一个新的函数，该函数永久绑定了指定的 <code>this</code> 值，可以在稍后调用。</p><p><code>bind</code> 不会立即调用函数，而是返回一个新函数，可以在后续任意时刻调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">greeting, punctuation</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting + <span class="hljs-string">&#x27;, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + punctuation);<br>&#125;<br><br><span class="hljs-keyword">const</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Frank&#x27;</span> &#125;;<br><br><span class="hljs-keyword">const</span> greetFrank = greet.<span class="hljs-title function_">bind</span>(person, <span class="hljs-string">&#x27;Hey&#x27;</span>);<br><span class="hljs-title function_">greetFrank</span>(<span class="hljs-string">&#x27;?&#x27;</span>); <span class="hljs-comment">// 输出 &quot;Hey, Frank?&quot;</span><br></code></pre></td></tr></table></figure><p><strong>实现它们</strong></p><p>call：</p><p>1、在目标对象添加临时属性，指向要调用的函数</p><p>2、目标对象调用函数，这样函数的this就指向了目标对象</p><p>3、调用结束，删除临时属性</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">Function.prototype.myCall = <span class="hljs-keyword">function</span><span class="hljs-params">(context, <span class="hljs-rest_arg">...args</span>)</span> &#123;<br>  <span class="hljs-comment">// 如果 context 为 null 或 undefined，则默认指向全局对象（浏览器下为 window）</span><br>  context = context || globalThis;<br>  <span class="hljs-comment">// 为避免属性名冲突，生成一个独一无二的属性名</span><br>  <span class="hljs-keyword">const</span> fnSymbol = Symbol();<br>  <span class="hljs-comment">// 将函数（this）赋值给目标对象的一个临时属性</span><br>  context[fnSymbol] = <span class="hljs-keyword">this</span>;<br>  <span class="hljs-comment">// 通过目标对象调用该函数，并传入参数</span><br>  <span class="hljs-keyword">const</span> result = context[fnSymbol](...args);<br>  <span class="hljs-comment">// 删除临时属性</span><br>  <span class="hljs-keyword">delete</span> context[fnSymbol];<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><p>apply：（与call类似，只不过区别是接收的参数是数组或者类数组类型）</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog">Function<span class="hljs-variable">.prototype</span><span class="hljs-variable">.myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-keyword">context</span>, argsArray) &#123;<br>  <span class="hljs-keyword">context</span> = <span class="hljs-keyword">context</span> || globalThis;<br>  <span class="hljs-keyword">const</span> fnSymbol = Symbol();<br>  <span class="hljs-keyword">context</span>[fnSymbol] = <span class="hljs-keyword">this</span>;<br>  <span class="hljs-comment">// 使用扩展运算符或 apply 调用函数</span><br>  <span class="hljs-keyword">const</span> result = argsArray ? <span class="hljs-keyword">context</span>[fnSymbol](..<span class="hljs-variable">.argsArray</span>) : <span class="hljs-keyword">context</span>[fnSymbol]();<br>  delete <span class="hljs-keyword">context</span>[fnSymbol];<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><p>bind：</p><p>返回一个新函数并通过闭包捕获原函数、绑定上下文和预设参数；</p><p>在调用时判断调用方式（普通调用或构造调用）来正确确定 <code>this</code>；</p><p>维护原型链，保证构造函数场景下新实例能正确继承原函数的原型属性。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">Function.prototype.myBind = <span class="hljs-keyword">function</span><span class="hljs-params">(context, <span class="hljs-rest_arg">...args</span>)</span> &#123;<br>  <span class="hljs-keyword">const</span> self = <span class="hljs-keyword">this</span>; <span class="hljs-comment">// 保存原函数引用</span><br><br>  <span class="hljs-comment">// 返回一个新函数（绑定函数）</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">boundFunc</span><span class="hljs-params">(<span class="hljs-rest_arg">...bindArgs</span>)</span> &#123;<br>    <span class="hljs-comment">// 如果通过 new 调用，this instanceof boundFunc 为 true，此时使用新创建的实例作为 this，</span><br>    <span class="hljs-comment">// 否则，使用绑定时传入的 context 作为 this</span><br>    <span class="hljs-keyword">return</span> self.apply(<br>      <span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> boundFunc ? <span class="hljs-keyword">this</span> : context,<br>      args.concat(bindArgs)<br>    );<br>  &#125;<br><br>  <span class="hljs-comment">// 设置原型链，保证通过 new 调用时，新对象可以继承原函数的原型</span><br>  boundFunc.prototype = Object.create(self.prototype);<br>  <br>  <span class="hljs-keyword">return</span> boundFunc;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="6、异步编程"><a href="#6、异步编程" class="headerlink" title="6、异步编程"></a>6、异步编程</h2><p>异步编程：允许程序在等待某些耗时操作（如网络请求、文件读取或定时任务）完成的同时，继续执行其他任务，不用一直阻塞等待。当耗时任务完成后，通过回调函数、事件、Promise、或 async&#x2F;await 等机制处理结果。异步编程通过<strong>事件循环机制</strong>，可以使耗时任务在后台执行，不阻塞主线程。</p><p>同步编程：执行过程是按照顺序的，每个任务都必须等待前一个任务完成后才能开始，若某个任务耗时较长，就会导致程序暂停，降低响应速度。</p><p><strong>事件循环 Event Loop</strong></p><p>​<strong>任务队列</strong>：当异步任务（如定时器、网络请求）完成后，其<strong>对应的回调函数</strong>会被放入任务队列。</p><p>​<strong>执行栈</strong>：JavaScript 有一个单一的执行栈，当栈内没有同步任务时，事件循环会从任务队列中取出一个任务执行。</p><p>​<strong>异步执行</strong>：这样就实现了即使某些任务耗时较长，程序也能继续执行其他任务，等待耗时任务完成后再处理结果。</p><p><strong>常见的异步编程方式</strong></p><p>1、回调函数Callback</p><p>回调函数是一个函数，它<strong>被传递给另一个函数作为参数</strong>，并在某个特定的时刻被调用。</p><p>最传统的异步方式，在任务完成后调用指定的函数来处理结果。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params">callback</span>) &#123;<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    callback(<span class="hljs-string">&#x27;数据加载完成&#x27;</span>);<br>  &#125;, <span class="hljs-number">2000</span>);<br>&#125;<br>fetchData(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result);<br>&#125;);<br></code></pre></td></tr></table></figure><p>2、Promise</p><p>提供了一种更优雅的方式来处理异步操作，使得代码更易读、易维护。</p><p>它通过链式调用来避免回调地狱。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const fetchDataPromise = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">&#x27;数据加载完成&#x27;</span>);<br>  &#125;, <span class="hljs-number">2000</span>);<br>&#125;);<br><br>fetchDataPromise.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result);<br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.error(error);<br>&#125;);<br></code></pre></td></tr></table></figure><p>3、async&#x2F;await</p><p>基于 Promise 的语法糖，使得异步代码看起来像同步代码，更直观。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;数据加载完成&#x27;</span>);<br>    &#125;, <span class="hljs-number">2000</span>);<br>  &#125;);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>&#125;<br><span class="hljs-title function_">fetchData</span>();<br></code></pre></td></tr></table></figure><ul><li><strong>定时器函数 setTimeout</strong></li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const timerId = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;2秒后执行的回调&#x27;</span>);<br>&#125;, <span class="hljs-number">2000</span>);<br></code></pre></td></tr></table></figure><p>返回值：定时器ID</p><p>取消定时器：<code>clearTimeout(timerId)</code></p><p>工作原理：在浏览器中，<code>setTimeout</code> 属于浏览器提供的 Web API，定时器功能是由浏览器的其他部分（通常运行在独立线程中）处理的。调用<code>setTimeout</code>时，JS引擎会把回调函数和延迟时间传递给浏览器，浏览器会注册一个定时器，记录回调函数和延迟时间。在独立的线程中启动定时器，在后台等待指定的延迟时间。当延迟时间结束，浏览器将回调函数放入任务队列（宏任务队列），等待事件循环空闲后执行。</p><p>特点：不保证精确性，延迟只是一个最小等待时间，实际回调的执行时间可能因为当前任务的执行或者其他定时器的竞争而延迟。setTimeout允许耗时任务（例如 DOM 操作、网络请求等）异步调度，避免阻塞主线程。</p><ul><li><strong>Promise</strong></li></ul><p>Promise 是一种对<strong>异步操作结果</strong>进行包装的机制，可以更优雅地处理回调函数，避免“回调地狱”（callback hell），从而使异步代码更容易理解和维护。</p><p><strong>三种状态</strong></p><p>pending等待中 fulfilled成功  rejected失败</p><p>一旦 Promise 的状态从 pending 转变为 fulfilled 或 rejected，就不会再改变。</p><p><strong>链式调用</strong></p><p>Promise 提供了 <code>.then()</code>、<code>.catch()</code> 和 <code>.finally()</code> 方法，可以在操作完成后进行处理，并将多个异步操作串联起来，实现链式调用。</p><p><strong>工作原理</strong></p><p>创建Promise实例，构造函数接收一个<strong>执行器函数</strong>。</p><p>函数立即执行，并传入两个函数参数resolve, reject，分别用于将Promise的状态从pending转换为fulfilled或者rejected。</p><p>通过.then方法注册成功时要执行的回调函数，.catch方法注册失败时的回调函数。</p><p>怎么实现的链式调用呢?</p><p><code>.then()</code> 方法会返回一个新的 Promise，这使得可以将多个异步操作串联起来，形成一个链式结构，按顺序处理每个操作的结果或错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 模拟异步操作</span><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 如果操作成功，调用 resolve 并传入结果</span><br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;操作成功&quot;</span>);<br>    <span class="hljs-comment">// 如果操作失败，可以调用 reject</span><br>    <span class="hljs-comment">// reject(&quot;操作失败&quot;);</span><br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li><strong>async&#x2F;await关键字</strong></li></ul><p>是Promise的语法糖，使得异步代码的写法看起来更像同步代码，提升代码的可读性和可维护性。</p><p>在函数前加上async关键字，就定义了一个异步函数，无论函数内部返回什么，async函数总会返回一个Promise。await关键字只能在async函数内部使用，它会暂停async函数的执行，等待一个Promise，如果成功，返回解析值。如果失败，抛出异常。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>);<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>    <span class="hljs-keyword">return</span> data;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;数据获取失败&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">fetchData</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));<br></code></pre></td></tr></table></figure><p>工作原理：</p><p><strong>暂停与恢复</strong><br>当遇到 <code>await somePromise</code> 时，async 函数会暂停执行，将后续代码注册为一个微任务（microtask），并等待 <code>somePromise</code> 完成。完成后，事件循环会从微任务队列中取出这个任务，恢复 async 函数的执行，并将 Promise 的解析值赋给 <code>await</code> 表达式。</p><p><strong>非阻塞特性</strong><br>虽然在 async 函数内部看起来像是同步代码，但实际上 async&#x2F;await 并不会阻塞整个主线程，它只是在当前 async 函数内部暂停执行，其他代码仍然可以继续运行。</p><h2 id="7、面向对象"><a href="#7、面向对象" class="headerlink" title="7、面向对象"></a>7、面向对象</h2><p>1、对象创建的方式有哪些</p><ul><li><p>对象字面量 ：使用花括号定义对象</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const obj</span> = &#123;<br>  name: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  age: 25<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>构造函数：定义一个函数作为构造函数，使用new关键字创建实例</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(name, age)</span> &#123;<br>  <span class="hljs-keyword">this</span>.name = name;<br>  <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure></li><li><p>es6 类class：使用class语法定义构造函数和原型方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>  <br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Charlie&#x27;</span>, <span class="hljs-number">28</span>);<br></code></pre></td></tr></table></figure></li><li><p>Object.create：基于现有对象创建一个新对象，并指定新对象的原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> proto = &#123;<br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, I am <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(proto);<br>obj2.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Dave&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>new Object：通过Object构造函数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> obj3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>obj3.name = <span class="hljs-string">&#x27;Frank&#x27;</span>;<br>obj3.age = <span class="hljs-number">35</span>;<br></code></pre></td></tr></table></figure></li><li><p>工厂函数：普通的函数，用来封装对象的创建逻辑，返回新对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createPerson</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    name,<br>    age,<br>    <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> person3 = <span class="hljs-title function_">createPerson</span>(<span class="hljs-string">&#x27;Eve&#x27;</span>, <span class="hljs-number">22</span>);<br></code></pre></td></tr></table></figure></li></ul><p>2、对象继承的方式有哪些</p><ul><li><p>原型链继承：利用对象的原型属性，将一个对象作为另一个对象的原型。</p><ul><li>优点：实现简单，能够继承父对象的属性和方法。</li><li>缺点：所有子对象共享父对象的引用类型属性，容易出现引用共享的问题。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Parent&#x27;</span>;<br>&#125;<br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-comment">// 让 Child 的原型指向 Parent 的一个实例</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br>child.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出 &quot;Hello from Parent&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>2、借用构造函数继承（经典继承）：在子构造函数内部调用父构造函数，通过 <code>call</code> 或 <code>apply</code> 将父构造函数的执行上下文绑定到子实例上，从而让子实例拥有父构造函数中的属性。</p><p>优点：每个子对象都有自己的属性副本，不会共享引用类型的属性。</p><p>缺点：只能继承父构造函数中的属性，不能继承父构造函数原型中的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>];<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);  <span class="hljs-comment">// 借用构造函数</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-keyword">const</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">10</span>);<br>child1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;green&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-property">colors</span>); <span class="hljs-comment">// 输出 [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span><br><br><span class="hljs-keyword">const</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">12</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">colors</span>); <span class="hljs-comment">// 输出 [&quot;red&quot;, &quot;blue&quot;]</span><br></code></pre></td></tr></table></figure></li><li><p>3、组合继承：结合了原型链继承和借用构造函数继承</p><p>优点：能够同时继承属性和方法，比较全面。</p><p>缺点：父构造函数被调用了两次（一次在 <code>Child.prototype = new Parent()</code>，一次在 <code>Parent.call(this, name)</code>），可能会带来不必要的性能损耗。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>];<br>&#125;<br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name); <span class="hljs-comment">// 继承属性</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>(); <span class="hljs-comment">// 继承方法</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>; <span class="hljs-comment">// 修复 constructor 指向</span><br><br><span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">10</span>);<br>child.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出 &quot;Hello from Alice&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>4、寄生式继承：创建一个仅用于封装继承过程的函数，该函数内部先创建一个以某对象为原型的新对象，然后对这个新对象进行增强，最后返回它。</p><p>优点：简单易用，可以对对象进行定制和扩展。</p><p>缺点：缺少对引用类型属性的封装问题，容易造成共享问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createObj</span>(<span class="hljs-params">original</span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = original;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>&#125;<br><br><span class="hljs-keyword">const</span> parent = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Parent&#x27;</span>,<br>  <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-title function_">createObj</span>(parent);<br>child.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Child&#x27;</span>;<br>child.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出 &quot;Hello from Child&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>5、寄生组合继承：是对组合继承的优化，避免了在设置子对象原型时调用父构造函数，从而只调用一次父构造函数，提高效率。常用方法是利用 <code>Object.create</code> 来创建子对象的原型。</p><p>优点：避免了组合继承中父构造函数调用两次的问题，是目前推荐使用的继承方式。</p><p>缺点：实现上稍微复杂一点，但大部分情况都值得使用这种方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>];<br>&#125;<br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-comment">// 使用 Object.create 代替 new Parent()</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>;<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">10</span>);<br>child.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出 &quot;Hello from Alice&quot;</span><br><br></code></pre></td></tr></table></figure></li><li><p>6、ES6 Class 继承：ES6 引入了 class 关键字和 extends 关键字，使得对象继承写法更加简洁。底层原理依然基于原型链，但语法更加直观和类似于传统面向对象语言。</p><p>优点：语法更清晰、更接近传统面向对象编程习惯，同时内置处理了原型继承的问题。</p><p>缺点：本质上还是基于原型继承，某些底层细节与 ES5 的继承方式类似。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>];<br>  &#125;<br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name);  <span class="hljs-comment">// 调用父类构造函数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">10</span>);<br>child.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出 &quot;Hello from Alice&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>7、Object.create() 方式：使用 <code>Object.create</code> 创建一个新对象，并指定其原型为传入的对象。这种方式非常直接，可以精确控制新对象的原型链。</p><p>优点：简单、直接，可以灵活地创建基于现有对象的新对象。</p><p>缺点：只能继承对象本身的方法和属性，对于构造函数模式下的属性初始化需要另外处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parent = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Parent&#x27;</span>,<br>  <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent);<br>child.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Child&#x27;</span>;<br>child.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出 &quot;Hello from Child&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="8、垃圾回收与内存泄露"><a href="#8、垃圾回收与内存泄露" class="headerlink" title="8、垃圾回收与内存泄露"></a>8、垃圾回收与内存泄露</h2><p>内存管理主要由垃圾回收机制（Garbage Collection, GC）自动完成，但如果不注意代码的设计和资源的管理，仍然可能导致内存泄漏。</p><p>垃圾回收：自动检测程序中不再被使用的内存，并将其回收，以便后续分配给其他对象。</p><p><strong>标记清除（Mark-and-Sweep）</strong>：<br>这是最常见的垃圾回收算法。其基本过程如下：</p><ol><li><strong>标记阶段</strong>：从根对象（如全局对象、当前执行上下文等）开始，遍历所有可达的对象，并做上标记。</li><li><strong>清除阶段</strong>：所有没有被标记的对象被认为是不可达的，即没有引用指向它们，这些对象的内存将被释放。</li></ol><p><strong>引用计数（Reference Counting）</strong>：<br>另一种算法是对每个对象维护一个引用计数，当计数为 0 时，表明没有任何引用指向该对象，可以被回收。不过引用计数容易产生循环引用的问题，因此现代 JavaScript 引擎一般采用标记清除或其改进版本（例如分代回收）。</p><p><strong>分代回收（Generational Collection）</strong>：<br>现代引擎（如 V8）会把对象分为“新生代”和“老生代”：</p><ul><li><strong>新生代</strong>：存储生命周期较短的对象，垃圾回收频率较高。</li><li><strong>老生代</strong>：存储生命周期较长的对象，垃圾回收频率较低。<br>这种方法可以提高性能，因为大部分对象很快就不再使用，只在新生代中进行频繁的垃圾回收。</li></ul><p>内存泄漏：程序中不再需要的内存未能被垃圾回收机制释放，导致内存占用逐渐增加。长时间运行的程序如果发生内存泄漏，会引发性能下降、响应变慢甚至崩溃。</p><p> 常见的内存泄漏原因：</p><ul><li><strong>全局变量的滥用</strong>：<br>无意中将变量定义为全局变量（例如漏写 <code>var</code>、<code>let</code> 或 <code>const</code>），使得这些变量一直存在于全局作用域中，从而无法被回收。</li><li><strong>闭包</strong>：<br>闭包虽然是实现数据封装和模块化的有力工具，但如果使用不当，闭包会意外地持有对不再需要的对象的引用，从而导致内存无法释放。</li><li><strong>定时器和事件监听器</strong>：<br>未能及时清除的定时器（如 <code>setInterval</code>）或未注销的事件监听器会一直持有对 DOM 节点或其他对象的引用，导致这些对象无法回收。</li><li><strong>脱离 DOM 的引用</strong>：<br>当 DOM 元素被移除后，如果代码中仍然持有对这些元素的引用，那么这些元素及其关联的数据不会被回收。</li><li><strong>缓存和数据结构</strong>：<br>长期存储在缓存或数据结构中的数据，如果没有合理的失效机制，也会导致内存泄漏。</li></ul><p>如何防止内存泄漏？</p><ul><li><p><strong>合理使用变量作用域</strong>：<br>避免在全局作用域中定义过多变量，尽可能使用局部变量，并及时清理不需要的引用。</p></li><li><p><strong>注意闭包的使用</strong>：<br>在使用闭包时，确保没有无意中引用大量数据或 DOM 元素，可以通过解除引用或采用更合适的设计来避免泄漏。</p></li><li><p><strong>及时清除定时器和事件监听器</strong>：</p><p>在不需要时，使用 <code>clearInterval</code>、<code>clearTimeout</code> 取消定时器，以及在组件卸载或 DOM 元素销毁时移除事件监听器。</p></li><li><p><strong>合理设计缓存机制</strong>：<br>对缓存数据设置失效机制，定期清理不再使用的数据。</p></li><li><p><strong>使用工具监控内存</strong>：<br>利用浏览器开发者工具或专门的内存检测工具（如 Chrome 的 Memory 面板、Node.js 的内存快照工具）来监控内存使用情况，及时发现和解决内存泄漏问题。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原型</tag>
      
      <tag>闭包</tag>
      
      <tag>作用域</tag>
      
      <tag>执行上下文</tag>
      
      <tag>异步编程</tag>
      
      <tag>面向对象</tag>
      
      <tag>垃圾回收</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础大乱炖一锅出</title>
    <link href="/2025/02/18/JS%E5%9F%BA%E7%A1%80%E5%A4%A7%E4%B9%B1%E7%82%96%E4%B8%80%E9%94%85%E5%87%BA/"/>
    <url>/2025/02/18/JS%E5%9F%BA%E7%A1%80%E5%A4%A7%E4%B9%B1%E7%82%96%E4%B8%80%E9%94%85%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="JS基础大乱炖一锅出"><a href="#JS基础大乱炖一锅出" class="headerlink" title="JS基础大乱炖一锅出"></a>JS基础大乱炖一锅出</h1><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502181617897.png" alt="image-20250218161653528"></p><h2 id="1、new操作符的实现原理"><a href="#1、new操作符的实现原理" class="headerlink" title="1、new操作符的实现原理"></a>1、new操作符的实现原理</h2><p><strong>原理！就4步！</strong></p><p>1、创建空对象</p><p>2、把新对象内部的[[Prototype]]指向构造函数的prototype</p><p>3、以新对象为this调用构造函数，初始化新对象</p><p>4、如果构造函数返回的是对象，直接返回。否则，返回创建的新对象。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 首先，咱们写一个构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(name)</span> &#123;<br>  <span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-comment">// 再写一个函数，模拟new操作符的作用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span><span class="hljs-params">(con, <span class="hljs-rest_arg">...args</span>)</span> &#123;<br>  <span class="hljs-comment">// 判断参数时不时函数类型</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> con !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    console.error(<span class="hljs-string">&quot;con must be a function&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 创建空对象</span><br>  let newObj = &#123;&#125;;<br>  <span class="hljs-comment">// 将空对象的原型指向构造函数prototype</span><br>  newObj.__proto__ = con.prototype;<br>  <span class="hljs-comment">// 将构造函数的this指向新对象</span><br>  let res = con.apply(newObj, args);<br>  <span class="hljs-comment">// 判断构造函数返回值是否为对象，如果是，则返回构造函数返回值，否则返回新对象</span><br>  let flag = res &amp;&amp; (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&quot;function&quot;</span>);<br>  <span class="hljs-keyword">return</span> flag ? res : newObj;<br>&#125;<br><br><span class="hljs-comment">// 测试效果</span><br><br>console.log(myNew(Person,<span class="hljs-string">&#x27;anan&#x27;</span>))<br></code></pre></td></tr></table></figure><h2 id="2、map和Object的区别"><a href="#2、map和Object的区别" class="headerlink" title="2、map和Object的区别"></a>2、map和Object的区别</h2><p>map和object都能够存储键值对，那好奇的朋友就发问了，有什么区别呢？</p><p>有的。</p><p><strong>1、键的类型</strong></p><ul><li><p>Map：什么类型都可以，字符串√ 数字√ 对象√函数√ NaN也行！并且严格区分，不会自动转换为字符串。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br><span class="hljs-built_in">map</span>.set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;number one&quot;</span>);<br><span class="hljs-built_in">map</span>.set(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;string one&quot;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">map</span>.get(<span class="hljs-number">1</span>));   <span class="hljs-comment">// &quot;number one&quot;</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">map</span>.get(<span class="hljs-string">&quot;1&quot;</span>)); <span class="hljs-comment">// &quot;string one&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>Object：只能是字符串或者Symbol，不是字符串的都会自动转换为字符串！</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const obj <span class="hljs-operator">=</span> &#123;&#125;<span class="hljs-comment">;</span><br>obj[<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;number one&quot;</span><span class="hljs-comment">;  // 数字 1 会转换为字符串 &quot;1&quot;</span><br>obj[<span class="hljs-string">&quot;1&quot;</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;string one&quot;</span><span class="hljs-comment">; // 覆盖&quot;1&quot;的值</span><br>console.log(obj[<span class="hljs-number">1</span>])<span class="hljs-comment">;  // &quot;string one&quot;</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>2、键的顺序</strong></p><ul><li>Map：内部会保存插入顺序，遍历的时候也是按照插入顺序返回的</li><li>Object：ES6 规范中规定对象属性遍历顺序，但实际行为在不同情况下可能不一致</li></ul><p><strong>3、大小属性</strong></p><ul><li>Map：获取键值对数量使用<code>map.size</code></li><li>Object：没有直接获取键值对数量的方法，可以使用<code>Object.keys(obj).length</code></li></ul><p><strong>4、迭代方面</strong></p><ul><li><p>Map：可以迭代，使用<code>for...of</code> 循环、<code>map.forEach()</code> 或解构语法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">const</span> <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new </span><span class="hljs-class title_">Map</span>([[<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>]]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [<span class="hljs-built_in">key</span>, value] of <span class="hljs-built_in">map</span>) &#123;<br>  console.<span class="hljs-property">log</span>(<span class="hljs-built_in">key</span>, value);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Object：本身是不可迭代的。需要转换成键数组、值数组或键值对数组。</p><p><code>Object.keys()</code>、<code>Object.values()</code> 或 <code>Object.entries()</code>。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">const</span> obj = &#123; a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">key</span> of <span class="hljs-built_in">Object</span>.<span class="hljs-property">keys</span>(obj)) &#123;<br>  console.<span class="hljs-property">log</span>(<span class="hljs-built_in">key</span>, obj[<span class="hljs-built_in">key</span>]);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>5、应用场景</strong></p><ul><li>Map：更适合频繁增加和删除键值对的场景。没有原型链干扰，它不继承来自 <code>Object.prototype</code> 的属性。</li><li>Object：通常用于存储结构化数据或作为简单的字典，但可能会受到原型链的干扰（例如内置属性或方法）。</li></ul><h2 id="3、Map和WeakMap的区别"><a href="#3、Map和WeakMap的区别" class="headerlink" title="3、Map和WeakMap的区别"></a>3、Map和WeakMap的区别</h2><p><strong>键的类型</strong></p><ul><li>Map：键可以是任意类型</li><li>WeakMap：键只能是对象！只能是对象！对象对象对象~</li></ul><p><strong>可枚举性</strong></p><ul><li>Map：可迭代，使用 <code>for...of</code>、<code>map.forEach()</code> ，也有<code>size</code>属性</li><li>WeakMap：不可迭代！没有遍历方法！也没有<code>size</code>属性！不允许列举键值对，因为它的键是弱引用，随时都可能被回收~</li></ul><p><strong>使用场景</strong></p><ul><li>Map：频繁增加、删除、遍历键值对的场景、用于数据持久存储和操作，或者需要保证键的顺序。</li><li>WeakMap：存储与对象相关的元数据或私有数据。当希望在对象不再被使用时，该对象对应的相关数据能自动被清除，使用 WeakMap 可以有效防止内存泄漏。</li></ul><h2 id="4、JavaScript有哪些内置对象"><a href="#4、JavaScript有哪些内置对象" class="headerlink" title="4、JavaScript有哪些内置对象"></a>4、JavaScript有哪些内置对象</h2><p>“内置对象”是指 JavaScript 语言在其标准中预先定义并由 JavaScript 引擎自动提供的对象。</p><p><strong>全局对象：</strong>存储全局可用的变量和函数。</p><blockquote><p>在浏览器中，全局对象通常是 <code>window</code>（或 <code>self</code>，例如在 Web Worker 中）。</p><p>在 Node.js 中，全局对象通常是 <code>global</code>。</p><p>为了统一跨平台访问，ES2020 引入了 <code>globalThis</code>，它提供了一个标准的方式来引用全局对象。</p></blockquote><p><strong>基本类型包装对象</strong>：<code>Object</code>、<code>Function</code>、<code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Symbol</code>、<code>BigInt</code> 等。</p><p><strong>集合和数组相关</strong>：<code>Array</code>、<code>Map</code>、<code>Set</code>、<code>WeakMap</code>、<code>WeakSet</code>。</p><p><strong>工具对象</strong>：<code>Math</code>（数学函数和常量）、<code>JSON</code>（解析和字符串化 JSON 数据）。</p><p><strong>日期和正则</strong>：<code>Date</code>、<code>RegExp</code>。</p><p><strong>错误处理</strong>：<code>Error</code> 及其派生类型（如 <code>TypeError</code>、<code>SyntaxError</code> 等）。</p><p><strong>二进制数据处理</strong>：<code>ArrayBuffer</code>、<code>DataView</code>、各类 <code>TypedArray</code>。</p><p><strong>异步编程</strong>：<code>Promise</code> 等。</p><p><strong>反射与代理</strong>：<code>Reflect</code>、<code>Proxy</code>。</p><h2 id="5、常用的正则表达式有哪些"><a href="#5、常用的正则表达式有哪些" class="headerlink" title="5、常用的正则表达式有哪些"></a>5、常用的正则表达式有哪些</h2><p><strong>匹配数字</strong>：该字符串从开始到结束全部由一个或多个数字组成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/^\d+$/</span> <br></code></pre></td></tr></table></figure><p><strong>匹配英文</strong>：确保整个字符串只包含一个或多个英文字母</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/^[a-zA-Z]+$/</span><br></code></pre></td></tr></table></figure><p><strong>匹配邮箱</strong>：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">const reg = /^<span class="hljs-comment">[\w.-]</span>+@<span class="hljs-comment">[A-Za-z\d.-]</span>+\.<span class="hljs-comment">[A-Za-z]</span>&#123;2,&#125;$/<br></code></pre></td></tr></table></figure><p><strong>匹配号码：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">const</span> reg = /^<span class="hljs-number">1</span>[<span class="hljs-number">3</span>-<span class="hljs-number">9</span>]\d&#123;<span class="hljs-number">9</span>&#125;$/<br></code></pre></td></tr></table></figure><h2 id="6、对JSON的理解"><a href="#6、对JSON的理解" class="headerlink" title="6、对JSON的理解"></a>6、对JSON的理解</h2><p>JSON 是一种文本格式，可以方便地在不同编程语言之间传输数据。</p><p>JSON 是 Web 开发中最常用的数据交换格式。</p><p>客户端与服务器之间通常使用 JSON 格式传输数据，因为它格式简单、易于解析并且与多种编程语言兼容。</p><p><strong>严格的语法规则</strong></p><ul><li>键必须用双引号括起来，单引号不合法。</li><li>字符串也必须使用双引号。</li><li>JSON 不允许使用尾随逗号。</li></ul><p><strong>数据转换</strong></p><ul><li><p><strong>序列化</strong><br>将 JavaScript 对象转换为 JSON 字符串可以使用 <code>JSON.stringify()</code> 方法：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> obj = &#123; name: <span class="hljs-string">&quot;Alice&quot;</span>, age: <span class="hljs-number">25</span> &#125;;<br><span class="hljs-keyword">const</span> jsonString = JSON.stringify(obj);<br>console.<span class="hljs-keyword">log</span>(jsonString); // 输出: &#x27;&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Alice&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">25</span>&#125;&#x27;<br></code></pre></td></tr></table></figure></li><li><p><strong>反序列化</strong><br>将 JSON 字符串解析为 JavaScript 对象可以使用 <code>JSON.parse()</code> 方法：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> jsonString = &#x27;&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Alice&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:25&#125;&#x27;;<br><span class="hljs-keyword">const</span> obj = JSON.<span class="hljs-keyword">parse</span>(jsonString);<br>console.<span class="hljs-built_in">log</span>(obj.name); <span class="hljs-comment">// 输出: &quot;Alice&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="7、JavaScript脚本延迟加载的方式有哪些"><a href="#7、JavaScript脚本延迟加载的方式有哪些" class="headerlink" title="7、JavaScript脚本延迟加载的方式有哪些"></a>7、JavaScript脚本延迟加载的方式有哪些</h2><p><strong>延迟加载（Lazy Loading）</strong> 是一种优化技术，目的是推迟非关键脚本的加载和执行，从而减少页面初始加载时间、提升首屏<strong>渲染速度</strong>，并降低不必要的资源消耗。</p><p><strong>1、使用defer</strong></p><p>加载时机：立即开始加载（下载）</p><p>执行时机：HTML文档解析完成后，DOMContentLoaded事件触发前，按出现顺序执行。</p><p>特点：不会阻塞页面的解析加载，保证脚本执行顺序和文档中出现的顺序一致。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span> <span class="hljs-attr">defer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2、使用async</strong></p><p>加载时机：立即开始加载（下载）（异步加载）</p><p>执行时机：加载完成，就立即执行</p><p>特点：不保证顺序，取决于它们的加载速度，不会阻塞页面解析和渲染</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>3、动态插入脚本 createElement</strong></p><p>通过JS动态创建<code>&lt;script&gt;</code>标签，插入到DOM中，从而延迟加载脚本。</p><p>灵活，可以在特定条件或事件发生时加载脚本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-params">url, callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>  script.<span class="hljs-property">src</span> = url;<br>  script.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (callback) <span class="hljs-title function_">callback</span>();<br>  &#125;;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script);<br>&#125;<br><br><span class="hljs-comment">// 例如，当用户点击按钮时加载脚本</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;loadBtn&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">loadScript</span>(<span class="hljs-string">&#x27;script.js&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Script loaded!&#x27;</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>**4、动态加载模块 import() **</p><p>使用 ES6 提供的动态 <code>import()</code> 方法，在需要时再异步加载模块。</p><p>返回一个 Promise，可以通过 <code>.then()</code> 或 <code>await</code> 处理加载结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 当需要加载某个模块时</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./module.js&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// module 是加载的模块对象，包含所有导出的内容</span><br>    <span class="hljs-variable language_">module</span>.<span class="hljs-title function_">doSomething</span>(); <span class="hljs-comment">// 调用模块中的函数</span><br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// err 是模块加载失败时的错误对象</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error loading module:&#x27;</span>, err);<br>  &#125;);<br></code></pre></td></tr></table></figure><p><strong>5、脚本置底</strong></p><p>将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</p><h2 id="8、JavaScript-类数组对象的定义"><a href="#8、JavaScript-类数组对象的定义" class="headerlink" title="8、JavaScript 类数组对象的定义"></a>8、JavaScript 类数组对象的定义</h2><p>类数组对象：是对象，和数组具有类似的数组结构，但不是真正的Array对象。</p><ul><li>能够通过索引访问元素</li><li>有length属性</li><li>不一定继承Array.prototype</li></ul><p><strong>常见的类数组对象</strong></p><p><code>arguments</code> 对象、DOM 集合如<code>NodeList</code> <code>HTMLCollection</code>、字符串</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// arguments 是一个类数组对象</span><br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arguments.<span class="hljs-built_in">length</span>); <span class="hljs-comment">// 输出传入参数的数量</span><br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arguments[<span class="hljs-number">0</span>]);     <span class="hljs-comment">// 输出第一个参数</span><br>&#125;<br>demo(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<br><br><span class="hljs-comment">// NodeList 示例（在浏览器环境中）</span><br>const paragraphs = document.querySelectorAll(<span class="hljs-string">&#x27;p&#x27;</span>); <span class="hljs-comment">// 返回 NodeList 类数组对象</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(paragraphs.<span class="hljs-built_in">length</span>); <span class="hljs-comment">// 输出页面中 &lt;p&gt; 标签的数量</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(paragraphs[<span class="hljs-number">0</span>]);     <span class="hljs-comment">// 输出第一个 &lt;p&gt; 元素</span><br></code></pre></td></tr></table></figure><p><strong>类数组对象转换为数组呢</strong></p><ul><li><p>Array.from方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> argsArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">arguments</span>);<br></code></pre></td></tr></table></figure></li><li><p>扩展运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> argsArray = [...<span class="hljs-variable language_">arguments</span>]<br></code></pre></td></tr></table></figure></li><li><p>Array.prototype.slice</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> argsArray = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br></code></pre></td></tr></table></figure></li></ul><h2 id="9、数组有哪些原生方法"><a href="#9、数组有哪些原生方法" class="headerlink" title="9、数组有哪些原生方法"></a>9、数组有哪些原生方法</h2><p><strong>修改：</strong>push、pop、shift、unshift、splice、sort、reverse 、fill<strong>【影响原数组】</strong></p><p><strong>生成新数组</strong>：concat、slice、flat、flatMap、join（生成的字符串）</p><p><strong>迭代与处理</strong>：forEach（返回 <code>undefined</code>，可以主动修改原数组）、map（返回新数组）、filter、reduce、every、some、find、findIndex</p><p><strong>搜索</strong>：indexOf、lastIndexOf、includes</p><p><strong>迭代器相关</strong>：keys、values、entries</p><h2 id="10、Unicode、UTF-8、UTF-16、UTF-32的区别"><a href="#10、Unicode、UTF-8、UTF-16、UTF-32的区别" class="headerlink" title="10、Unicode、UTF-8、UTF-16、UTF-32的区别"></a>10、Unicode、UTF-8、UTF-16、UTF-32的区别</h2><p>Unicode：国际标准，抽象的字符集，世界上几乎所有的文字和符号都分配了唯一的<strong>数字标识</strong>（<strong>代码点</strong>）。旨在取代各种字符编码系统，实现全球字符的统一表示。</p><blockquote><p>Unicode 的代码点范围从 <code>U+0000</code> 到 <code>U+10FFFF</code></p></blockquote><p>UTF是为了实现Unicode字符集的<strong>存储和传输</strong>的一系列编码方案，它们都把Unicode的代码点转换为一系列字节，但是具体方式和效率不同。</p><blockquote><p><strong>UTF-8</strong>：</p><ul><li>可变长度（1~4 字节）。</li><li>向后兼容 ASCII，节省英文文本空间，广泛应用于网络和文件存储。</li></ul><p><strong>UTF-16</strong>：</p><ul><li>可变长度（2 或 4 字节）。</li><li>大多数字符用 2 字节表示，超出基本平面的字符用 4 字节。</li><li>被 Windows 和 JavaScript 等使用。</li></ul><p><strong>UTF-32</strong>：</p><ul><li>固定长度（4 字节）。</li><li>编码简单，但内存占用大，使用较少。</li></ul></blockquote><h2 id="11、常见的位运算符有哪些？其计算规则是什么"><a href="#11、常见的位运算符有哪些？其计算规则是什么" class="headerlink" title="11、常见的位运算符有哪些？其计算规则是什么"></a>11、常见的位运算符有哪些？其计算规则是什么</h2><p>位运算符：直接操作数字的二进制位。</p><p>JavaScript 中的数字是以 64 位浮点数（IEEE 754 格式）存储的，但在进行位运算时，它们会被暂时转换为 32 位有符号整数。位运算符通常比算术运算符更快，因为它们直接操作内存中的二进制位。</p><p>**按位与&amp;**：对应的二进制位都是1，则该位结果是1，否则是0</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">// 二进制: 5 -&gt; 0101, 3 -&gt; 0011</span><br><span class="hljs-comment">// 0101 &amp; 0011 = 0001  (十进制 1)</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> <span class="hljs-meta">&amp; 3); <span class="hljs-comment">// 输出 1</span></span><br></code></pre></td></tr></table></figure><p><strong>按位或</strong>|：对应的二进制位只要有1，则该位结果是1，否则是0</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 二进制: 5 -&gt; 0101, 3 -&gt; 0011</span><br><span class="hljs-comment">// 0101 | 0011 = 0111  (十进制 7)</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> | <span class="hljs-number">3</span>); <span class="hljs-comment">// 输出 7</span><br></code></pre></td></tr></table></figure><p><strong>按位异或^</strong>：对应的二进制位，只有两个操作数都不同，则该位结果是1，否则是0</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 二进制: 5 -&gt; 0101, 3 -&gt; 0011</span><br><span class="hljs-comment">// 0101 ^ 0011 = 0110  (十进制 6)</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> ^ <span class="hljs-number">3</span>); <span class="hljs-comment">// 输出 6</span><br></code></pre></td></tr></table></figure><p>**按位非~**：对每一位取反(对 32 位整数取反后再解释成带符号数)</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">// 5 的二进制（32 位）大致为 ...00000101</span><br><span class="hljs-comment">// ~5 = ...11111010，解释为 -6</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-symbol">~5)</span>; <span class="hljs-comment">// 输出 -6</span><br></code></pre></td></tr></table></figure><p>**左移运算符&lt;&lt;**：二进制左移指定的位数，补0</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 5 -&gt; 0101，左移 1 位变为 1010，即十进制 10</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> &lt;&lt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 输出 10</span><br></code></pre></td></tr></table></figure><p>**有符号右移运算符&gt;&gt;**：二进制右移指定的位数，左侧根据原来的符号补（正数补0，负数补1）</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 5 -&gt; 0101，右移 1 位变为 0010，即十进制 2</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 输出 2</span><br><br><span class="hljs-comment">// -8 的 32 位表示为 11111111 11111111 11111111 11111000，</span><br><span class="hljs-comment">// 右移 2 位后为 11111111 11111111 11111111 11111110，即十进制 -2</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">-8</span> &gt;&gt; <span class="hljs-number">2</span>); <span class="hljs-comment">// 输出 -2</span><br></code></pre></td></tr></table></figure><p>**无符号右移运算符&gt;&gt;&gt;**：将一个数的二进制位向右移动指定的位数，左侧始终补 0，不考虑符号位，</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 5 -&gt; 0101，右移 1 位，左侧补 0，结果为 0010，即十进制 2</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span> &gt;&gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 输出 2</span><br><br><span class="hljs-comment">// 对于负数，如 -1 的 32 位表示为 0xFFFFFFFF，</span><br><span class="hljs-comment">// 无符号右移 1 位后为 0x7FFFFFFF，即十进制 2147483647</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">-1</span> &gt;&gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 输出 2147483647</span><br></code></pre></td></tr></table></figure><h2 id="12、为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组"><a href="#12、为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" class="headerlink" title="12、为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组"></a>12、为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组</h2><p>arguments是类数组，它被设计成一个简单的对象，仅提供数字索引和 <code>length</code> 属性。</p><p>在许多使用场景中，开发者只需要读取参数数量和逐个访问参数，而不需要数组提供的高级方法，因此将其设计为类数组就足够了。</p><p><strong>传统的for循环</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[i]);<br>  &#125;<br>&#125;<br><span class="hljs-title function_">demo</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 分别输出 1, 2, 3</span><br></code></pre></td></tr></table></figure><p><strong>for ..of循环</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arg <span class="hljs-keyword">of</span> <span class="hljs-variable language_">arguments</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg);<br>  &#125;<br>&#125;<br><span class="hljs-title function_">demo</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>转换为真正的数组</strong></p><p>使用 <code>Array.from()</code>：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>) &#123;<br>  const argsArray = <span class="hljs-built_in">Array</span>.from(arguments);<br>  argsArray.forEach(<span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arg));<br>&#125;<br>demo(<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>);<br></code></pre></td></tr></table></figure><p>使用扩展运算符：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>) &#123;<br>  const argsArray = [...arguments];<br>  argsArray.forEach(<span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arg));<br>&#125;<br>demo(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><p>使用 <code>Array.prototype.slice.call()</code>：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>) &#123;<br>  const argsArray = <span class="hljs-built_in">Array</span>.prototype.<span class="hljs-built_in">slice</span>.call(arguments);<br>  argsArray.forEach(<span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arg));<br>&#125;<br>demo(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="13、什么是-DOM-和-BOM？"><a href="#13、什么是-DOM-和-BOM？" class="headerlink" title="13、什么是 DOM 和 BOM？"></a>13、什么是 DOM 和 BOM？</h2><p><strong>DOM：文档对象模型</strong> – Document Object Model</p><p>是一种标准的编程接口，代表整个文档的结构，是一个树形结构，用来表示HTML文档的结构和内容。它把页面解析为一个树状结构，每个HTML元素、属性、文本都被视为一个节点。允许脚本动态访问和修改页面的内容、结构、样式。提供丰富的 API 以实现动态交互和更新页面内容。</p><ul><li><p>元素选择</p><blockquote><p>document.getElementById(id)</p><p>document.getElementsByClassName(className) ———– HTMLCollection 动态</p><p>document.getElementsByTagName(tagName) ———– HTMLCollection 动态</p><p>document.querySelector(selector)</p><p>document.querySelectorAll(selector) ——– NodeList 静态</p></blockquote></li><li><p>节点操作</p><blockquote><p>document.createElement(tagName)</p><p>element.appendChild(node)</p><p>element.insertBefore(newNode, referenceNode)</p><p>element.removeChild(node)</p><p>element.replaceChild(newNode, oldNode)</p><p>element.cloneNode(deep)</p></blockquote></li><li><p>内容和属性操作</p><blockquote><p>element.innerHTML</p><p>element.textContent</p><p>element.setAttribute(name, value)</p><p>element.getAttribute(name)</p><p>element.removeAttribute(name)</p></blockquote></li><li><p>样式与类操作</p><blockquote><p>element.style</p><p>element.classList.add()&#x2F;remove()&#x2F;toggle()&#x2F;contains()</p></blockquote></li><li><p>事件处理</p><blockquote><p>element.addEventListener(event, handler, options)</p><p>element.removeEventListener(event, handler, options)</p><p>element.dispatchEvent(event)</p></blockquote></li><li><p>DOM 遍历</p><blockquote><p>node.parentNode &#x2F; node.parentElement</p><p>node.childNodes &#x2F; element.children</p><p>node.firstChild &#x2F; node.lastChild</p><p>node.nextSibling &#x2F; node.previousSibling</p></blockquote></li></ul><p><strong>BOM：浏览器对象模型</strong> – Browser Object Model</p><p>是和浏览器交互的对象和接口，主要用来访问和控制浏览器窗口和环境，而不是页面内容本身。允许开发者操作浏览器窗口、导航、历史记录、屏幕信息等。包括 <code>window</code>、<code>navigator</code>、<code>location</code>、<code>history</code>、<code>screen</code> 等对象。不同于 DOM，它不规定文档内容的结构，而是与浏览器环境（例如窗口、框架、地址栏等）相关。</p><ul><li><p>window 对象</p><blockquote><p>window.alert(message)</p><p>window.confirm(message)</p><p>window.prompt(message, default)</p><p>window.open(url, name, specs)</p><p>window.close()</p><p>window.setTimeout(callback, delay)</p><p>window.setInterval(callback, delay)</p><p>window.clearTimeout(id) &#x2F; window.clearInterval(id)</p></blockquote></li><li><p>location 对象</p><blockquote><p>location.href</p><p>location.assign(url)</p><p>location.replace(url)</p><p>location.reload()</p></blockquote></li><li><p>history 对象</p><blockquote><p>history.back()</p><p>history.forward()</p><p>history.go(delta)</p></blockquote></li><li><p>navigator 对象</p><blockquote><p>navigator.userAgent</p><p>navigator.language</p><p>navigator.onLine</p><p>navigator.geolocation</p></blockquote></li><li><p>screen 对象</p><blockquote><p>screen.width、screen.height</p><p>screen.availWidth、screen.availHeight</p></blockquote></li></ul><h2 id="14、对AJAX的理解，实现一个AJAX请求"><a href="#14、对AJAX的理解，实现一个AJAX请求" class="headerlink" title="14、对AJAX的理解，实现一个AJAX请求"></a>14、对AJAX的理解，实现一个AJAX请求</h2><p><strong>AJAX（Asynchronous JavaScript and XML）</strong>是一种技术，不用重新加载整个页面，能够与服务器交换数据，来更新部分网页的技术。网页可以实现异步加载数据，从而改善用户体验。虽然名字里有XML，但是现代AJAX请求通常使用JSON格式的数据进行交互。</p><ul><li>异步通信：在后台与服务器通信，不会阻塞用户界面或者刷新页面。</li><li>数据格式：最初是XML，现在是JSON。</li><li>浏览器支持：可以使用XMLHttpRequest对象或者fetch API。</li></ul><p><strong>实现一个 AJAX 请求（使用 XMLHttpRequest）</strong></p><p>1、创建XMLHttpRequest对象</p><p>2、配置请求</p><p>3、设置状态变化监听</p><p>4、发送请求</p><p>5、回调处理</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>xhr.open(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;data.json&quot;</span>, <span class="hljs-literal">true</span>);<br>xhr.onreadystatechange = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span> &amp;&amp; xhr.status === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(xhr.responseText);<br>  &#125;<br>&#125;;<br>xhr.send();<br></code></pre></td></tr></table></figure><p><strong>？</strong> fetch怎么使用</p><p>xhr需要手动检查<code>readyState</code>和<code>status</code>判断请求是否成功，fetch是基于Promise的，语法更简洁，便于链式调用和错误捕获。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade">fetch(<span class="hljs-string">&#x27;data.json&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-comment">// 指定请求方法为 POST</span><br>  headers: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">body</span>: JSON.stringify(&#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> &#125;)<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())<br>.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data))<br>.catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;Error:&#x27;</span>, error));<br></code></pre></td></tr></table></figure><p><strong>？</strong> 使用 Promise 封装 AJAX</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ajaxGet</span>(<span class="hljs-params">url</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>        xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>,url,<span class="hljs-literal">true</span>)<br>        xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>)&#123;<br>                <span class="hljs-title function_">resolve</span>(xhr.<span class="hljs-property">responseText</span>)<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;fail&#x27;</span>))<br>            &#125;<br>        &#125;<br>        xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;网络错误&#x27;</span>))<br>        &#125;<br><br>        xhr.<span class="hljs-title function_">send</span>()<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>xhr.readyState：0,1,2,3,4</p><h2 id="15、JavaScript为什么要进行变量提升"><a href="#15、JavaScript为什么要进行变量提升" class="headerlink" title="15、JavaScript为什么要进行变量提升"></a>15、JavaScript为什么要进行变量提升</h2><p>变量提升：代码执行前，解释器会先扫描整个作用域（函数作用域或者全局作用域），将变量和函数的声明都提升到作用域的最前面。这里的提升针对的是声明部分，不是赋值。</p><p><strong>为什么会有变量提升</strong></p><p>JS在执行代码前，会先经过一个<strong>编译</strong>阶段。在这个阶段，解释器会给<strong>每个变量和函数创建内存空间</strong>，并且建立作用域链。在 ES5 及之前的版本中，JavaScript 只有函数级作用域（没有块级作用域）。为了保持作用域的一致性，变量声明都会被提升到函数或全局的最顶部，这样可以确保在整个函数体内都能访问到这些变量（虽然如果在使用前没有赋值，则值为 <code>undefined</code>）。变量提升是 JavaScript 早期设计的一部分，它帮助解释器在运行时对代码结构有一个整体的认识。虽然这可能会让初学者感到困惑，但它是语言实现的一种选择，同时也为后续的改进（比如 ES6 中的 <code>let</code> 和 <code>const</code>，它们也存在提升但有“暂时性死区”）打下了基础。</p><h2 id="16、ES6模块与CommonJS模块有什么异同"><a href="#16、ES6模块与CommonJS模块有什么异同" class="headerlink" title="16、ES6模块与CommonJS模块有什么异同"></a>16、<strong>ES6</strong>模块与<strong>CommonJS</strong>模块有什么异同</h2><p>它们都是JS里面的模块化系统，用于实现代码的分离、组织和重用。</p><p><strong>ES Module：</strong>是ECMAScript2015(ES6)引入的官方模块系统，已经是JS标准的一部分。模块的依赖关系在编译时就能确定。语法是通过<code>export</code>导出变量或者函数，通过<code>import</code>引入其他模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> value = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 导入</span><br><span class="hljs-keyword">import</span> &#123; value, greet &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>CommonJS</strong>：是Node.js中使用的模块系统，适合服务器端环境。模块在加载时采用同步加载，在运行时解析依赖，适合于服务器环境的同步 I&#x2F;O 操作。语法是通过<code>module.exports</code>或者<code>exports</code>导出。通过<code>require</code>引入模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 导出</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">42</span>,<br>  <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 导入</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./module.js&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">value</span>);<br><span class="hljs-variable language_">module</span>.<span class="hljs-title function_">greet</span>();<br></code></pre></td></tr></table></figure><p><strong>它们的差异：</strong></p><ul><li><p>语法差异</p><ul><li><p>es6模块：使用<code>export</code>、<code>export default </code>关键字导出，<code>import</code>导入。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-comment">// 命名导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#x27;bar&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123; ... &#125;</span>;</span><br><span class="hljs-comment">//默认导出 只能有一个</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123; ... &#125;</span>;</span><br></code></pre></td></tr></table></figure><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-comment">//导入命名导出  解构语法</span><br><span class="hljs-keyword">import</span> &#123; foo, func &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>;<br><span class="hljs-comment">//导入默认导出</span><br><span class="hljs-keyword">import</span> myFunc <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>CommonJS：使用<code>module.exports</code>或者<code>exports</code>导出，<code>require</code>导入。</p><p><code>exports</code> 是 <code>module.exports</code>的简写，只能用于添加属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 导出 只能有一个</span><br><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123; value: <span class="hljs-number">42</span> &#125;;<br><span class="hljs-comment">// 导出多个命名成员</span><br><span class="hljs-keyword">exports</span>.foo = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-keyword">exports</span>.bar = <span class="hljs-string">&quot;World&quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const moduleA</span> = require(<span class="hljs-string">&#x27;./moduleA&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>加载和执行的时机</p><p>es6：静态加载，编译时就确定模块依赖关系，可以进行静态分析。支持异步加载。</p><p>commonjs：同步加载，动态加载，<code>require()</code> 可出现在代码任意位置。在<code>require</code>调用时，会立即加载并执行对应模块。适用服务器端，因为文件IO操作通常是同步的。</p></li><li><p>作用域与变量绑定</p><p>es6：实时绑定。导出的是值的引用，模块内部变化会同步到导入方。当模块内部的值变化时，导入的模块可以感知变化。自动采用严格模式，提高代码健壮性。导入的是实时的引用（live binding），看到的是原始变量的当前状态；这种引用是只读的（不能整体重赋值），但如果值是对象，修改内部属性仍然可行。</p><p>commonjs：模块内部的变量是私有的，通过<code>require</code>的引入其实是模块导出对象的拷贝。一旦加载完成，再改变内部变量，不会反映在其他模块中导入的值上。导入时类似“浅拷贝”：拿到的是一个快照，如果整个对象被重新赋值，导入的绑定不会改变，但内部属性修改仍然共享。</p></li><li><p>循环依赖的处理</p><p>es6：依赖关系在编译阶段就已确定，采用实时绑定，可以在模块间动态同步状态。<br>但要注意，在模块尚未完全初始化前使用导入的变量可能会出现问题，因此也需要谨慎设计模块间的调用顺序。</p><p>commonjs：模块加载是同步的，缓存机制可能导致在循环依赖中获取到部分初始化的导出对象。<br>解决循环依赖的关键在于重新组织代码结构或延迟加载。</p></li></ul><p><strong>共同点</strong></p><ul><li>目的一致：两者都用于将代码分割成独立的模块，实现职责分离和代码重用。</li><li>对象属性修改：无论采用哪种模块系统，如果模块导出的是一个对象，导入后都可以修改这个对象内部的属性值（前提是对象本身没有被重新赋值）。</li></ul><h2 id="17、常见的DOM操作有哪些"><a href="#17、常见的DOM操作有哪些" class="headerlink" title="17、常见的DOM操作有哪些"></a>17、常见的DOM操作有哪些</h2><p><strong>获取元素</strong></p><p>通过ID：<code>document.getElementById</code></p><p>通过标签名： <code>document.getElementsByTagName</code></p><p>通过类名：<code>document.getElementsByClassName</code></p><p>通过css选择器：<code>document.querySelector</code>、<code>document.querySelectorAll</code></p><p><strong>创建元素</strong>：<code>document.createElement</code></p><p><strong>插入元素</strong>：</p><p>​父元素末尾插入：<code>parentElement.appendChild</code></p><p>​指定元素前插入：<code>parentElement.insertBefore(newElement, referenceElement)</code></p><p><strong>删除元素</strong>：</p><p>​删除子元素：<code>parentElement.removeChild</code></p><p>​直接删除元素：<code>element.remove()</code></p><p><strong>修改元素：</strong></p><p>​修改元素内容：<code>element.textContent</code>、<code>element.innerHTML</code></p><p>​修改元素属性：<code>element.setAttribute</code>、<code>element.getAttribute</code>、<code>element.removeAttribute</code></p><p>​修改样式：<code>element.style.</code>、<code>element.classList.add</code>、<code>element.classList.remove</code>、<code>element.classList.toggle</code>、<code>element.classList.contains</code></p><p><strong>遍历元素：</strong></p><p>​获取父元素： <code>element.parentElement</code></p><p>​获取子元素：<code>element.children</code>、 <code>element.firstElementChild</code>、<code>element.lastElementChild</code></p><p>​获取兄弟元素：<code>element.nextElementSibling</code>、<code>element.previousElementSibling</code></p><p><strong>事件操作</strong>：</p><p>​绑定事件：<code>element.addEventListener</code></p><p>​移除事件：<code>element.removeEventListener</code></p><h2 id="18、-use-strict是什么"><a href="#18、-use-strict是什么" class="headerlink" title="18、 use strict是什么"></a>18、 use strict是什么</h2><p>use strict是JS里面的一条指令，<strong>启动严格模式</strong>。能帮助写出更健壮、更安全的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br></code></pre></td></tr></table></figure><p>可以在脚本的最开始添加，或者在函数内部启用。</p><p>特点：</p><ul><li><p>捕获错误：比如使用未声明的变量会报错  &#x2F;&#x2F; ReferenceError: a is not defined</p><blockquote><p>在非严格模式下，直接给未声明的变量赋值，会自动创建一个全局变量；</p></blockquote></li><li><p>普通函数调用，this 关键字的绑定：</p></li></ul><p>  非严格模式，默认指向全局对象（window)</p><p>  严格模式，则为undefined。迫使开发者在使用 <code>this</code> 时更加明确其绑定对象，减少潜在的错误。</p><ul><li><p>禁止重复的参数名和对象属性</p></li><li><p>禁止删除变量、函数或参数</p></li><li><p>禁用 with 语句（<code>with</code> 语句会改变作用域链，容易引起混乱和难以调试的问题）</p></li><li><p>部分标识符被视为保留字，不能用作变量名或函数名。例如<code>public </code></p></li></ul><h2 id="19、如何判断一个对象是否属于某个类"><a href="#19、如何判断一个对象是否属于某个类" class="headerlink" title="19、如何判断一个对象是否属于某个类"></a>19、如何判断一个对象是否属于某个类</h2><p><strong>1、使用instance of运算符</strong></p><p>检查对象的原型链里面是否包含某个构造函数的prototype对象。</p><blockquote><p>instance of 的原理</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceof</span>(<span class="hljs-params"><span class="hljs-built_in">object</span>, constructor</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">object</span> !== <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-built_in">object</span> === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-built_in">object</span>);<br>    <span class="hljs-keyword">while</span> (proto) &#123;<br>        <span class="hljs-keyword">if</span> (proto === constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person instanceof Person);<br></code></pre></td></tr></table></figure><p>还有类class的情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">species</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">species</span> = species;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> animal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&#x27;dog&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(animal <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Animal</span>); <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure><p><strong>2、检查原型链</strong></p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">console</span>.log(<span class="hljs-type">Person</span>.proto<span class="hljs-keyword">type</span>.isPrototypeOf(person));<br></code></pre></td></tr></table></figure><p><strong>3、比较constructor属性</strong></p><p>每个对象都有一个constructor属性，指向创建对象的构造函数。</p><p>但这种方法可能会受到构造函数属性被修改的影响，所以不如 <code>instanceof</code> 稳定。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">console.log(person.constructor <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> Person)<span class="hljs-comment">; // 输出: true</span><br></code></pre></td></tr></table></figure><h2 id="20、强类型语言和弱类型语言的区别"><a href="#20、强类型语言和弱类型语言的区别" class="headerlink" title="20、强类型语言和弱类型语言的区别"></a>20、强类型语言和弱类型语言的区别</h2><p>强类型语言：变量和表达式都有严格的类型限制，不同类型之间<strong>不能随意混用或者隐式转换</strong>，所有的类型转换必须明确的进行。这种严格性可以在编译时或者运行时捕获错误。</p><p>弱类型语言：允许自动隐式转换。代码更简洁，不需要频繁显式声明类型、转换类型。比如数值与字符串的相加。</p><h2 id="21、解释性语言和编译型语言的区别"><a href="#21、解释性语言和编译型语言的区别" class="headerlink" title="21、解释性语言和编译型语言的区别"></a>21、解释性语言和编译型语言的区别</h2><p><strong>编译语言：</strong>（C、C++、Go ）</p><p>需要通过编译器把源代码转换为可以直接执行的机器码。</p><p>可执行文件在操作系统上直接运行，不需要额外的中间解释步骤，运行速度通常较快。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">源代码</span> <span class="hljs-literal">--</span>&gt; <span class="hljs-title">[</span><span class="hljs-comment">编译器</span><span class="hljs-title">]</span> <span class="hljs-literal">--</span>&gt; <span class="hljs-comment">机器码（可执行文件）</span><br></code></pre></td></tr></table></figure><p>优点：</p><ul><li><p>执行效率高：编译后的机器码直接运行，省去了运行时解释的开销。</p></li><li><p>提前发现错误：编译器在编译阶段会进行语法、类型等检查，能在运行前捕获部分错误。</p></li></ul><p>缺点：</p><ul><li>编译时间：大规模项目可能需要较长的编译时间。</li><li>平台依赖性：生成的机器码通常与平台相关，不同操作系统和硬件需要不同版本的可执行文件。</li><li>调试不够灵活：编译后的代码和源代码之间的映射可能不直观，调试时需要借助符号表等辅助工具。</li></ul><p><strong>解释语言</strong>（Python、JavaScript）</p><p>在运行时由解释器逐行读取源代码，即时执行。将每一行代码翻译成机器码后马上执行。</p><p>不需要事先生成独立的可执行文件。执行速度可能较编译型语言慢一些。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">源代码</span> <span class="hljs-literal">--</span>&gt; <span class="hljs-title">[</span><span class="hljs-comment">解释器</span><span class="hljs-title">]</span> <span class="hljs-literal">--</span>&gt; <span class="hljs-comment">执行（逐行解释）</span><br></code></pre></td></tr></table></figure><p>优点：</p><ul><li>跨平台性好：只要有相应平台的解释器，源代码可以直接运行，不依赖平台特定的机器码。</li><li>开发调试便捷：无需编译，可以快速修改代码并立即看到效果，适合快速原型开发。</li><li>动态性高：支持动态类型、动态绑定等特性，使得语言更灵活。</li></ul><p>缺点：</p><ul><li>执行效率较低：每次运行都需要解析源代码，存在额外的解释开销。</li><li>错误发现较晚：某些错误只能在运行时才会暴露，可能影响程序稳定性。</li></ul><p><strong>混合模式</strong>：<br>现代语言和执行环境往往采用编译与解释相结合的方式，例如：</p><ul><li><strong>Java</strong>：先将源代码编译成平台无关的字节码，再由 Java 虚拟机（JVM）解释执行或采用即时编译（JIT）技术将热点代码编译成本地机器码。</li><li><strong>JavaScript</strong>：传统上是解释执行，但现代引擎（如 V8、SpiderMonkey）使用 JIT 技术提高执行效率。一旦检测到某部分代码频繁执行，引擎就会将其编译成机器码，提高后续执行速度。</li></ul><h2 id="22、什么是尾调用，使用尾调用有什么好处？"><a href="#22、什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="22、什么是尾调用，使用尾调用有什么好处？"></a>22、什么是尾调用，使用尾调用有什么好处？</h2><p>尾调用：在函数地方最后一步直接调用另一个函数（或者自身）。</p><p>递归调用是函数最后一步，不需要额外计算。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">tailCallExample</span>(x, y) &#123;<br>  // 在这里没有其他操作，直接返回 f(x, y) 的结果<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">f(x,</span> y);<br>&#125;<br></code></pre></td></tr></table></figure><p>好处：</p><ul><li>减少调用栈的使用：可以复用当前函数的调用帧，避免调用栈不断增长。</li><li>提高性能：由于不需要为每一次递归调用都分配和销毁调用帧，尾调用优化能减少内存分配和回收的开销，提升程序执行效率。</li><li>支持无限递归：论上无限深的递归（例如遍历一个非常大的数据结构），尾调用优化使得这种递归成为可能，因为不会导致栈溢出。</li></ul><blockquote><p>调用栈（Call Stack）:管理函数调用的内存区域，以“栈”（后进先出）的结构管理所有正在执行的函数调用。</p><p>调用帧（Stack Frame）：每当一个函数被调用时，程序会为该函数创建一个“调用帧”。这个帧保存了函数执行时所需的所有信息：函数参数、局部变量、返回程序地址。</p><p>调用帧确保当函数调用嵌套（包括递归）时，每个函数都有自己的执行环境。函数结束时，它对应的调用帧会从调用栈中移除，从而恢复到之前的状态。</p><p>当一个函数调用另一个函数时，就会创建新的调用帧。如果函数递归调用自己而没有进行尾调用优化，每次递归都需要分配新的帧。随着递归深度增大，调用栈上的帧也会越来越多，这可能导致内存不足（栈溢出）。</p><p><strong>尾调用优化</strong>的核心思想是：</p><p>如果函数的最后一步是调用另一个函数（或自身），当前函数调用结束后不再需要做其他操作，那么就可以不创建新的帧，而是复用当前的帧。</p></blockquote><h2 id="23、for…in和for…of的区别"><a href="#23、for…in和for…of的区别" class="headerlink" title="23、for…in和for…of的区别"></a>23、for…in和for…of的区别</h2><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502181617804.png" alt="image-20250218153544246"></p><p><strong>遍历对象属性</strong>：如果使用for..in，需要结合<code>hasOwnProperty</code>过滤继承属性！</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> <span class="hljs-built_in">key</span> <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-keyword">if</span> (obj.hasOwnProperty(<span class="hljs-built_in">key</span>)) &#123;<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">key</span>, obj[<span class="hljs-built_in">key</span>]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>遍历数组和其他可迭代对象</strong>：推荐使用 <code>for...of</code>，因为它更直观，且不会受到对象属性遍历时的顺序问题影响。普通的对象用for..of遍历是会报错的，如果需要遍历的对象是类数组对象，用Array.from转成数组即可。</p><h2 id="24、-ajax、axios、fetch的区别"><a href="#24、-ajax、axios、fetch的区别" class="headerlink" title="24、 ajax、axios、fetch的区别"></a>24、 ajax、axios、fetch的区别</h2><p><strong>AJAX （XMLHttpRequest)</strong></p><p>浏览器内置的 <code>XMLHttpRequest</code> 对象来实现前后端数据交互。基于回调函数。</p><p><strong>原生支持</strong>：几乎所有浏览器都支持 <code>XMLHttpRequest</code>。</p><p><strong>非 Promise 化</strong>：默认 API 基于回调，代码结构较为繁琐，错误处理不够直观。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua">const xhr = new XMLHttpRequest();<br>xhr.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>,<span class="hljs-literal">true</span>);<br>xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>) &#123;<br>    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-built_in">status</span> === <span class="hljs-number">200</span>) &#123;<br>      console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;成功：&#x27;</span>, xhr.responseText);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      console.<span class="hljs-built_in">error</span>(<span class="hljs-string">&#x27;请求出错：&#x27;</span>, xhr.<span class="hljs-built_in">status</span>);<br>    &#125;<br>  &#125;<br>&#125;;<br>xhr.send();<br></code></pre></td></tr></table></figure><p><strong>Fetch</strong></p><p> ES6 后新增的浏览器原生 API，采用 Promise 方式封装 HTTP 请求。</p><p><strong>基于 Promise</strong>：使用 Promise 链式调用，方便处理异步请求和错误。</p><p><strong>更简洁的语法</strong>：写法直观，不需要处理复杂的状态机（如 readyState）。</p><p><strong>错误处理需要注意</strong>：默认只有网络错误会导致 Promise 被 reject，对于 HTTP 错误（如 404、500）不会自动 reject，需要手动判断 <code>response.ok</code>。</p><p><strong>浏览器兼容性</strong>：现代浏览器支持较好，但老版本浏览器可能需要 polyfill。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade">fetch(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!response.ok) &#123;<br>      throw <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&#x27;HTTP error, status = &#x27;</span> + response.status);<br>    &#125;<br>    <span class="hljs-keyword">return</span> response.json();<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;成功：&#x27;</span>, data))<br>  .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;请求出错：&#x27;</span>, error));<br></code></pre></td></tr></table></figure><p><strong>Axios</strong></p><p>基于 Promise 的第三方 HTTP 请求库</p><p><strong>基于 Promise</strong>：与 Fetch 类似，代码风格现代且易于理解</p><p><strong>自动转换 JSON</strong>：响应数据默认会自动转换成 JSON 对象，无需手动调用 <code>.json()</code>。</p><p><strong>拦截器支持</strong>：可以在请求和响应时进行预处理（如添加 token、统一处理错误）。</p><p><strong>更丰富的配置</strong>：支持请求超时、取消请求、配置 baseURL、并发请求等。</p><p><strong>兼容性</strong>：封装了底层实现，适用于大部分浏览器和 Node.js 环境。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">axios.get(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;成功：&#x27;</span>, response.data);<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;请求出错：&#x27;</span>, error);<br>  &#125;);<br></code></pre></td></tr></table></figure><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// 添加请求拦截器</span><br>axios.interceptors.request.use(config =&gt; &#123;<br>  <span class="hljs-comment">// 在请求发送前处理，比如添加认证 token</span><br>  config.headers.Authorization = <span class="hljs-string">&#x27;Bearer YOUR_TOKEN&#x27;</span>;<br>  <span class="hljs-keyword">return</span> config;<br>&#125;, <span class="hljs-keyword">error</span> =&gt; Promise.reject(<span class="hljs-keyword">error</span>));<br><br><span class="hljs-comment">// 添加响应拦截器</span><br>axios.interceptors.response.use(response =&gt; response, <span class="hljs-keyword">error</span> =&gt; &#123;<br>  <span class="hljs-comment">// 统一错误处理</span><br>  console.<span class="hljs-keyword">error</span>(<span class="hljs-string">&#x27;响应错误：&#x27;</span>, <span class="hljs-keyword">error</span>);<br>  <span class="hljs-function"><span class="hljs-keyword">return</span> Promise.<span class="hljs-title">reject</span><span class="hljs-params">(<span class="hljs-keyword">error</span>)</span></span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="25、addEventListener-方法的参数和使用"><a href="#25、addEventListener-方法的参数和使用" class="headerlink" title="25、addEventListener()方法的参数和使用"></a>25、addEventListener()方法的参数和使用</h2><p>这是一个向DOM元素添加事件监听器的方法~！</p><p>当指定的事件发生时，会执行回调函数。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">element</span>.addEventListener(<span class="hljs-keyword">type</span>, listener, options);<br></code></pre></td></tr></table></figure><p>type（必选）：字符串，指定要监听的事件类型，如 <code>&quot;click&quot;</code>、<code>&quot;mouseover&quot;</code>、<code>&quot;keydown&quot;</code> 等。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">// 监听点击事件</span><br>element.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, callback);<br></code></pre></td></tr></table></figure><p>listener（必选）：当事件发生时被调用的回调函数，函数要接收一个事件对象作为参数。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;元素被点击&quot;</span>, event);<br>&#125;<br>element.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, handleClick);<br></code></pre></td></tr></table></figure><p>options（可选）：</p><p><strong>旧版用法（布尔值 useCapture）</strong>：一个布尔值，指定是否在捕获阶段调用事件处理程序。如果为 <code>true</code>，则在事件捕获阶段调用；默认为 <code>false</code>，在冒泡阶段调用。</p><p><strong>现代用法（options 对象）</strong>：</p><p> 是一个对象，可以配置多个选项：</p><ul><li><strong>capture</strong>：布尔值，和 <code>useCapture</code> 功能一样，指定事件在捕获阶段触发。</li><li><strong>once</strong>：布尔值，如果为 <code>true</code>，监听器在第一次触发后会自动移除。</li><li><strong>passive</strong>：布尔值，表示监听器永远不会调用 <code>preventDefault()</code>，有助于提高滚动性能。</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">element.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, handleClick, &#123;<br>  capture: <span class="hljs-literal">false</span>,  <span class="hljs-comment">// 在冒泡阶段触发</span><br>  once: <span class="hljs-literal">true</span>,      <span class="hljs-comment">// 只执行一次</span><br>  passive: <span class="hljs-literal">true</span>    <span class="hljs-comment">// 提示不会调用 preventDefault()</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>可以使用 <code>removeEventListener</code> 方法移除监听器</p><p><strong>？</strong> 事件传播阶段</p><blockquote><p>事件在 DOM 树中传播分为三个阶段：捕获阶段、目标阶段和冒泡阶段。</p><p>通过设置 <code>capture</code> 选项（或旧的 <code>useCapture</code> 参数），可以指定事件处理程序在捕获阶段或冒泡阶段被调用。</p></blockquote><p><strong>？</strong> 三个阶段在做什么</p><blockquote><p>捕获阶段：当一个事件发生时（例如点击一个按钮），浏览器会从 <code>document</code>根节点开始，沿着 DOM 树从最外层的元素逐级传递事件，直到到达事件的目标元素。监听器需设置 <code>capture: true</code> 才能在此阶段触发。</p><p>目标对象：当事件到达目标元素时，进入目标阶段。在这一阶段，目标元素本身既处于捕获阶段的末尾，也处于冒泡阶段的开始。所有监听器均会触发。</p><p>冒泡阶段：事件在目标阶段处理完毕后，会从目标元素开始，沿着 DOM 树向上逐级传递回根元素（即 <code>document</code>），这个过程称为冒泡阶段。这个阶段，事件会依次触发父级元素上注册的监听器。</p></blockquote><p><strong>？</strong>事件类型</p><blockquote><ol><li>鼠标事件<br>click：鼠标单击事件。<br>dblclick：鼠标双击事件。<br>mousedown：鼠标按下事件。<br>mouseup：鼠标释放事件。<br>mousemove：鼠标移动事件。<br>mouseover &#x2F; mouseout：鼠标进入&#x2F;离开元素事件。<br>mouseenter &#x2F; mouseleave：类似于 mouseover&#x2F;mouseout，但不冒泡。<br>contextmenu：右键菜单事件。</li><li>键盘事件<br>keydown：按键按下时触发。<br>keyup：按键释放时触发。<br>keypress：按键产生字符时触发（现已逐渐废弃）。</li><li>表单及输入事件<br>submit：表单提交事件。<br>change：表单元素的值发生变化时触发（下拉列表、复选框、文本框等）。<br>input：输入框内容发生变化时触发。<br>focus：元素获得焦点时触发。<br>blur：元素失去焦点时触发。</li><li>窗口&#x2F;文档事件<br>load：页面或图像等资源加载完成时触发。<br>unload：页面卸载时触发。<br>beforeunload：在页面卸载之前触发（常用于提示用户）。<br>resize：窗口尺寸改变时触发。<br>scroll：滚动条滚动时触发。<br>DOMContentLoaded：初始的 HTML 文档被完全加载和解析完成后触发。</li><li>触摸事件（移动端）<br>touchstart：触摸开始时触发。<br>touchmove：触摸移动时触发。<br>touchend：触摸结束时触发。<br>touchcancel：触摸因某种原因中断时触发。</li><li>指针事件（支持鼠标、触控、笔输入）<br>pointerdown、pointerup、pointermove、pointercancel 等。</li><li>拖拽事件<br>drag、dragstart、dragenter、dragover、dragleave、drop、dragend。</li><li>动画与过渡事件<br>animationstart、animationend、animationiteration。<br>transitionend。</li><li>媒体事件<br>play、pause、ended：视频或音频播放控制。<br>timeupdate：媒体播放位置更新时触发。<br>volumechange：音量变化时触发。<br>canplay：足够的数据已经加载，可以开始播放时触发。<br>error：媒体加载或播放过程中发生错误时触发。</li><li>其他事件<br>error：加载资源（图片、脚本等）失败时触发。<br>wheel：鼠标滚轮滚动事件。</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
      <tag>new操作符</tag>
      
      <tag>map和Object</tag>
      
      <tag>WeakMap</tag>
      
      <tag>内置对象</tag>
      
      <tag>JSON</tag>
      
      <tag>脚本延迟加载</tag>
      
      <tag>类数组对象</tag>
      
      <tag>数组</tag>
      
      <tag>Unicode</tag>
      
      <tag>位运算符</tag>
      
      <tag>DOM</tag>
      
      <tag>BOM</tag>
      
      <tag>AJAX</tag>
      
      <tag>Axios</tag>
      
      <tag>Fetch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6相关芝士点</title>
    <link href="/2025/02/17/ES6%E7%9B%B8%E5%85%B3%E8%8A%9D%E5%A3%AB%E7%82%B9/"/>
    <url>/2025/02/17/ES6%E7%9B%B8%E5%85%B3%E8%8A%9D%E5%A3%AB%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="ES6相关芝士点"><a href="#ES6相关芝士点" class="headerlink" title="ES6相关芝士点"></a>ES6相关芝士点</h1><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502171610540.png" alt="image-20250217160942325"></p><h2 id="1、let、const、var的区别"><a href="#1、let、const、var的区别" class="headerlink" title="1、let、const、var的区别"></a>1、let、const、var的区别</h2><p><strong>作用域</strong></p><p>var 声明的变量具有函数作用域或全局作用域。</p><blockquote><p>函数作用域：如果在函数内使用 var 声明变量，则该变量只在这个函数内有效。</p></blockquote><p>let 和 const 声明的变量具有块级作用域。</p><blockquote><p>块级作用域：由大括号 {} 包含的区域。</p></blockquote><p><strong>变量提升</strong></p><blockquote><p>变量提升：将变量是或者函数声明提升到所在作用域顶部的行为。</p></blockquote><p>var 声明的变量会被提升到函数作用域或全局作用域顶部，但只提升声明，不提升赋值。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a); <span class="hljs-comment">// 输出: undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>let 和 const 声明的变量也会被提升到块级作用域的顶部，但处于暂时性死区状态！不会被初始化，因此这时候访问它会抛出<code>ReferenceError</code> 错误！</p><blockquote><p>暂时性死区：变量处于不可访问状态。</p></blockquote><p><strong>全局属性</strong></p><p>在全局作用域中用 var 声明的变量，会自动成为全局对象的一个属性。<br>容易与其他全局属性冲突，增加全局命名空间的负担。</p><p>在全局作用域中用 let 和 const 声明的变量，不会附加到全局对象上。</p><p><strong>重复声明</strong></p><p>在同一作用域内，使用 var 声明的变量，可以重复声明，后面会覆盖前面的值。</p><p>使用 let 和 const 声明的变量，如果在同一块级作用域内，重复声明会导致语法错误。如果在不同的块级作用域内，可以重复声明相同的变量名，不会冲突，因为作用域不同。</p><p><strong>初始化</strong></p><p>const 声明的变量必须在声明的同时初始化，否则会报语法错误。而且一旦声明和初始化后，变量的引用不能再被改变。如果引用的是一个对象或者数组，内部的属性或者元素仍然可以修改，但是变量本身不能重新被赋值。</p><p>var 和 let：可以不立即初始化，声明后默认值为 <code>undefined</code>，并且后续可以赋值。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502171610411.png" alt="image-20250216124540443"></p><h2 id="2、new操作符的原理？可以new箭头函数吗"><a href="#2、new操作符的原理？可以new箭头函数吗" class="headerlink" title="2、new操作符的原理？可以new箭头函数吗"></a>2、new操作符的原理？可以new箭头函数吗</h2><p><strong>1、创建一个空对象</strong></p><p><strong>2、设置原型</strong>：将新对象的内部[[Prototype]]（也就是<code>__proto__</code>）指向构造函数的<code>prototype</code>属性。</p><p><strong>3、执行构造函数</strong>：将新对象作为 this 上下文，调用构造函数，并将参数传递给构造函数。</p><p><strong>4、返回值处理</strong>：如果构造函数显式返回的对象，直接返回。否则，默认返回新对象。</p><p><strong>？</strong> 不能new箭头函数的原因</p><blockquote><p>箭头函数没有自己的 <code>this</code>，它们继承自外部作用域，因此不具备构造函数所需要的特性。</p><p>箭头函数没有 <code>prototype</code> 属性，构造函数需要这个属性来构建实例的原型链。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 定时器中使用箭头函数</span><br>  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 箭头函数没有自己的 this，</span><br>    <span class="hljs-comment">// 这里的 this 会继承自 Person 构造函数中的 this，</span><br>    <span class="hljs-comment">// 所以 this.age 指向的是当前 Person 实例的 age 属性</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>++;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br></code></pre></td></tr></table></figure><h2 id="3、箭头函数与普通函数的区别"><a href="#3、箭头函数与普通函数的区别" class="headerlink" title="3、箭头函数与普通函数的区别"></a>3、箭头函数与普通函数的区别</h2><p><strong>this的绑定</strong></p><ul><li><p>箭头函数</p><p>箭头函数没有自己的this，是<strong>词法绑定</strong>，即继承它定义时候的所在上下文（词法环境）的this值。</p><p>无论怎么调用，箭头函数的this是固定的，固定的，不会再变。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const obj = &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">42</span>,<br>  <span class="hljs-attr">arrow</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this); <span class="hljs-comment">// this 指向外部环境（例如全局对象或父函数的 this），而不是 obj</span><br>  &#125;<br>&#125;;<br>obj.arrow(); <span class="hljs-comment">// 可能输出 window（在浏览器中）或 undefined（在严格模式下）</span><br></code></pre></td></tr></table></figure></li><li><p>普通函数</p><p>普通函数的this是<strong>动态绑定</strong>，取决于它的调用方式。</p><p>对象的方法中调用，this指向对象；</p><p>函数通过new关键字调用，this绑定到新创建的实例对象；</p><p>直接调用，指向全局对象（非严格）或者undefiend（严格）；</p><p>通过call、apply、bind调用，显式指定调用时的this值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">42</span>,<br>  <span class="hljs-attr">method</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// this 指向 obj</span><br>  &#125;<br>&#125;;<br>obj.<span class="hljs-title function_">method</span>(); <span class="hljs-comment">// 输出 obj</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>？</strong>this是什么</p><blockquote><p>在JavaScript中，<code>this</code>是一个非常重要的关键字，它在函数被调用时被赋予一个值，用来指向函数执行的上下文环境（即“谁”在调用这个函数）。</p><p>它的值通常是一个对象，但具体指向哪个对象取决于函数的调用方式。</p><ul><li><strong>作为方法调用</strong>：<code>this</code>指向调用它的对象。</li><li><strong>作为普通函数调用</strong>：<code>this</code>指向全局对象（非严格模式）或<code>undefined</code>（严格模式）。</li><li><strong>作为构造函数调用</strong>：<code>this</code>指向新创建的对象实例。</li><li><strong>通过<code>call</code>、<code>apply</code>或<code>bind</code>调用</strong>：<code>this</code>指向显式指定的对象。</li><li><strong>箭头函数中</strong>：<code>this</code>捕获定义时所在上下文的<code>this</code>值。</li></ul></blockquote><p><strong>arguments对象</strong></p><ul><li><p>箭头函数</p><p>没有自己的 <code>arguments</code> 对象。</p><p>箭头函数内部的<code>arguments</code>会从其定义时所在的<strong>词法作用域</strong>继承而来。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) &#123;<br>  const arrow = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arguments); <span class="hljs-comment">// 引用的是 outer 函数的 arguments</span><br>  &#125;;<br>  arrow();<br>&#125;<br>outer(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 输出 [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li><li><p>普通函数</p><p>有自己的 <code>arguments</code> 对象，包含了传入函数的所有参数。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">function <span class="hljs-attribute">normal</span>() &#123;<br>  console<span class="hljs-selector-class">.log</span>(arguments); <span class="hljs-comment">// 输出传入的参数对象</span><br>&#125;<br><span class="hljs-attribute">normal</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 输出 [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>用作构造函数</strong></p><ul><li><p>箭头函数</p><p>不能用作构造函数，无法使用 <code>new</code> 操作符调用，因为它们没有内部的 <code>[[Construct]]</code> 方法，也没有 <code>prototype</code> 属性。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const Arrow <span class="hljs-operator">=</span> () <span class="hljs-operator">=</span>&gt; &#123;&#125;<span class="hljs-comment">;</span><br>// new Arrow()<span class="hljs-comment">; // TypeError: Arrow is not a constructor</span><br></code></pre></td></tr></table></figure></li><li><p>普通函数</p><p>可以用作构造函数，通过 <code>new</code> 调用后，会创建一个新对象，并将其绑定到函数内部的 <code>this</code> 上。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> Person(<span class="hljs-type">name</span>) &#123;<br>  this.name = <span class="hljs-type">name</span>;<br>&#125;<br>const p = <span class="hljs-built_in">new</span> Person(&quot;Alice&quot;);<br>console.log(p.name); // &quot;Alice&quot;<br></code></pre></td></tr></table></figure></li></ul><p><strong>prototype属性</strong></p><ul><li><p>箭头函数</p><p>不存在 <code>prototype</code> 属性，因为它们不能作为构造函数。</p></li><li><p>普通函数</p><p>拥有 <code>prototype</code> 属性，当函数被用作构造函数时，该属性会成为新创建对象的原型。</p></li></ul><h2 id="4、扩展运算符的作用及使用场景"><a href="#4、扩展运算符的作用及使用场景" class="headerlink" title="4、扩展运算符的作用及使用场景"></a>4、扩展运算符的作用及使用场景</h2><p>ES6引入的语法，…主要是把可迭代对象（数组、字符串、Set、Map等）或者对象展开为单独的元素或者属性。</p><p><strong>数组合并、数组复制</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> arr1 = [1, 2, 3];<br><span class="hljs-keyword">const</span> arr2 = [4, 5, 6];<br><br><span class="hljs-comment">// 合并数组</span><br><span class="hljs-keyword">const</span> merged = [...arr1, ...arr2];<br>console.<span class="hljs-built_in">log</span>(merged); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br><br><span class="hljs-comment">// 复制数组（浅拷贝）</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">copy</span> = [...arr1];<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">copy</span>); <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><p><strong>？</strong> 浅拷贝的含义</p><blockquote><p><strong>浅拷贝</strong>仅复制数组的第一层，引用类型元素与原数组共享内存。</p><p>修改基本类型（不影响原数组），修改引用类型的内容（影响原数组）</p><p>但<strong>替换</strong>整个元素（改变引用）不会影响原数组。</p></blockquote><p><strong>函数参数传递</strong></p><p>参数存储在数组中时，可以使用扩展运算符将数组转换为一个参数列表。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b, c</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b + c;<br>&#125;<br><br>const numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">sum</span>(...numbers)); <span class="hljs-comment">// 输出 6</span><br></code></pre></td></tr></table></figure><p><strong>？</strong> 和rest运算符的区别</p><blockquote><p><strong>rest 运算符</strong>（使用三个点 <code>...</code>）用于将多个数据“收集”成一个数组或对象，主要应用在函数参数和解构赋值中。它与扩展运算符（spread operator）共享相同的语法，但语义相反：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-rest_arg">...numbers</span>)</span> &#123;<br>  <span class="hljs-comment">// `numbers` 是一个数组，包含了所有传入的参数</span><br>  <span class="hljs-keyword">return</span> numbers.reduce((acc, curr) =&gt; acc + curr, <span class="hljs-number">0</span>);<br>&#125;<br><br>console.log(sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// 输出 10</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>对象合并、对象复制</strong></p><p>将多个对象的属性合并到一个新对象中</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">const</span> obj1 = &#123; a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-attribute">const</span> obj2 = &#123; c: <span class="hljs-number">3</span>, d: <span class="hljs-number">4</span> &#125;;<br><br><span class="hljs-attribute">const</span> mergedObj = &#123; ...obj1, ...obj2 &#125;;<br><span class="hljs-attribute">console</span>.log(mergedObj); // &#123; a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span>, c: <span class="hljs-number">3</span>, d: <span class="hljs-number">4</span> &#125;<br></code></pre></td></tr></table></figure><p>利用扩展运算符进行浅拷贝，快速复制一个对象</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">const</span> original = &#123; name: <span class="hljs-string">&quot;Alice&quot;</span>, age: <span class="hljs-number">25</span>,c:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]&#125;;<br><span class="hljs-attribute">const</span> clone = &#123; ...original &#125;;<br><span class="hljs-attribute">clone</span>.name = &#x27;an&#x27;<br><span class="hljs-attribute">clone</span>.c.push(<span class="hljs-number">4</span>)<br><span class="hljs-attribute">console</span>.log(clone); // &#123; name: <span class="hljs-string">&quot;an&quot;</span>, age: <span class="hljs-number">25</span> &#125;<br><span class="hljs-attribute">console</span>.log(original); // &#123; name: <span class="hljs-string">&quot;Alice&quot;</span>, age: <span class="hljs-number">25</span> &#125;<br></code></pre></td></tr></table></figure><p><strong>解构赋值</strong></p><p>用于提取剩余的数组元素或对象属性。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 数组解构</span><br>const [<span class="hljs-built_in">first</span>, ...rest] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">first</span>); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(rest);  <span class="hljs-comment">// [2, 3, 4]</span><br><br><span class="hljs-comment">// 对象解构</span><br>const &#123; a, ...others &#125; = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">30</span> &#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a);     <span class="hljs-comment">// 10</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(others); <span class="hljs-comment">// &#123; b: 20, c: 30 &#125;</span><br></code></pre></td></tr></table></figure><h2 id="5、什么是解构"><a href="#5、什么是解构" class="headerlink" title="5、什么是解构"></a>5、什么是解构</h2><p>ES6提供的一种模式，用于从数组或对象提取数据，是一种语法糖。</p><p><strong>数组解构</strong></p><p>按顺序、默认值、跳过元素、嵌套解构</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>const [a, b, c] = arr;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b); <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(c); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-type">const</span> [x, y, z = <span class="hljs-number">3</span>] = arr; <span class="hljs-comment">// z 默认值为 3，因为 arr 第三项不存在</span><br>console.<span class="hljs-built_in">log</span>(x, y, z); <span class="hljs-comment">// 1 2 3</span><br><br><span class="hljs-type">const</span> nested = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]];<br><span class="hljs-type">const</span> [m, [n, o]] = nested; <span class="hljs-comment">// 要按照嵌套解构来，否则o是undefined</span><br>console.<span class="hljs-built_in">log</span>(m, n, o); <span class="hljs-comment">// 1 2 3</span><br></code></pre></td></tr></table></figure><p><strong>对象解构</strong></p><p>以属性名为匹配条件！换顺序也可以提取！</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xl">const person = &#123; <span class="hljs-keyword">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, age: <span class="hljs-number">25</span> &#125;;<br>const &#123; <span class="hljs-keyword">name</span>, age &#125; = person;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">name</span>); <span class="hljs-comment">// &quot;Alice&quot;</span><br>console.<span class="hljs-built_in">log</span>(age);  <span class="hljs-comment">// 25</span><br></code></pre></td></tr></table></figure><p>也可以使用别名，默认值</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bob&quot;</span> &#125;;<br>const &#123; <span class="hljs-attr">name</span>: xxx, <span class="hljs-attr">age</span>: a = <span class="hljs-number">30</span> &#125; = person;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(xxx); <span class="hljs-comment">// &quot;Bob&quot;</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a); <span class="hljs-comment">// 30 （因为 person 没有 age 属性，所以使用默认值 30）</span><br></code></pre></td></tr></table></figure><p><strong>？</strong> 如果是深度嵌套如何提取</p><blockquote><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">const school = &#123;</span><br><span class="hljs-attribute">   classes</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#123;</span><br>      <span class="hljs-attribute">stu</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#123;</span><br>         <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;Bob&#x27;,</span><br>         <span class="hljs-attribute">age</span><span class="hljs-punctuation">:</span> <span class="hljs-string">24,</span><br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const &#123; classes: &#123; stu: &#123; <span class="hljs-type">name</span> &#125; &#125;&#125; = school<br>       <br>console.log(<span class="hljs-type">name</span>)  // <span class="hljs-string">&#x27;Bob&#x27;</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>应用场景</strong></p><p>函数参数使用解构提取数组或者对象的值</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">&#123; name, age &#125;</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`Name: <span class="hljs-subst">$&#123;name&#125;</span>, Age: <span class="hljs-subst">$&#123;age&#125;</span>`</span>);<br>&#125;<br>display(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">28</span> &#125;);<br></code></pre></td></tr></table></figure><p>快速交换变量值（如果是引用类型，交换地址）</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let a = <span class="hljs-number">1</span>, b = <span class="hljs-number">2</span>;<br>[a, b] = [b, a];<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a, b); <span class="hljs-comment">// 2 1</span><br></code></pre></td></tr></table></figure><p>处理返回多个值的函数：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">getCoordinates</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">[10,</span> <span class="hljs-number">20</span>];<br>&#125;<br>const [x, y] = getCoordinates();<br></code></pre></td></tr></table></figure><h2 id="6、ES6中模板字符串语法"><a href="#6、ES6中模板字符串语法" class="headerlink" title="6、ES6中模板字符串语法"></a>6、ES6中模板字符串语法</h2><p>使用反引号来定义模版字面量：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const str</span> = <span class="hljs-string">`Hello, world!`</span>;<br></code></pre></td></tr></table></figure><p>支持多行字符串，无需特殊的转义字符。</p><p>在模板字符串中，空格、缩进、换行都会被保留（所以可以写HTML代码）</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const multiLine = <span class="hljs-string">`这是第一行</span><br><span class="hljs-string">这是第二行</span><br><span class="hljs-string">这是第三行`</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(multiLine); <span class="hljs-comment">//就真的换行了！</span><br></code></pre></td></tr></table></figure><p>通过<code>$&#123;&#125;</code>进行字符串插值，可以嵌入任意表达式，在运行时计算并转为字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;Alice&quot;</span>;<br><span class="hljs-keyword">const</span> age = <span class="hljs-number">25</span>;<br><span class="hljs-keyword">const</span> greeting = <span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;name&#125;</span> and I am <span class="hljs-subst">$&#123;age&#125;</span> years old.`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>let、const、var的区别</tag>
      
      <tag>new操作符的原理</tag>
      
      <tag>箭头函数与普通函数的区别</tag>
      
      <tag>扩展运算符</tag>
      
      <tag>解构</tag>
      
      <tag>模板字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进一步讨论数据类型</title>
    <link href="/2025/02/15/%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AE%A8%E8%AE%BA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2025/02/15/%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AE%A8%E8%AE%BA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="进一步讨论数据类型"><a href="#进一步讨论数据类型" class="headerlink" title="进一步讨论数据类型"></a>进一步讨论数据类型</h1><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502160005197.png" alt="image-20250216000537105"></p><h2 id="1、原始数据类型和引用数据类型的区别"><a href="#1、原始数据类型和引用数据类型的区别" class="headerlink" title="1、原始数据类型和引用数据类型的区别"></a>1、原始数据类型和引用数据类型的区别</h2><p><strong>原始数据类型：</strong></p><ul><li><p>不可变性：原始数据类型的值一旦被创建就不能改变，例如，对字符串的操作总是返回一个新的字符串，不会修改原来的字符串。</p><blockquote><p>字符串池：字符串池（String Pool）是一种内存优化机制。当创建一个新的字符串字面量时，JavaScript 引擎会先检查字符串池中是否已经存在相同内容的字符串。如果存在，则直接返回池中字符串的引用，而不是创建一个新的实例。</p></blockquote></li><li><p>存储方式：直接存储在栈内存，因此复制变量的时候，复制的是实际的值。</p></li><li><p>传递方式：赋值、作为函数参数传递时，是按值传递，传递的是值的副本。</p><blockquote><p>换句话说，原始变量和目标变量在内存中是完全独立的。</p></blockquote></li><li><p>比较方式：直接比较值的内容。</p></li></ul><p><strong>引用数据类型：</strong></p><ul><li><p>可变性：引用类型的值（对象）是可变的，可以动态增加、删除、修改属性。</p></li><li><p>存储方式：引用类型的数据存储在堆内存，变量的引用（内存地址）存储在栈内存。</p></li><li><p>传递方式：赋值、作为函数参数传递时，是按引用传递。这意味着多个变量可能指向的是同一个对象，修改其中一个变量所指向的对象会影响到其他变量。</p></li><li><p>比较方式：比较的是对象的引用（内存地址）。</p></li></ul><p><strong>？</strong> 为什么这样区别设计二者的存储方式</p><blockquote><p>根据原始数据类型的不可变性、大小固定的特点，存储在栈内存，分配速度快，适合存储固定大小、生命周期短的数据，可以高效进行内存分配和回收。</p><p>根据引用数据类型的可变性、大小不固定的特点，堆内存适合存储大小不固定或者需要动态分配内存的数据，空间大，而且灵活。变量中存储的是对实际数据的引用，使得传递对象时不需要复制整个对象，只需要复制引用，提高了效率。</p><p><strong>栈内存</strong>：分配和回收速度快，但适用于简单、固定大小的数据。</p><p><strong>堆内存</strong>：灵活且容量大，但分配和垃圾回收的成本相对较高。</p></blockquote><h2 id="2、它们的垃圾回收是如何进行的，有区别吗"><a href="#2、它们的垃圾回收是如何进行的，有区别吗" class="headerlink" title="2、它们的垃圾回收是如何进行的，有区别吗"></a>2、它们的垃圾回收是如何进行的，有区别吗</h2><p><strong>原始数据类型</strong>：当函数执行结束或变量离开其作用域时，存储在栈中的原始数据会被自动释放，不需要额外的垃圾回收机制介入。</p><p><strong>？</strong> 离开作用域是指</p><blockquote><p>作用域决定了程序哪些部分可以访问某个变量或者函数。常见的作用域有全局作用域、函数作用域、块级作用域（使用 let 或者 const 声明）</p><p>当代码执行进入一个新的块或者函数时，就创建了一个新的作用域，其中声明的变量就只能在这个作用域内使用。当函数执行完毕或者代码块执行结束后，之前在该作用域内声明的变量就会离开作用域。如果没有其他引用，就会成为垃圾回收的候选，内存可以被释放。</p></blockquote><p><strong>引用数据类型</strong>：JS引擎会定期运行垃圾回收器，标记并清除不再被引用的对象。</p><blockquote><p><strong>引用计数垃圾回收：</strong>如果没有指向该对象的引用，那么该对象称作“垃圾”或者可回收的。</p><p>（<strong>备注：</strong> 现代 JavaScript 引擎不再使用引用计数进行垃圾回收，因为存在循环引用问题。）</p><p><strong>标记清除算法：</strong>这个算法将“对象不再需要”这个定义简化为“对象不可达”。在 JavaScript 中，根是全局对象。垃圾回收器将定期从这些根开始，找到从这些根能引用到的所有对象，然后找到从这些对象能引用到的所有对象，等等。从根开始，垃圾回收器将找到所有<em>可到达</em>的对象并收集所有不能到达的对象。</p><p>（<strong>备注：</strong> 当前，所有现代的引擎搭载的是标记清除垃圾回收器。）</p><p><strong>优化：</strong>分代&#x2F;增量&#x2F;并行垃圾回收</p></blockquote><h2 id="3、-数据类型检测的方式有哪些"><a href="#3、-数据类型检测的方式有哪些" class="headerlink" title="3、 数据类型检测的方式有哪些"></a>3、 数据类型检测的方式有哪些</h2><p><strong><code>typeof</code> 运算符</strong></p><p>对于 <code>null</code> 会返回 <code>&quot;object&quot;</code>，这是历史遗留问题。</p><p>对于数组和其他对象，都会返回 <code>&quot;object&quot;</code></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> <span class="hljs-number">42</span>);          <span class="hljs-comment">// &quot;number&quot;</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> <span class="hljs-string">&quot;Hello&quot;</span>);     <span class="hljs-comment">// &quot;string&quot;</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> <span class="hljs-literal">true</span>);        <span class="hljs-comment">// &quot;boolean&quot;</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> <span class="hljs-literal">undefined</span>);   <span class="hljs-comment">// &quot;undefined&quot;</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> Symbol());    <span class="hljs-comment">// &quot;symbol&quot;</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;);<span class="hljs-comment">// &quot;function&quot; ★</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> &#123;&#125;);          <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> []);          <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> <span class="hljs-literal">null</span>);        <span class="hljs-comment">// &quot;object&quot;（注意）★</span><br></code></pre></td></tr></table></figure><p><strong><code>instanceof</code> 运算符</strong></p><p>检测一个对象是否是某个构造函数的实例，用于引用类型检测。</p><p>如果涉及到跨 iframe 或 window 时，可能会出现问题，因为不同全局环境下的构造函数不相等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>);           <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);           <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>);     <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong><code>Object.prototype.toString.call()</code> 方法</strong></p><p>获取一个标准格式的类型字符串。</p><p>能够准确检测绝大多数数据类型，包括内置对象、数组、null、undefined 等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-number">42</span>));           <span class="hljs-comment">// &quot;[object Number]&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&quot;Hello&quot;</span>));      <span class="hljs-comment">// &quot;[object String]&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">true</span>));         <span class="hljs-comment">// &quot;[object Boolean]&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>));    <span class="hljs-comment">// &quot;[object Undefined]&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>));         <span class="hljs-comment">// &quot;[object Null]&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>([]));           <span class="hljs-comment">// &quot;[object Array]&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(&#123;&#125;));           <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;)); <span class="hljs-comment">// &quot;[object Function]&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));   <span class="hljs-comment">// &quot;[object Date]&quot;</span><br></code></pre></td></tr></table></figure><p><strong><code>Array.isArray()</code> 方法</strong></p><p>专门用于检测某个值是否为数组。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Array</span>.isArray([]));      <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Array</span>.isArray(&#123;&#125;));      <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong><code>constructor</code>判断</strong></p><p>通过访问对象的 <code>constructor</code> 属性来判断对象是由哪个构造函数创建的。</p><p>仅限于对象（引用类型）</p><p>通过常规创建方式得到的对象，其原型链会提供一个 <code>constructor</code> 属性。如果使用 <code>Object.create(null)</code> 或手动修改原型后，对象可能没有 <code>constructor</code> 属性。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const obj <span class="hljs-operator">=</span> &#123;&#125;<span class="hljs-comment">;</span><br>console.log(obj.constructor <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> Object)<span class="hljs-comment">; // true</span><br><br>const arr <span class="hljs-operator">=</span> []<span class="hljs-comment">;</span><br>console.log(arr.constructor <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> Array)<span class="hljs-comment">;  // true</span><br></code></pre></td></tr></table></figure><h2 id="4、判断数组的方式有哪些"><a href="#4、判断数组的方式有哪些" class="headerlink" title="4、判断数组的方式有哪些"></a>4、判断数组的方式有哪些</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Array.isArrray(obj)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span><br></code></pre></td></tr></table></figure><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Object</span>.proto<span class="hljs-keyword">type</span>.toString.call(obj).slice(8,-1) === &#x27;<span class="hljs-type">Array&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">obj.__proto__ <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> Array.prototype<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Object.getPrototypeOf(obj) <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> Array.prototype<br></code></pre></td></tr></table></figure><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Array</span>.proto<span class="hljs-keyword">type</span>.isPrototypeOf(obj)<br></code></pre></td></tr></table></figure><p>我根据对原型的理解，画了一张图：</p><p><strong>prototype</strong>：<br>是构造函数的属性，用于为新创建的对象提供共享的属性和方法。</p><p>**<strong>proto</strong>**：<br>是对象的内部属性（或访问器），指向该对象的原型。对象在创建时，会把构造函数的 <code>prototype</code> 赋值给其 <code>__proto__</code>。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502152350401.png" alt="image-20250215211233974"></p><h2 id="5、null和undefined区别"><a href="#5、null和undefined区别" class="headerlink" title="5、null和undefined区别"></a>5、null和undefined区别</h2><p><strong>undefined</strong>：表示变量已声明但尚未赋值。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let a;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a); <span class="hljs-comment">// 输出：undefined</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(foo()); <span class="hljs-comment">// 输出：undefined，因为没有显式返回值</span><br></code></pre></td></tr></table></figure><p><strong>null</strong>：表示“空”或“无值”，是一种有意的赋值，表示变量应当为空。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let b = <span class="hljs-literal">null</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b); <span class="hljs-comment">// 输出：null</span><br></code></pre></td></tr></table></figure><p><strong>严格比较</strong>（&#x3D;&#x3D;&#x3D;）：</p><ul><li><code>undefined === null</code> 返回 <code>false</code>，因为它们类型不同。</li></ul><p><strong>非严格比较</strong>（&#x3D;&#x3D;）：</p><ul><li><code>undefined == null</code> 返回 <code>true</code>，这是因为在非严格比较中，JavaScript 会认为它们都表示“无”的概念。</li></ul><h2 id="6、intanceof-操作符的实现原理及实现"><a href="#6、intanceof-操作符的实现原理及实现" class="headerlink" title="6、intanceof 操作符的实现原理及实现"></a>6、intanceof 操作符的实现原理及实现</h2><p><strong>底层原理</strong>：检查该构造函数的 <code>prototype</code> 属性是否出现在对象的原型链中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkPro</span>(<span class="hljs-params">con, ins</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> con !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;con must be a function&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> proto = ins.<span class="hljs-property">__proto__</span>;<br>  <span class="hljs-keyword">let</span> prototype = con.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>  <span class="hljs-keyword">while</span> (proto !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (proto == prototype) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 示例：</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">const</span> alice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">checkPro</span>(<span class="hljs-title class_">Person</span>, alice)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">checkPro</span>(<span class="hljs-title class_">Array</span>, alice)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="7、为什么0-1-0-2-0-3，如何让其相等"><a href="#7、为什么0-1-0-2-0-3，如何让其相等" class="headerlink" title="7、为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等"></a>7、为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等</h2><p>在 JavaScript 中，数字采用 IEEE 754 双精度浮点数表示法，这种表示法无法精确地表示所有小数，特别是像 0.1 和 0.2 这样的数。在二进制表示中，0.1 和 0.2 都是无限循环的，因此它们只能被近似表示，导致在进行加法运算时出现微小的舍入误差。</p><p> <strong>Math.round</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Math</span>.round((<span class="hljs-number">0</span>.<span class="hljs-number">1</span>+<span class="hljs-number">0</span>.<span class="hljs-number">2</span>)*<span class="hljs-number">100</span>)/<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p><strong>toFixed</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Number</span>((<span class="hljs-number">0</span>.<span class="hljs-number">1</span>+<span class="hljs-number">0</span>.<span class="hljs-number">2</span>).toFixed(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><h2 id="8、如何使用安全的-undefined-值"><a href="#8、如何使用安全的-undefined-值" class="headerlink" title="8、如何使用安全的 undefined 值"></a>8、如何使用安全的 undefined 值</h2><p>在某些旧版 JavaScript 环境中，<code>undefined</code> 可能被意外地重写，为了确保得到真正的 <code>undefined</code> 值，有以下几种“安全”的方式：</p><p><strong>使用 <code>void</code> 运算符</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> safeUndefined = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(safeUndefined); <span class="hljs-comment">// 输出：undefined</span><br></code></pre></td></tr></table></figure><p><strong>利用 IIFE 的参数 立即执行函数表达式</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">(<span class="hljs-keyword">function</span> (<span class="hljs-params">undefined</span>) &#123;<br>  <span class="hljs-comment">// 在这个函数作用域中，变量 undefined 是一个局部变量</span><br>  <span class="hljs-comment">// 且没有被赋予任何值，所以它的值就是原始的 undefined</span><br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// 输出：undefined</span><br><br>  <span class="hljs-comment">// 这里就可以放心地使用 undefined，而不用担心全局 undefined 被修改</span><br>&#125;)();<br></code></pre></td></tr></table></figure><h2 id="9、typeof-NaN-的结果是什么？"><a href="#9、typeof-NaN-的结果是什么？" class="headerlink" title="9、typeof NaN 的结果是什么？"></a>9、typeof NaN 的结果是什么？</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span>(<span class="hljs-literal">NaN</span>)); <span class="hljs-comment">// number</span><br></code></pre></td></tr></table></figure><p>NaN 是一个特殊值，用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p><p>NaN 和自身不相等。因为如果两个计算都得到了 <code>NaN</code>，这并不意味着它们表示相同的错误或同样的情况。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-literal">NaN</span> === <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// false</span><br><span class="hljs-literal">NaN</span> !== <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="10、isNaN-和-Number-isNaN-函数的区别？"><a href="#10、isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="10、isNaN 和 Number.isNaN 函数的区别？"></a>10、isNaN 和 Number.isNaN 函数的区别？</h2><p>主要区别在于是否进行类型转换！</p><p><strong>全局 isNaN() 函数</strong>：会先将参数转换为数字，再判断是否为 <code>NaN</code>，因此可能导致一些非数字类型的数据也被误判为 <code>NaN</code>。</p><p><strong>ES6 的 Number.isNaN() 方法</strong>：不会进行类型转换，仅当值严格为 <code>NaN</code> 时才返回 <code>true</code>，因此更为精确和安全。</p><p>★推荐Number.isNaN 函数</p><h2 id="11、Number-其他值到数字值的转换规则？"><a href="#11、Number-其他值到数字值的转换规则？" class="headerlink" title="11、Number 其他值到数字值的转换规则？"></a>11、Number 其他值到数字值的转换规则？</h2><p><strong>undefined</strong> → <code>NaN</code></p><p><strong>null</strong> → <code>0</code></p><p><strong>boolean</strong>：<code>true</code> → <code>1</code>，<code>false</code> → <code>0</code></p><p><strong>字符串</strong>：合法数值字符串转换为对应数字，不合法的返回 <code>NaN</code>；空字符串返回 <code>0</code></p><p><strong>对象</strong>：先转换为原始值，再按照原始值的规则转换（通常返回 <code>NaN</code>，除非对象自定义了转换逻辑）</p><p><strong>Symbol</strong>：不能转换为数字，会抛出错误</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// NaN ★</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>)); <span class="hljs-comment">// 0 ★</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>)); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>)); <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;&quot;</span>)); <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;  &quot;</span>)); <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;123&quot;</span>)); <span class="hljs-comment">// 123</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;123.45  &quot;</span>)); <span class="hljs-comment">// 123.45 ★</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;123abc&quot;</span>)); <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(&#123;&#125;)); <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(&#123; <span class="hljs-attr">value</span>: <span class="hljs-number">123</span> &#125;)); <span class="hljs-comment">// NaN</span><br><span class="hljs-comment">// 自定义对象转换</span><br>const obj = &#123;<br>    valueOf() &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>    &#125;<br>  &#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(obj)); <span class="hljs-comment">// 42 ★</span><br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(Symbol(<span class="hljs-string">&quot;id&quot;</span>))); <span class="hljs-comment">// Uncaught TypeError ★</span><br></code></pre></td></tr></table></figure><h2 id="12、String-其他值到字符串的转换规则？"><a href="#12、String-其他值到字符串的转换规则？" class="headerlink" title="12、String 其他值到字符串的转换规则？"></a>12、String 其他值到字符串的转换规则？</h2><p><strong>undefined</strong> → <code>&quot;undefined&quot;</code></p><p><strong>null</strong> → <code>&quot;null&quot;</code></p><p><strong>Boolean</strong>：<code>true</code> → <code>&quot;true&quot;</code>；<code>false</code> → <code>&quot;false&quot;</code></p><p><strong>Number</strong>：转换为其对应的数字字符（特殊数字如 <code>NaN</code>、<code>Infinity</code> 有专门的字符串表示）</p><p><strong>String</strong>：本身不变</p><p><strong>Object</strong>：调用对象的 <code>toString()</code>（或内部 ToPrimitive 算法）转换为字符串，默认普通对象为 <code>&quot;[object Object]&quot;</code>，数组和函数有各自的表现形式</p><p><strong>Symbol</strong>：必须显式转换（<code>String(symbol)</code> 或 <code>symbol.toString()</code>），否则隐式转换会报错</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stata">console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(undefined)); <span class="hljs-comment">// &quot;undefined&quot;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(null)); <span class="hljs-comment">// &quot;null&quot;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(true)); <span class="hljs-comment">// &quot;true&quot;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(false)); <span class="hljs-comment">// &quot;false&quot;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(123));<span class="hljs-comment">// &quot;123&quot;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(0));<span class="hljs-comment">// &quot;0&quot;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(-45)); <span class="hljs-comment">// &quot;-45&quot;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(NaN));<span class="hljs-comment">// &quot;NaN&quot;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(Infinity));<span class="hljs-comment">// &quot;Infinity&quot;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(-Infinity));<span class="hljs-comment">// &quot;-Infinity&quot;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(&#123;&#125;));<span class="hljs-comment">// &quot;[object Object]&quot; ★</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>([1,2,3])); <span class="hljs-comment">// &quot;1,2,3&quot;  ★</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(function()&#123;&#125;));<span class="hljs-comment">// &quot;function()&#123;&#125;&quot; ★</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(Symbol(<span class="hljs-string">&quot;id&quot;</span>)));<span class="hljs-comment">// &quot;Symbol(id)&quot; ★</span><br></code></pre></td></tr></table></figure><h2 id="13、Boolean-其他值到布尔类型的值的转换规则？"><a href="#13、Boolean-其他值到布尔类型的值的转换规则？" class="headerlink" title="13、Boolean 其他值到布尔类型的值的转换规则？"></a>13、Boolean 其他值到布尔类型的值的转换规则？</h2><p><strong>Falsy 值</strong>：<code>undefined</code>、<code>null</code>、<code>false</code>、<code>+0</code>、<code>-0</code>、<code>NaN</code> 和 <code>&quot;&quot;</code> 转换为 <code>false</code>。</p><p><strong>Truthy 值</strong>：除了上述 falsy 值之外，所有其他值转换为 <code>true</code>。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">console.log(<span class="hljs-type">Boolean</span>(undefined)); // <span class="hljs-keyword">false</span><br>console.log(<span class="hljs-type">Boolean</span>(<span class="hljs-keyword">null</span>));// <span class="hljs-keyword">false</span><br>console.log(<span class="hljs-type">Boolean</span>(<span class="hljs-number">0</span>));// <span class="hljs-keyword">false</span> ★<br>console.log(<span class="hljs-type">Boolean</span>(<span class="hljs-number">-0</span>));// <span class="hljs-keyword">false</span><br>console.log(<span class="hljs-type">Boolean</span>(<span class="hljs-keyword">NaN</span>));// <span class="hljs-keyword">false</span><br>console.log(<span class="hljs-type">Boolean</span>(&quot;&quot;));// <span class="hljs-keyword">false</span>  ★<br>console.log(<span class="hljs-type">Boolean</span>(&quot;0&quot;));// <span class="hljs-keyword">true</span> ★<br>console.log(<span class="hljs-type">Boolean</span>(&quot;hello&quot;));// <span class="hljs-keyword">true</span><br>console.log(<span class="hljs-type">Boolean</span>(&quot;&#123;&#125;&quot;));// <span class="hljs-keyword">true</span> ★<br>console.log(<span class="hljs-type">Boolean</span>(&quot;[]&quot;));// <span class="hljs-keyword">true</span> ★<br>console.log(<span class="hljs-type">Boolean</span>(&quot;function()&#123;&#125;&quot;));// <span class="hljs-keyword">true</span> ★<br>console.log(<span class="hljs-type">Boolean</span>(&quot;Symbol(&#x27;id&#x27;)&quot;));// <span class="hljs-keyword">true</span> <br></code></pre></td></tr></table></figure><h2 id="14、-和-操作符的返回值"><a href="#14、-和-操作符的返回值" class="headerlink" title="14、 || 和 &amp;&amp; 操作符的返回值"></a>14、 || 和 &amp;&amp; 操作符的返回值</h2><p><strong>逻辑或（<code>||</code>）</strong></p><ul><li><strong>返回规则</strong>：<br>对于表达式 <code>a || b</code>，如果 <code>a</code> 是 truthy（真值），则直接返回 <code>a</code>；否则返回 <code>b</code>。</li><li><strong>工作过程</strong>：<ol><li>先计算 <code>a</code>。</li><li>如果 <code>a</code> 为 truthy，则整个表达式的值为 <code>a</code>（并且不再计算 <code>b</code>）。</li><li>如果 <code>a</code> 为 falsy，则计算 <code>b</code>，并返回 <code>b</code> 的值。</li></ol></li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Hello&quot;</span> || <span class="hljs-string">&quot;World&quot;</span>); <span class="hljs-comment">// 返回 &quot;Hello&quot;，因为 &quot;Hello&quot; 为 truthy</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;&quot;</span> || <span class="hljs-string">&quot;World&quot;</span>);      <span class="hljs-comment">// 返回 &quot;World&quot;，因为 &quot;&quot; 为 falsy</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">0</span> || <span class="hljs-number">42</span>);            <span class="hljs-comment">// 返回 42，因为 0 为 falsy</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-literal">null</span> || <span class="hljs-literal">undefined</span>);  <span class="hljs-comment">// 返回 undefined，因为 null 和 undefined 都为 falsy，返回最后一个操作数</span><br></code></pre></td></tr></table></figure><p><strong>逻辑与（<code>&amp;&amp;</code>）</strong></p><ul><li><strong>返回规则</strong>：<br>对于表达式 <code>a &amp;&amp; b</code>，如果 <code>a</code> 是 falsy（假值），则直接返回 <code>a</code>；否则返回 <code>b</code>。</li><li><strong>工作过程</strong>：<ol><li>先计算 <code>a</code>。</li><li>如果 <code>a</code> 为 falsy，则整个表达式的值为 <code>a</code>（并且不再计算 <code>b</code>）。</li><li>如果 <code>a</code> 为 truthy，则计算 <code>b</code>，并返回 <code>b</code> 的值。</li></ol></li></ul><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">console.<span class="hljs-meta">log</span>(<span class="hljs-string">&quot;Hello&quot;</span> <span class="hljs-variable">&amp;&amp;</span> <span class="hljs-string">&quot;World&quot;</span>); // 返回 <span class="hljs-string">&quot;World&quot;</span>，因为 <span class="hljs-string">&quot;Hello&quot;</span> 为 truthy，所以返回第二个操作数<br>console.<span class="hljs-meta">log</span>(<span class="hljs-string">&quot;&quot;</span> <span class="hljs-variable">&amp;&amp;</span> <span class="hljs-string">&quot;World&quot;</span>);      // 返回 <span class="hljs-string">&quot;&quot;</span>，因为 <span class="hljs-string">&quot;&quot;</span> 为 falsy，直接返回第一个操作数<br>console.<span class="hljs-meta">log</span>(42 <span class="hljs-variable">&amp;&amp;</span> 0);            // 返回 0，因为 42 为 truthy，但 0 为 falsy<br>console.<span class="hljs-meta">log</span>(<span class="hljs-keyword">null</span> <span class="hljs-variable">&amp;&amp;</span> <span class="hljs-string">&quot;Test&quot;</span>);     // 返回 <span class="hljs-keyword">null</span>，因为 <span class="hljs-keyword">null</span> 为 falsy<br></code></pre></td></tr></table></figure><p><strong>这种行为使得逻辑运算符不仅可以用于条件判断，还可以用来设置默认值或进行短路求值。</strong></p><blockquote><p>1、设置默认值</p><p>利用 <code>||</code> 的短路特性，可以在一个表达式中为变量指定默认值。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">let <span class="hljs-keyword">user</span>Name = <span class="hljs-string">&quot;&quot;</span>;<br>// 如果 <span class="hljs-keyword">user</span>Name 为 falsy（例如空字符串），则使用 <span class="hljs-string">&quot;defaultName&quot;</span> 作为默认值<br>let name = <span class="hljs-keyword">user</span>Name || <span class="hljs-string">&quot;defaultName&quot;</span>;<br>console.<span class="hljs-keyword">log</span>(name); // 输出 <span class="hljs-string">&quot;defaultName&quot;</span><br></code></pre></td></tr></table></figure><p>2、短路求值</p><p>利用 <code>&amp;&amp;</code> 的短路特性，可以控制在某个条件为真时才继续执行某些操作。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> isLoggedIn = <span class="hljs-literal">true</span>;<br>// 如果 isLoggedIn 为 <span class="hljs-literal">true</span>，则继续执行后面的操作，否则直接返回 <span class="hljs-literal">false</span><br>isLoggedIn &amp;&amp; console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;User is logged in&quot;</span>);<br></code></pre></td></tr></table></figure></blockquote><h2 id="15、-Object-is-与比较操作符-、-的区别？"><a href="#15、-Object-is-与比较操作符-、-的区别？" class="headerlink" title="15、 Object.is() 与比较操作符===、==的区别？"></a>15、 Object.is() 与比较操作符<code>===</code>、<code>==</code>的区别？</h2><p><strong><code>==</code>（宽松相等）</strong>：在比较前会进行类型转换（隐式转换）。</p><p><strong><code>===</code>（严格相等）</strong>：比较时要求两边的值类型必须相同，且值也必须相等。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">**特殊情况**：<br>- `NaN === NaN` 返回 `false`。<br>- `+<span class="hljs-number">0</span> === -<span class="hljs-number">0</span>` 返回 `true`。<br></code></pre></td></tr></table></figure><p> **<code>Object.is()</code>**：<code>Object.is()</code> 基本上与 <code>===</code> 类似，但处理特殊值时有不同的行为。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Object.is(<span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-literal">NaN</span> === <span class="hljs-literal">NaN</span>);         <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Object.is(+<span class="hljs-number">0</span>, <span class="hljs-number">-0</span>));   <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(+<span class="hljs-number">0</span> === <span class="hljs-number">-0</span>);           <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="16、什么是-JavaScript-中的包装类型"><a href="#16、什么是-JavaScript-中的包装类型" class="headerlink" title="16、什么是 JavaScript 中的包装类型"></a>16、什么是 JavaScript 中的包装类型</h2><p>包装类型：原始数据类型对应的对象形式！</p><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs openscad"><span class="hljs-built_in">let</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span>.toUpperCase()); <span class="hljs-comment">// &quot;HELLO&quot;</span><br></code></pre></td></tr></table></figure><p>当对原始值调用属性或方法时，JavaScript 会在后台临时创建一个对应的对象包装器（例如 <code>String</code>、<code>Number</code>、<code>Boolean</code> 对象），使得能够访问原始值的方法。</p><p><strong>包装类型的工作原理</strong></p><p>当试图访问原始值的属性或方法时，JavaScript 会进行以下操作：</p><ol><li>根据原始值的类型（例如字符串）创建对应的包装对象（例如 <code>new String(&quot;hello&quot;)</code>）。</li><li>在这个包装对象上查找所请求的方法或属性（例如 <code>toUpperCase</code>）。</li><li>调用方法或访问属性，然后丢弃这个包装对象。</li></ol><p><strong>包装类型的特点</strong></p><ul><li><p>临时性</p></li><li><p>类型差异性</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 当没有访问方法或属性时，str 依然是一个原始字符串</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> str);        <span class="hljs-comment">// &quot;string&quot;</span><br></code></pre></td></tr></table></figure></li></ul><p>可以使用<code>valueOf</code>方法将包装类型倒转成基本类型：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-keyword">var</span> b = Object(a)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b); <span class="hljs-comment">// String &#123;&#x27;abc&#x27;&#125;</span><br><span class="hljs-keyword">var</span> c = b.valueOf() <span class="hljs-comment">// &#x27;abc&#x27;</span><br></code></pre></td></tr></table></figure><p>试试打印这个：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>( <span class="hljs-literal">false</span> );<br><span class="hljs-keyword">if</span> (!a) &#123;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( <span class="hljs-string">&quot;Oops&quot;</span> ); <span class="hljs-comment">// never runs</span><br>&#125;<br></code></pre></td></tr></table></figure><p>什么都不会打印，因为包装类型是对象。</p><h2 id="17、JavaScript-中如何进行隐式类型转换？"><a href="#17、JavaScript-中如何进行隐式类型转换？" class="headerlink" title="17、JavaScript 中如何进行隐式类型转换？"></a>17、JavaScript 中如何进行隐式类型转换？</h2><p>隐式类型转换：不显示调用转换函数，JS引擎自动将一种数据类型转换为另一种数据类型。</p><p> <strong>算术运算符中的隐式转换</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;5&quot;</span> - <span class="hljs-number">2</span>;      <span class="hljs-regexp">//</span> 数字: <span class="hljs-number">3</span>，字符串 <span class="hljs-string">&quot;5&quot;</span> 被转换为数字 <span class="hljs-number">5</span><br><span class="hljs-string">&quot;10&quot;</span> * <span class="hljs-string">&quot;2&quot;</span>;   <span class="hljs-regexp">//</span> 数字: <span class="hljs-number">20</span>，两个字符串都被转换为数字<br><span class="hljs-string">&quot;10&quot;</span> <span class="hljs-regexp">/ 2;     /</span>/ 数字: <span class="hljs-number">5</span><br><span class="hljs-string">&quot;abc&quot;</span> - <span class="hljs-number">2</span>;    <span class="hljs-regexp">//</span> NaN，因为 <span class="hljs-string">&quot;abc&quot;</span> 不能转换为数字<br><br><span class="hljs-regexp">//</span> 加号运算符 `+` 的特殊情况<br><span class="hljs-string">&quot;5&quot;</span> + <span class="hljs-number">2</span>;      <span class="hljs-regexp">//</span> 字符串: <span class="hljs-string">&quot;52&quot;</span><br><span class="hljs-number">2</span> + <span class="hljs-string">&quot;3&quot;</span>;      <span class="hljs-regexp">//</span> 字符串: <span class="hljs-string">&quot;23&quot;</span><br><span class="hljs-number">2</span> + <span class="hljs-number">3</span>;        <span class="hljs-regexp">//</span> 数字: <span class="hljs-number">5</span>（两个都是数字，不发生字符串转换）<br></code></pre></td></tr></table></figure><p><strong>比较运算符中的隐式转换</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">1</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-comment">;         // true，因为 &quot;1&quot; 转换为数字 1</span><br><span class="hljs-attribute">true</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;        // true，true 被转换为数字 1</span><br><span class="hljs-attribute">false</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;       // true，false 被转换为数字 0</span><br><span class="hljs-attribute">null</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> undefined<span class="hljs-comment">;// true（这是个特殊情况）</span><br><br>// 严格模式，不进行隐式转换：<br><span class="hljs-number">1</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-comment">;        // false</span><br><span class="hljs-attribute">true</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;       // false</span><br></code></pre></td></tr></table></figure><p><strong>布尔上下文中的隐式转换</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 转换为false:</span><br><span class="hljs-literal">undefined</span><br><span class="hljs-literal">null</span><br><span class="hljs-literal">false</span><br>+<span class="hljs-number">0</span>、<span class="hljs-number">-0</span><br><span class="hljs-literal">NaN</span><br><span class="hljs-string">&quot;&quot;</span>（空字符串）<br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span> 其他都转换为<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>对象转换为原始类型</strong></p><p>当对象参与运算或比较时，内部会先调用 <strong>ToPrimitive</strong> 抽象操作，通常会先调用对象的 <code>valueOf()</code> 方法，如果返回的是原始值，则使用该值；否则再调用 <code>toString()</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-title function_">valueOf</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>  &#125;,<br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj + <span class="hljs-number">2</span>); <span class="hljs-comment">// 44，因为 obj 转换为数字 42，再加上 2</span><br></code></pre></td></tr></table></figure><h2 id="18、-操作符什么时候用于字符串的拼接？"><a href="#18、-操作符什么时候用于字符串的拼接？" class="headerlink" title="18、+ 操作符什么时候用于字符串的拼接？"></a>18、+ 操作符什么时候用于字符串的拼接？</h2><p><strong>字符串拼接</strong>：当至少有一个操作数是字符串或隐式转换为字符串时，<code>+</code> 执行字符串拼接。</p><p><strong>对象的情况</strong>：当操作数是对象时，会先通过内部的 ToPrimitive 操作（通常先调用 <code>valueOf()</code>，再调用 <code>toString()</code>）转换为原始值。如果转换结果为字符串，则触发字符串拼接；如果转换结果为数字，则进行加法运算。</p><p><strong>？</strong> 隐式转换为字符串的情况有</p><blockquote><p>1、当 <code>+</code> 运算符的一侧是字符串时，另一侧的操作数会自动转换为字符串；</p><p>2、在模板字符串中，通过 <code>$&#123;&#125;</code> 嵌入的表达式会自动调用 <code>String()</code> 转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">let</span> message = <span class="hljs-string">`Age: <span class="hljs-subst">$&#123;age&#125;</span>`</span>; <span class="hljs-comment">// 结果为 &quot;Age: 30&quot;</span><br></code></pre></td></tr></table></figure><p>3、对象在字符串上下文中</p><p>当对象出现在需要字符串的地方（例如在字符串连接、打印输出、或作为对象的属性名时），JavaScript 会自动调用对象的 <code>toString()</code> 方法（或者在某些情况下调用 <code>valueOf()</code> 后再转换为字符串）：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;User: &quot;</span> + obj); <span class="hljs-comment">// 结果通常为 &quot;User: [object Object]&quot;</span><br><span class="hljs-comment">// 如果重写了 toString() 方法</span><br>obj.toString = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> this.name; &#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;User: &quot;</span> + obj); <span class="hljs-comment">// 结果为 &quot;User: Alice&quot;</span><br></code></pre></td></tr></table></figure><p>4、其他需要字符串的上下文</p><p>某些 API 或操作要求传入字符串参数时，如果传入的值不是字符串，JavaScript 也会自动进行转换：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 例如在 DOM 操作中传入非字符串参数时：<br>document.getElementById(<span class="hljs-number">123</span>); <span class="hljs-regexp">//</span> <span class="hljs-number">123</span> 会被转换为 <span class="hljs-string">&quot;123&quot;</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="19、object-assign和扩展运算符是深拷贝还是浅拷贝"><a href="#19、object-assign和扩展运算符是深拷贝还是浅拷贝" class="headerlink" title="19、object.assign和扩展运算符是深拷贝还是浅拷贝"></a>19、object.assign和扩展运算符是深拷贝还是浅拷贝</h2><p>都是浅拷贝。</p><p><strong>浅拷贝</strong>：只复制对象的第一层属性。如果属性值是原始值（如字符串、数字、布尔值），则直接复制；如果属性值是引用类型（如对象、数组等），则只复制引用地址，拷贝后的对象和原对象共享同一个引用的子对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> original = &#123; <br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <br>  <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> &#125; <br>&#125;;<br><br><span class="hljs-comment">// 使用 Object.assign 进行浅拷贝</span><br><span class="hljs-keyword">const</span> copy1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, original);<br><br><span class="hljs-comment">// 使用扩展运算符进行浅拷贝</span><br><span class="hljs-keyword">const</span> copy2 = &#123; ...original &#125;;<br><br><span class="hljs-comment">// 修改嵌套对象的属性</span><br>copy1.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">42</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(original.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>); <span class="hljs-comment">// 输出 42，说明 original 和 copy1 的 b 属性指向同一个对象</span><br></code></pre></td></tr></table></figure><p><strong>？</strong> 如何进行深拷贝</p><ul><li><strong>深拷贝</strong>：会递归复制所有嵌套对象，确保新对象与原对象完全独立。</li><li>实现方法包括：<ul><li>使用 <code>JSON.parse(JSON.stringify(obj))</code>（注意这种方式有局限性，如无法处理函数、undefined、Symbol、循环引用等）</li><li>使用递归手写深拷贝函数</li><li>使用第三方库，比如 Lodash 的 <code>_.cloneDeep()</code></li></ul></li></ul><h2 id="20、如何判断一个对象是空对象"><a href="#20、如何判断一个对象是空对象" class="headerlink" title="20、如何判断一个对象是空对象"></a>20、如何判断一个对象是空对象</h2><p><strong>使用 <code>Object.keys()</code></strong></p><p>返回一个包含对象自身可枚举属性名称的数组。但不会遍历原型链属性。</p><p>如果数组长度为 0，则说明对象为空。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">isEmptyObject</span>(obj) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">Object.keys(obj).length</span> === <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用 <code>for...in</code> 循环结合 <code>hasOwnProperty</code></strong></p><p>使用 <code>for...in</code> 循环遍历对象所有可枚举属性，并结合 <code>hasOwnProperty</code> 过滤掉原型链上的属性。如果循环体内没有执行任何操作，则说明对象为空。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">function</span> isEmptyObject(obj) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span><span class="hljs-built_in"> key</span> <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (obj.hasOwnProperty<span class="hljs-built_in">(key</span>)) &#123;<br>      <span class="hljs-keyword">return</span><span class="hljs-built_in"> false</span>; // 如果有任意自有属性，返回<span class="hljs-built_in"> false</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span><span class="hljs-built_in"> true</span>; // 没有自有属性，返回<span class="hljs-built_in"> true</span><br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>使用 JSON 序列化</strong></p><p>将对象序列化成 JSON 字符串，如果结果是 <code>&quot;&#123;&#125;&quot;</code>，则说明对象为空。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">isEmptyObject</span>(obj) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">JSON.stringify(obj)</span> === &#x27;&#123;&#125;&#x27;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原始数据类型</tag>
      
      <tag>引用数据类型</tag>
      
      <tag>数据类型检测</tag>
      
      <tag>判断数组的方式</tag>
      
      <tag>null和undefined的区别</tag>
      
      <tag>isNaN 和 Number.isNaN 的区别</tag>
      
      <tag>类型转换规则</tag>
      
      <tag>与或操作符</tag>
      
      <tag>包装类型</tag>
      
      <tag>深拷贝和浅拷贝</tag>
      
      <tag>如何判断一个对象是空对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript中的数据类型</title>
    <link href="/2025/02/15/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2025/02/15/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript中的数据类型"><a href="#JavaScript中的数据类型" class="headerlink" title="JavaScript中的数据类型"></a>JavaScript中的数据类型</h1><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502151716006.png" alt="image-20250215171444153"></p><p>原始数据类型：String、Number、Boolean、Null、Undefiend、Symbol、BigInt</p><p>引用数据类型：Array、Function、Object、RegExp、Date</p><ul><li><p><strong>原始数据类型</strong></p><p>原始数据类型的值是不可变的，一旦创建就不能直接修改其内容。当对原始类型的变量进行赋值或者传递时，是按值传递，会复制一份独立的数据。</p><ul><li><p><strong>String：</strong>具有不可变性，对字符串进行操作时，实际返回的是新的字符串。例如，对字符串调用<code>.toUpperCase()</code>不会改变原字符串，而是返回一个新的字符串。</p><p>内置方法：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs stata">testString = <span class="hljs-string">&quot;Hello World&quot;</span><br><span class="hljs-comment">// 返回指定索引的字符串</span><br>console.<span class="hljs-built_in">log</span>(testString.charAt(4)); <span class="hljs-comment">// o</span><br><span class="hljs-comment">// 返回指定索引处字符的 Unicode 编码值</span><br>console.<span class="hljs-built_in">log</span>(testString.charCodeAt(4)); <span class="hljs-comment">// 111</span><br><span class="hljs-comment">// 将多个字符串拼接到当前字符串的末尾</span><br>console.<span class="hljs-built_in">log</span>(testString.concat(<span class="hljs-string">&quot; 111&quot;</span>,<span class="hljs-string">&quot;www&quot;</span>)); <span class="hljs-comment">// Hello World 111www</span><br><span class="hljs-comment">// 提取字符串的一部分，返回一个新字符串</span><br>console.<span class="hljs-built_in">log</span>(testString.slice(1,2)); <span class="hljs-comment">// e</span><br><span class="hljs-comment">// 提取字符串的一部分，与 slice 类似，但不接受负值</span><br>console.<span class="hljs-built_in">log</span>(testString.substring(1,2)); <span class="hljs-comment">// e</span><br><span class="hljs-comment">// 根据分隔符将字符串拆分为数组</span><br>console.<span class="hljs-built_in">log</span>(testString.<span class="hljs-keyword">split</span>(<span class="hljs-string">&quot;&quot;</span>));<span class="hljs-comment">// [&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;W&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;]</span><br><span class="hljs-comment">// 将字符串转换为大写</span><br>console.<span class="hljs-built_in">log</span>(testString.toUpperCase()); <span class="hljs-comment">// HELLO WORLD</span><br><span class="hljs-comment">// 将字符串转换为小写</span><br>console.<span class="hljs-built_in">log</span>(testString.toLowerCase()); <span class="hljs-comment">// hello world</span><br><span class="hljs-comment">// indexOf(searchValue, fromIndex) 返回指定值首次出现的索引，未找到时返回 -1</span><br>console.<span class="hljs-built_in">log</span>(testString.indexOf(<span class="hljs-string">&quot;o&quot;</span>)); <span class="hljs-comment">// 4</span><br><span class="hljs-comment">// lastIndexOf(searchValue, fromIndex)：返回指定值最后一次出现的索引，未找到时返回 -1</span><br>console.<span class="hljs-built_in">log</span>(testString.lastIndexOf(<span class="hljs-string">&quot;l&quot;</span>)); <span class="hljs-comment">//9 </span><br><span class="hljs-comment">// 检查字符串是否包含指定值</span><br>console.<span class="hljs-built_in">log</span>(testString.includes(<span class="hljs-string">&quot;o&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 检查字符串是否以指定值开头</span><br>console.<span class="hljs-built_in">log</span>(testString.startsWith(<span class="hljs-string">&quot;H&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 检查字符串是否以指定值结尾</span><br>console.<span class="hljs-built_in">log</span>(testString.endsWith(<span class="hljs-string">&quot;d&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// replace(searchValue, replaceValue)：替换字符串中的第一个指定值</span><br>console.<span class="hljs-built_in">log</span>(testString.<span class="hljs-keyword">replace</span>(<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>)); <span class="hljs-comment">// HeXlo World</span><br><span class="hljs-comment">// 替换字符串中所有匹配的值</span><br>console.<span class="hljs-built_in">log</span>(testString.replaceAll(<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;X&quot;</span>)); <span class="hljs-comment">// HeXXo WorXd</span><br><span class="hljs-comment">// 移除字符串两端的空白字符 (另有trimStart()、trimEnd())</span><br>console.<span class="hljs-built_in">log</span>(testString.<span class="hljs-built_in">trim</span>()); <span class="hljs-comment">// Hello World</span><br><span class="hljs-comment">// 返回字符串的长度</span><br>console.<span class="hljs-built_in">log</span>(testString.length); <span class="hljs-comment">// 11</span><br><span class="hljs-comment">// 返回字符串本身</span><br>console.<span class="hljs-built_in">log</span>(testString.<span class="hljs-keyword">toString</span>()); <span class="hljs-comment">// Hello World</span><br></code></pre></td></tr></table></figure></li><li><p><strong>Number：</strong>用于表示整数和浮点数，所有数字在 JavaScript 中均为 IEEE 754 双精度浮点数。</p><p>特殊值：<code>NaN</code>表示Not a Number，常出现在非法数学运算中。<code>Infinity</code> 和<code>-Infinity</code>表示无穷大无穷小。</p></li><li><p><strong>Boolean：</strong> 只有两个值，<code>true</code>和<code>false</code>，通常用于逻辑判断和条件控制。</p></li><li><p><strong>Undefined：</strong> 表示变量已声明但未赋值的状态，或者函数没有显式返回值，返回的也是undefined。</p></li><li><p><strong>Null：</strong> 表示无值或者空的状态，是特殊的原始值。</p><p>注意：<code>typeof null</code> 返回 <code>&quot;object&quot;</code>，这是 JavaScript 语言设计中的一个历史遗留问题。</p></li><li><p><strong>Symbol：</strong> ES6引入的新数据类型，用于生成独一无二的标识符，常用于对象属性的键，避免命名冲突。</p><p>每个Symbol值都是唯一且不可变的，不能自动转换为字符串，但是可以显式转换、通过<code>description</code>属性获取描述信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sym1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;an&quot;</span>)<br><span class="hljs-keyword">const</span> sym2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;an&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sym1===sym2); <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">const</span> obj = &#123;<br>    [sym1]: <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[sym1]); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li><li><p><strong>BigInt：</strong>表示任意精度的整数，解决了 Number 类型在表示大整数时精度丢失的问题。</p><p>可以表示超出 <code>Number.MAX_SAFE_INTEGER</code>（即 2^53 - 1）的整数。</p><p>使用 <code>n</code> 后缀或 <code>BigInt()</code> 构造函数来创建 BigInt 类型的数值。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const big1 <span class="hljs-operator">=</span> <span class="hljs-number">2423526443272357524</span>n<br>const big2 <span class="hljs-operator">=</span> BigInt(<span class="hljs-string">&quot;2423526443272357524&quot;</span>)<br>console.log(big1<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>big2)<span class="hljs-comment">; // true</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>引用数据类型</strong></p><ul><li><p><strong>普通对象 Object：</strong>最基本的数据结构，用键值对的形式存储数据。</p><p>键（属性名）通常为字符串、Symbol。</p><p>属性可以动态添加、修改、删除。</p><p>属性可以通过点语法或者中括号访问。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xl">const person = &#123;<br>    <span class="hljs-keyword">name</span>: <span class="hljs-string">&quot;anan&quot;</span>,<br>    age: <span class="hljs-number">18</span><br>&#125;<br>console.<span class="hljs-built_in">log</span>(person.<span class="hljs-keyword">name</span>); <span class="hljs-comment">// anan</span><br></code></pre></td></tr></table></figure></li><li><p><strong>数组 Array：</strong> 用于存储有序的数据集合。</p><p>内置方法：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-comment">// ==============  遍历  ==============</span><br><span class="hljs-comment">// 遍历数组  forEach</span><br>arr.forEach(<span class="hljs-function">(<span class="hljs-params">item,index</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(item,index);<br>&#125;)<br><span class="hljs-comment">// 遍历数组  for...of</span><br><span class="hljs-keyword">for</span> (let item of arr)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(item);<br>&#125;<br><span class="hljs-comment">// 遍历数组的索引  for...in </span><br><span class="hljs-keyword">for</span> (let index in arr)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr[index]);<br>&#125;<br><br><span class="hljs-comment">// ==============  增删改  ==============</span><br><span class="hljs-comment">// 数组末尾添加一个或多个元素,返回新数组的长度</span><br>arr.<span class="hljs-built_in">push</span>(<span class="hljs-number">4</span>) <br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr); <span class="hljs-comment">// [1, 2, 3, 4]</span><br><span class="hljs-comment">// 数组末尾移除一个元素，返回被移除的元素</span><br>arr.<span class="hljs-built_in">pop</span>()<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr); <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-comment">// 数组开头移除一个元素，返回被移除的元素</span><br>arr.shift()<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr); <span class="hljs-comment">// [2, 3]</span><br><span class="hljs-comment">// 数组开头添加一个或多个元素，返回新数组的长度</span><br>arr.unshift(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr); <span class="hljs-comment">// [1,2, 3]</span><br><span class="hljs-comment">// 从指定位置开始删除或添加元素</span><br><span class="hljs-comment">// array.splice(start[, deleteCount[, item1[, item2[, ...]]]])</span><br><span class="hljs-comment">// 移除元素：移除从索引1开始的两个元素</span><br>arr.<span class="hljs-built_in">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr); <span class="hljs-comment">// [1]</span><br><span class="hljs-comment">// 添加元素：在索引1处添加一个元素2</span><br>arr.<span class="hljs-built_in">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr); <span class="hljs-comment">// [1, 2]</span><br><span class="hljs-comment">// 替换元素：从索引1开始移除一个元素并插入7</span><br>arr.<span class="hljs-built_in">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr); <span class="hljs-comment">// [1, 7]</span><br><span class="hljs-comment">// 使用负数作为 start 参数：</span><br>arr.<span class="hljs-built_in">splice</span>(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr); <span class="hljs-comment">// [1, 2, 3]</span><br><br><span class="hljs-comment">// ==============  查找和搜索  ==============</span><br><span class="hljs-comment">// indexOf(searchElement, fromIndex) </span><br><span class="hljs-comment">// 返回指定元素首次出现的索引，未找到时返回 -1</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr.<span class="hljs-built_in">indexOf</span>(<span class="hljs-number">2</span>) ); <span class="hljs-comment">// 1</span><br><span class="hljs-comment">// lastIndexOf(searchElement, fromIndex)</span><br><span class="hljs-comment">// 返回指定元素最后一次出现的索引，未找到时返回 -1</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr.lastIndexOf(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 1</span><br><span class="hljs-comment">// find(callback)</span><br><span class="hljs-comment">// 返回数组中第一个满足条件的元素，未找到时返回 undefined</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr.<span class="hljs-built_in">find</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item===<span class="hljs-number">2</span>)); <span class="hljs-comment">// 2</span><br><span class="hljs-comment">// findIndex(callback)</span><br><span class="hljs-comment">// 返回数组中第一个满足条件的元素的索引，未找到时返回 -1</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr.findIndex(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item===<span class="hljs-number">4</span>)); <span class="hljs-comment">// -1</span><br><span class="hljs-comment">// includes(value)</span><br><span class="hljs-comment">// 检查数组是否包含指定值，返回布尔值。</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr.<span class="hljs-built_in">includes</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// ==============  转换和映射  ==============</span><br><span class="hljs-comment">// map(callback)</span><br><span class="hljs-comment">// 对数组的每个元素执行回调函数，返回一个新数组，包含每次回调的结果。</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr.<span class="hljs-built_in">map</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item+<span class="hljs-number">1</span>)); <span class="hljs-comment">// [2, 3, 4]</span><br><span class="hljs-comment">// 返回一个新数组，包含所有满足条件的元素。</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr.<span class="hljs-built_in">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item===<span class="hljs-number">2</span>)); <span class="hljs-comment">//[2]</span><br><span class="hljs-comment">// 对数组的每个元素执行回调函数，将结果累积为一个值。另有reduceRight，从右累积</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr.<span class="hljs-built_in">reduce</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">sum</span>,cur</span>)=&gt;</span><span class="hljs-built_in">sum</span>+cur,<span class="hljs-number">0</span>)); <span class="hljs-comment">// 6</span><br><span class="hljs-comment">// 返回数组的一个浅拷贝，包含从 start 到 end（不包括 end）的元素。</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr.<span class="hljs-built_in">slice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)); <span class="hljs-comment">// [2]</span><br><span class="hljs-comment">// 合并多个数组，返回一个新数组</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr.concat([<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br><br><span class="hljs-comment">// ==============  数组排序  ============== </span><br><span class="hljs-comment">// sort(compareFunction)</span><br>const newArr = [<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]<br><span class="hljs-comment">// 默认按字符串顺序排序，可以通过传入比较函数实现自定义排序。</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(newArr.<span class="hljs-built_in">sort</span>()); <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br>let a1 = newArr.<span class="hljs-built_in">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>a-b); <span class="hljs-comment">// 升序排序，返回 [1, 2, 3]</span><br>let a2 = newArr.<span class="hljs-built_in">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>b-a); <span class="hljs-comment">// 降序排序，返回 [5, 4, 3, 2, 1]</span><br><span class="hljs-comment">// 直接修改原数组</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;地址一致吗？&#x27;</span>,a1 === a2); <span class="hljs-comment">// 地址一致吗？ true</span><br><br><span class="hljs-comment">// ==============  数组检查和验证  ==============</span><br><span class="hljs-comment">// every(callback) 检查数组中的每个元素是否都满足条件，返回布尔值。</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(newArr.every(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item&gt;<span class="hljs-number">0</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// some(callback) 检查数组中是否有至少一个元素满足条件，返回布尔值</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(newArr.some(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>item&gt;<span class="hljs-number">0</span>)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// ==============  数组的解构和拷贝  ==============</span><br><span class="hljs-comment">// Array.from(arrayLike) 将类数组对象（如字符串、NodeList 等）转换为数组。</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Array</span>.from(<span class="hljs-string">&#x27;hello&#x27;</span>)); <span class="hljs-comment">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br><span class="hljs-comment">// Array.isArray(value) 检查一个值是否为数组，返回布尔值</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Array</span>.isArray(<span class="hljs-string">&#x27;hello&#x27;</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li><li><p><strong>函数 Function：</strong>本质上也是对象，可以存储代码块并在需要时执行。</p><p>可以赋值给变量、作为参数传递给其他函数、甚至从函数中返回。</p><p>具有属性和方法（例如 <code>.call()</code>、<code>.apply()</code>）。</p><p>支持闭包，即内部函数可以访问外部函数的变量。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`Hello World,<span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br>&#125;<br>greet(<span class="hljs-string">&quot;anan&quot;</span>) <span class="hljs-comment">// Hello World,anan</span><br></code></pre></td></tr></table></figure></li><li><p><strong>日期对象 Date</strong></p><p>可以获取当前时间、进行时间计算、格式化日期等操作。</p><p>通过 <code>new Date()</code> 创建实例，并提供多种格式的构造方法。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// ============= 日期对象创建 ===============</span><br><span class="hljs-comment">// 创建当前日期和时间</span><br>const <span class="hljs-built_in">now</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">now</span>); <span class="hljs-comment">// Sat Feb 15 2025 16:13:03 GMT+0800 (中国标准时间)</span><br><span class="hljs-comment">// 创建特定日期和时间 月份从0开始!!!</span><br>const spe_date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2025</span>,<span class="hljs-number">1</span>,<span class="hljs-number">25</span>,<span class="hljs-number">10</span>,<span class="hljs-number">35</span>,<span class="hljs-number">24</span>)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(spe_date);<span class="hljs-comment">// Tue Feb 25 2025 10:35:24 GMT+0800 (中国标准时间)</span><br><span class="hljs-comment">// 使用时间戳（自1970年1月1日以来的毫秒数）</span><br>const time_stamp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1696070400000</span>)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(time_stamp); <span class="hljs-comment">// Sat Sep 30 2023 18:40:00 GMT+0800 (中国标准时间)</span><br><span class="hljs-comment">// 使用日期字符串</span><br>const date_string = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;2025-02-25T10:35:24&quot;</span>)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(date_string); <span class="hljs-comment">// Tue Feb 25 2025 10:35:24 GMT+0800 (中国标准时间)</span><br><br><span class="hljs-comment">// ============= 获取具体日期和时间 ===============</span><br>const now_time = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(now_time.getFullYear()); <span class="hljs-comment">// 年</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(now_time.getMonth()+<span class="hljs-number">1</span>); <span class="hljs-comment">// 月</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(now_time.getDate());<span class="hljs-comment">// 日</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(now_time.getHours());<span class="hljs-comment">// 时</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(now_time.getMinutes());<span class="hljs-comment">// 分</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(now_time.getSeconds());<span class="hljs-comment">// 秒</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(now_time.getMilliseconds()); <span class="hljs-comment">// 毫秒,范围在 0 到 999 </span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(now_time.getDay());<span class="hljs-comment">// 星期</span><br><br><span class="hljs-comment">// ============= 时间戳操作 ===============</span><br>const now_time_stamp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br><span class="hljs-comment">// getTime 返回自1970年1月1日以来的毫秒数</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(now_time_stamp.getTime()); <span class="hljs-comment">// 1739607954915 </span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(now_time_stamp.setTime(<span class="hljs-number">1696684800000</span>)); <span class="hljs-comment">// 1696684800000</span><br><br><span class="hljs-comment">// ============= 日期格式化 ===============</span><br><span class="hljs-comment">// 本身没有内置的格式化方法</span><br><span class="hljs-comment">// 但可以通过手动拼接</span><br><span class="hljs-comment">// 或使用第三方库（如 moment.js 或 date-fns）来实现。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">formDate</span>(<span class="hljs-params">date</span>)&#123;<br>    const <span class="hljs-built_in">year</span> =<span class="hljs-built_in">date</span>.getFullYear()<br>    const <span class="hljs-built_in">month</span> =<span class="hljs-built_in">date</span>.getMonth()+<span class="hljs-number">1</span><br>    const <span class="hljs-built_in">day</span> =<span class="hljs-built_in">date</span>.getDate()<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">year</span>&#125;</span>-<span class="hljs-subst">$&#123;<span class="hljs-built_in">month</span>&#125;</span>-<span class="hljs-subst">$&#123;<span class="hljs-built_in">day</span>&#125;</span>`</span><br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(formDate(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>())); <span class="hljs-comment">// 2025-2-15</span><br></code></pre></td></tr></table></figure></li><li><p><strong>正则表达式 RegExp：</strong>用于模式匹配字符串。</p><p>支持各种模式和修饰符（如 <code>g</code> 全局匹配、<code>i</code> 忽略大小写）。</p><p>可用于查找、替换和验证字符串格式。</p><ul><li><p>字面量语法<br>const regex &#x3D; &#x2F;pattern&#x2F;flags</p><p>pattern：正则表达式的模式，用于定义匹配规则。</p><p>flags：可选的标志，用于修改匹配行为</p></li><li><p>构造函数语法</p><p>const regex &#x3D; new RegExp(“pattern”, “flags”);</p></li></ul><p><strong>常见的模式</strong></p><blockquote><ul><li><code>.</code>：匹配任意单个字符（默认不包括换行符）。</li><li><code>\d</code>：匹配任意数字（0-9）。</li><li><code>\w</code>：匹配任意字母、数字或下划线（等价于 <code>[a-zA-Z0-9_]</code>）。</li><li><code>\s</code>：匹配任意空白字符（空格、制表符、换行符等）。</li><li><code>[abc]</code>：匹配方括号中的任意一个字符。</li><li><code>[^abc]</code>：匹配不在方括号中的任意字符。</li><li><code>^</code>：匹配字符串的开头。</li><li><code>$</code>：匹配字符串的结尾。</li><li><code>\b</code>：匹配单词边界。</li><li><code>\B</code>：匹配非单词边界。</li><li><code>*</code>：匹配前面的字符 0 次或多次。</li><li><code>+</code>：匹配前面的字符 1 次或多次。</li><li><code>?</code>：匹配前面的字符 0 次或 1 次。</li><li><code>&#123;n&#125;</code>：匹配前面的字符恰好 n 次。</li><li><code>&#123;n, m&#125;</code>：匹配前面的字符至少 n 次，最多 m 次。</li><li><code>()</code>：分组，捕获匹配的内容。</li><li><code>|</code>：表示逻辑“或”，用于匹配多个选项中的任意一个。</li></ul></blockquote><p><strong>常见的标志</strong></p><blockquote><ul><li><code>g</code>：全局匹配（匹配所有可能的结果）。</li><li><code>i</code>：忽略大小写。</li><li><code>m</code>：多行模式（允许 <code>^</code> 和 <code>$</code> 匹配每一行的开头和结尾）。</li><li><code>s</code>：单行模式（允许 <code>.</code> 匹配换行符）。</li><li><code>u</code>：Unicode 模式（支持 Unicode 字符）。</li><li><code>y</code>：粘性匹配（从上次匹配的位置开始匹配）</li></ul></blockquote><p><strong>常用的方法</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const regex1 = /abc/<br>// ============ test 是否有匹配的<br>console.log(regex1.test(<span class="hljs-string">&#x27;wwwabcde&#x27;</span>)); // <span class="hljs-keyword">true</span><br>console.log(regex1.test(<span class="hljs-string">&#x27;a0b0ccc&#x27;</span>)); // <span class="hljs-keyword">false</span><br>// ============ exec 执行匹配，返回匹配结果数组或 <span class="hljs-keyword">null</span><br>const regex2 = /(\d+)/;<br>res = regex2.exec(<span class="hljs-string">&#x27;a123b233c3d4&#x27;</span>);<br><span class="hljs-keyword">if</span> (res)&#123;<br>    console.log(res[<span class="hljs-number">0</span>]); //完整匹配： &quot;123&quot;<br>    console.log(res[<span class="hljs-number">1</span>]); //第一个捕获组： &quot;123&quot;<br>    console.log(res.<span class="hljs-keyword">index</span>); // 匹配的起始位置 <span class="hljs-number">1</span><br>    console.log(res.<span class="hljs-keyword">input</span>); // 原始字符串 a123b233c3d4<br>&#125;<br>// ============ 返回匹配结果数组，包含所有匹配的内容<br>const regex3 = /(\d+)/g; // 全局匹配<br>res = &quot;a123b233c3d4&quot;.match(regex3);<br>console.log(res);// [<span class="hljs-string">&#x27;123&#x27;</span>, <span class="hljs-string">&#x27;233&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>]<br>// ============ 返回一个迭代器，包含所有匹配的结果数组。<br>res = &quot;a123b233c3d4&quot;.matchAll(regex3);<br>console.log(res); // RegExpStringIterator<br><span class="hljs-keyword">for</span> (let match <span class="hljs-keyword">of</span> res)&#123;<br>    console.log(match);<br>    // [<span class="hljs-string">&#x27;123&#x27;</span>, <span class="hljs-string">&#x27;123&#x27;</span>, <span class="hljs-keyword">index</span>: <span class="hljs-number">1</span>, <span class="hljs-keyword">input</span>: <span class="hljs-string">&#x27;a123b233c3d4&#x27;</span>, <span class="hljs-keyword">groups</span>: undefined]<br>    // [<span class="hljs-string">&#x27;233&#x27;</span>, <span class="hljs-string">&#x27;233&#x27;</span>, <span class="hljs-keyword">index</span>: <span class="hljs-number">5</span>, <span class="hljs-keyword">input</span>: <span class="hljs-string">&#x27;a123b233c3d4&#x27;</span>, <span class="hljs-keyword">groups</span>: undefined]<br>    // [<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-keyword">index</span>: <span class="hljs-number">9</span>, <span class="hljs-keyword">input</span>: <span class="hljs-string">&#x27;a123b233c3d4&#x27;</span>, <span class="hljs-keyword">groups</span>: undefined]<br>    // [<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-keyword">index</span>: <span class="hljs-number">11</span>, <span class="hljs-keyword">input</span>: <span class="hljs-string">&#x27;a123b233c3d4&#x27;</span>, <span class="hljs-keyword">groups</span>: undefined]<br>&#125;<br>// ============ 返回匹配内容的索引，未找到时返回 <span class="hljs-number">-1</span><br>res = &quot;a123b233c3d4&quot;.<span class="hljs-keyword">search</span>(regex3);<br>console.log(res); // <span class="hljs-number">1</span><br><br>// 还可以使用正则表达式替换字符串、拆分字符串。<br></code></pre></td></tr></table></figure></li><li><p><strong>错误对象 Error：</strong> 用于表示程序运行时发生的错误，帮助开发者进行调试和异常处理。</p><p>包含错误信息、错误名称和堆栈信息。</p><p>可通过 <code>throw</code> 关键字抛出，并使用 <code>try...catch</code> 进行捕获和处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">// 手动抛出一个异常</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Something went wrong!&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;: &quot;</span> + e.<span class="hljs-property">message</span>); <span class="hljs-comment">// &quot;Error: Something went wrong!&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>七大原始数据类型</tag>
      
      <tag>函数</tag>
      
      <tag>正则对象</tag>
      
      <tag>日期对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css绘制场景应用</title>
    <link href="/2025/02/15/css%E7%BB%98%E5%88%B6%E5%9C%BA%E6%99%AF%E5%BA%94%E7%94%A8/"/>
    <url>/2025/02/15/css%E7%BB%98%E5%88%B6%E5%9C%BA%E6%99%AF%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="css绘制场景应用"><a href="#css绘制场景应用" class="headerlink" title="css绘制场景应用"></a>css绘制场景应用</h1><h2 id="1、三角形"><a href="#1、三角形" class="headerlink" title="1、三角形"></a>1、三角形</h2><p>利用<code>border</code>属性，将<code>border</code>可视化，发现它并不是矩形组成的：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502150137281.png" alt="image-20250214221911820"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">70</span>, <span class="hljs-number">23</span>, <span class="hljs-number">114</span>);<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">100px</span> solid;<br>    <span class="hljs-attribute">border-color</span>: aqua rebeccapurple red green;<br>&#125;<br></code></pre></td></tr></table></figure><p>将div盒子的宽高设置为0，显示的是四个三角形：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502150137265.png" alt="image-20250214221956511"></p><p>于是利用透明度、边框长度等进行组合，绘制三角形：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502150137534.png" alt="image-20250214222330191"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">0px</span>;<br>            <span class="hljs-attribute">height</span>: <span class="hljs-number">0px</span>;<br>            <span class="hljs-attribute">border-top</span>: <span class="hljs-number">100px</span> solid aqua;<br>            <span class="hljs-attribute">border-right</span>:<span class="hljs-number">100px</span> solid transparent;<br>            <span class="hljs-attribute">border-left</span>:<span class="hljs-number">100px</span> solid transparent;<br>        &#125;<br></code></pre></td></tr></table></figure><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502150137289.png" alt="image-20250214223021160"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">0px</span>;<br>            <span class="hljs-attribute">height</span>: <span class="hljs-number">0px</span>;<br>            <span class="hljs-attribute">border-left</span>: <span class="hljs-number">100px</span> solid green;<br>            <span class="hljs-attribute">border-bottom</span>:<span class="hljs-number">100px</span> solid transparent;<br>            <span class="hljs-attribute">border-top</span>:<span class="hljs-number">100px</span> solid transparent;<br>        &#125;<br></code></pre></td></tr></table></figure><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502150137295.png" alt="image-20250214222926636"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>           <span class="hljs-attribute">width</span>: <span class="hljs-number">0px</span>;<br>           <span class="hljs-attribute">height</span>: <span class="hljs-number">0px</span>;<br>           <span class="hljs-attribute">border-left</span>: <span class="hljs-number">100px</span> solid transparent;<br>           <span class="hljs-attribute">border-bottom</span>:<span class="hljs-number">100px</span> solid red;<br>           <span class="hljs-attribute">border-right</span>:<span class="hljs-number">100px</span> solid transparent;<br>       &#125;<br></code></pre></td></tr></table></figure><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502150137248.png" alt="image-20250214223058709"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">0px</span>;<br>            <span class="hljs-attribute">height</span>: <span class="hljs-number">0px</span>;<br>            <span class="hljs-attribute">border-right</span>: <span class="hljs-number">100px</span> solid rebeccapurple;<br>            <span class="hljs-attribute">border-bottom</span>:<span class="hljs-number">100px</span> solid transparent;<br>            <span class="hljs-attribute">border-top</span>:<span class="hljs-number">100px</span> solid transparent;<br>        &#125;<br></code></pre></td></tr></table></figure><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502150137680.png" alt="image-20250214223345658"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0px</span>;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">100px</span> solid transparent;<br>    <span class="hljs-attribute">border-top</span>:<span class="hljs-number">100px</span> solid blue;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、扇形"><a href="#2、扇形" class="headerlink" title="2、扇形"></a>2、扇形</h2><p>利用三角形的绘制，加上一个圆角属性就可以啦~</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502150137701.png" alt="image-20250214233418311"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>; <br>   <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>   <span class="hljs-attribute">border</span>: <span class="hljs-number">100px</span> solid transparent;<br>   <span class="hljs-attribute">border-top</span>: <span class="hljs-number">100px</span> solid red;<br>   <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、圆形"><a href="#3、圆形" class="headerlink" title="3、圆形"></a>3、圆形</h2><p>先绘制一个正方形，再设置圆角属性 border-radius: 50%</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502150137722.png" alt="image-20250214234606559"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>   <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>   <span class="hljs-attribute">background-color</span>: red;<br>   <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、半圆"><a href="#4、半圆" class="headerlink" title="4、半圆"></a>4、半圆</h2><p>绘制长宽为2比1的矩形，再设置圆角属性，只设置左上，右上。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502150137765.png" alt="image-20250215000825948"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>   <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>   <span class="hljs-attribute">background-color</span>: red;<br>   <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50px</span> <span class="hljs-number">50px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、宽高自适应正方形"><a href="#5、宽高自适应正方形" class="headerlink" title="5、宽高自适应正方形"></a>5、宽高自适应正方形</h2><ul><li><p>利用vw&#x2F;vh，宽高取相对于视口的百分比单位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">10vw</span>;<br>   <span class="hljs-attribute">height</span>: <span class="hljs-number">10vh</span>;<br>   <span class="hljs-attribute">background-color</span>: tomato;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>利用width取百分比，高度由padding撑开，和width的百分比相同。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">20%</span>;<br>   <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">20%</span>;<br>   <span class="hljs-attribute">background-color</span>: tomato;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>利用width取百分比，高度由伪元素撑开。父元素一定要设置overflow: hidden;</p><p>若不设置 <code>overflow: hidden</code>，父级 div 的高度会被「塌陷」为 0！常规文档流中，相邻元素的垂直外边距会合并伪元素的 margin-top 会「穿透」父容器，导致父容器高度计算异常。</p><p>通过设置 <code>overflow: hidden</code>：</p><ul><li><p>创建了独立的布局环境 (BFC)</p></li><li><p>阻断外边距折叠</p></li><li><p>强制父容器包含子元素的 margin</p><p>说明：还可以设置 **display: flow-root;**或者 **float: left;**或者 <strong>position: absolute;</strong></p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">20%</span>;<br>   <span class="hljs-attribute">overflow</span>: hidden;<br>   <span class="hljs-attribute">background-color</span>: tomato;<br>&#125;<br><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">100%</span>;<br>  &#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="6、梯形"><a href="#6、梯形" class="headerlink" title="6、梯形"></a>6、梯形</h2><p>先给一个宽度，再给下边距，显示为一个矩形后，再定义透明的右边距，去覆盖掉一部分。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502150137782.png" alt="image-20250215004209063"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>   <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">100px</span> solid red;<br>   <span class="hljs-attribute">border-right</span>: <span class="hljs-number">80px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，可以绘制等腰梯形：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502150137976.png" alt="image-20250215004410270"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>   <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">100px</span> solid red;<br>   <span class="hljs-attribute">border-right</span>: <span class="hljs-number">80px</span> solid transparent;<br>   <span class="hljs-attribute">border-left</span>: <span class="hljs-number">80px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7、画一条0-5px的线"><a href="#7、画一条0-5px的线" class="headerlink" title="7、画一条0.5px的线"></a>7、画一条0.5px的线</h2><p>利用缩放 <code>transform: scale(0.5,0.5);</code></p><h2 id="8、如何解决-1px-问题？"><a href="#8、如何解决-1px-问题？" class="headerlink" title="8、如何解决 1px 问题？"></a>8、如何解决 1px 问题？</h2><p>1px问题：通常指的是在网页设计中使用 CSS 定义 1px 的线条或边框时，在不同设备（尤其是高分辨率或 Retina 屏幕）上实际显示效果与预期不一致的问题。设计师常希望得到“极细”的线条（hairline），在某些设备上 1px 的线条可能看起来太粗。在高分辨率屏幕上，一个 CSS 像素可能对应多个物理像素。例如，在 Retina 屏幕上，1 CSS 像素可能等于 2 或 3 个物理像素，这样 1px 的边框就会显得比真正的 1 个物理像素粗很多。</p><p>**？ ** 如何解决呢</p><blockquote><p>1、获取DPR，直接把 1px 改成 1&#x2F;devicePixelRatio 后的值。这种方法的缺陷在于兼容性不行，IOS 系统需要8及以上的版本，安卓系统则直接不兼容。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span> <span class="hljs-attr">data-device</span>=</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">window.devicePixelRatio</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span><span class="hljs-selector-attr">[data-device=<span class="hljs-string">&quot;2&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">border</span>:<span class="hljs-number">0.5px</span> solid <span class="hljs-number">#333</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2、伪元素先放大后缩小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span><span class="hljs-selector-attr">[data-device=<span class="hljs-string">&quot;2&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-id">#container</span><span class="hljs-selector-attr">[data-device=<span class="hljs-string">&quot;2&quot;</span>]</span><span class="hljs-selector-pseudo">::after</span>&#123;<br>      <span class="hljs-attribute">position</span>:absolute;<br>      <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">200%</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">200%</span>;<br>      <span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.5</span>);<br>      <span class="hljs-attribute">transform-origin</span>: left top;<br>      <span class="hljs-attribute">box-sizing</span>: border-box;<br>      <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#333</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、viewport 缩放。这样做的副作用也很大，整个页面被缩放了。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;</span>&gt;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>三角形</tag>
      
      <tag>扇形</tag>
      
      <tag>圆形</tag>
      
      <tag>半圆</tag>
      
      <tag>正方形</tag>
      
      <tag>梯形</tag>
      
      <tag>1px问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定位与浮动</title>
    <link href="/2025/02/14/%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%AE%E5%8A%A8/"/>
    <url>/2025/02/14/%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%AE%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="定位与浮动"><a href="#定位与浮动" class="headerlink" title="定位与浮动"></a>定位与浮动</h1><h2 id="1、清除浮动"><a href="#1、清除浮动" class="headerlink" title="1、清除浮动"></a>1、清除浮动</h2><p><strong>浮动是什么</strong> </p><p>浮动float是一种css属性，将元素从正常的文档流取出，并将元素向容器的左侧或者右侧移动，使得其他元素（文本或者内联元素）围绕它排列。浮动元素碰到包含它的边框或者其他浮动元素的边框就会停留。</p><p>1、脱离正常文档流，占据一块区域。</p><p>2、其他元素产生环绕效果。</p><p><strong>为什么要清除浮动</strong></p><p>因为浮动元素不参与父容器的高度计算，如果容器只有浮动元素，父容器可能出现高度为0的情况，简称”父容器塌陷“问题。</p><p><strong>清除浮动的方法</strong></p><p>1、在浮动元素之后插入空的块级元素，添加行内样式，设置clear属性</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;float-box&quot;</span> style=<span class="hljs-string">&quot;float: left;&quot;</span>&gt;浮动元素&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;clear: both;&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>2、为父容器添加clearfix类，使用伪元素。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;clearfix&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;float-box&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;float: left;&quot;</span>&gt;</span>浮动元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 其他内容 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、为父容器设置 overflow 溢出属性，创建BFC，从而包含内部的浮动元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、为父容器设置 display，生成BFC，自动包含浮动。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">.<span class="hljs-built_in">container</span> &#123;<br>  <span class="hljs-keyword">display</span>: flow-root;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、对clear属性的理解"><a href="#2、对clear属性的理解" class="headerlink" title="2、对clear属性的理解"></a>2、对clear属性的理解</h2><p>clear 属性规定元素的哪一侧不允许出现浮动元素。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">clear</span>: none|<span class="hljs-type">left</span>|<span class="hljs-type">right</span>|<span class="hljs-type">both</span>|<span class="hljs-type">initial</span>|<span class="hljs-type">inherit</span>;<br></code></pre></td></tr></table></figure><p><code>clear: both;</code>，这保证了它不会与任何左侧或右侧的浮动元素重叠，而是会显示在这些浮动元素的下方。这样可以有效解决因浮动带来的布局混乱问题。</p><h2 id="3、对BFC的理解"><a href="#3、对BFC的理解" class="headerlink" title="3、对BFC的理解"></a>3、对BFC的理解</h2><p><strong>BFC（Block Formatting Context，块级格式化上下文）</strong> ，它是一种布局的概念，是一个独立的渲染区域，其中的子元素会按照一定的规则排列，且这个区域与外部环境相对独立。</p><ul><li><strong>独立的布局区域。</strong>当一个元素形成了BFC，它内部的块级盒子（包括浮动元素）会在这个独立的上下文进行布局，不受外部元素的干扰。BFC的区域不会与浮动元素发生重叠。</li><li><strong>清除浮动。</strong>由于浮动元素不参与正常的文档流，可能导致父容器高度塌陷，通过触发BFC（例如给父容器设置overflow: hidden;），可以让父容器包裹住内部的浮动元素。</li><li><strong>需要避免外边距重叠。</strong>在同一个BFC内，相邻块级元素的垂直外边距可能会发生折叠。如果希望避免这种情况，将这些元素放入不同的 BFC 中可以解决外边距重叠的问题。</li><li><strong>可以用来实现两栏布局</strong>。 左侧设置<code>float:left</code>，右侧设置<code>overflow: hidden</code>。这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。</li></ul><p><strong>？</strong> 如何让一个元素触发BFC</p><blockquote><p>1、设置浮动（且不为none)</p><p>2、设置定位（ <code>absolute</code> 或 <code>fixed</code> ）</p><p>3、设置溢出（不为 <code>visible</code>，可以是 <code>hidden</code>、<code>auto</code> 或 <code>scroll</code>）</p><p>4、设置display（ <code>display: inline-block;</code>、<code>display: flex;</code> 或 <code>display: grid;</code> ）</p></blockquote><h2 id="4、外边距折叠问题"><a href="#4、外边距折叠问题" class="headerlink" title="4、外边距折叠问题"></a>4、外边距折叠问题</h2><p>外边距折叠：在css布局中，垂直方向上相邻的块级元素的外边距不会简单相加，而是合并成较大的外边距。父子元素之间也可能存在，当父元素没有边框或内边距时，父元素的上边距和其第一个子元素的上边距也可能发生折叠；同样，父元素的下边距和最后一个子元素的下边距也会折叠。</p><p>问题：设计初衷是为了避免页面中出现过大的间距，但可能会导致开发者预期与实际布局不符，从而引发问题。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;margin-bottom: 20px; background: lightblue;&quot;</span>&gt;元素<span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;margin-top: 30px; background: lightgreen;&quot;</span>&gt;元素<span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>？</strong> 怎么避免外边距折叠问题</p><blockquote><p>1、为父元素或者相邻元素添加内边距 &#x2F; 边框。</p><p>2、使用BFC，为父元素生成独立的格式化上下文，限制了子元素外边距“溢出”父元素的边界，使得子元素的外边距仅在父元素内部起作用，而不会和父元素的外边距合并到一起。</p><p>3、让兄弟元素各自形成 BFC 。</p></blockquote><h2 id="5、元素的层叠顺序"><a href="#5、元素的层叠顺序" class="headerlink" title="5、元素的层叠顺序"></a>5、元素的层叠顺序</h2><p>层叠顺序 stacking order：多个重叠元素在视觉上显示的前后顺序，也就是元素的覆盖顺序，是Z轴方向的层叠（垂直于屏幕的方向）。</p><p>层叠上下文 stacking context：层叠上下文是一个独立的“堆栈”，在这个上下文内的元素按照特定的规则排列。只有在同一个层叠上下文中的元素，其 z-index 值才会相互比较。</p><p><strong>？</strong> 创建层叠上下文的方法</p><blockquote><p>文档中的层叠上下文由满足以下任意一个条件的元素形成：</p><ul><li>文档根元素（<code>&lt;html&gt;</code>）；</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a> 值为 <code>absolute</code>（绝对定位）或 <code>relative</code>（相对定位）且 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a> 值不为 <code>auto</code> 的元素；</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a> 值为 <code>fixed</code>（固定定位）或 <code>sticky</code>（粘滞定位）的元素（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）；</li><li>flex (<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex"><code>flex</code></a>) 容器的子元素，且 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a> 值不为 <code>auto</code>；</li><li>grid (<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid"><code>grid</code></a>) 容器的子元素，且 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/z-index"><code>z-index</code></a> 值不为 <code>auto</code>；</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/opacity"><code>opacity</code></a> 属性值小于 <code>1</code> 的元素（参见 <a href="https://www.w3.org/TR/css3-color/#transparency">the specification for opacity</a>）；</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mix-blend-mode"><code>mix-blend-mode</code></a> 属性值不为 <code>normal</code> 的元素；</li><li>以下任意属性值不为 <code>none</code> 的元素：<ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform"><code>transform</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter"><code>filter</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/backdrop-filter"><code>backdrop-filter</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/perspective"><code>perspective</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path"><code>clip-path</code></a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mask"><code>mask</code></a> &#x2F; <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mask-image"><code>mask-image</code></a> &#x2F; <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mask-border"><code>mask-border</code></a></li></ul></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/isolation"><code>isolation</code></a> 属性值为 <code>isolate</code> 的元素；</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change"><code>will-change</code></a> 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素（参考<a href="https://dev.opera.com/articles/css-will-change-property/">这篇文章</a>）；</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain"><code>contain</code></a> 属性值为 <code>layout</code>、<code>paint</code> 或包含它们其中之一的合成值（比如 <code>contain: strict</code>、<code>contain: content</code>）的元素。</li></ul></blockquote><p><strong>z-index 属性</strong><br>z-index 用于调整处于同一层叠上下文中的元素的显示顺序：</p><ul><li>较大的 z-index 值会使元素显示在较小 z-index 值的元素之上。</li><li>z-index 只有在元素创建了定位（例如 <code>position: relative</code>、<code>absolute</code> 或 <code>fixed</code>）或属于特定的层叠上下文时才起作用。</li><li>在不同层叠上下文中的元素，彼此的 z-index 值不互相比较。</li><li>如果没有特别设置 z-index，元素会按照文档中出现的顺序进行堆叠（后面的覆盖前面的）。</li></ul><p>层叠等级：在同一个层叠上下文中，内部的元素在z轴的顺序。任何元素都有层叠等级。html根节点就是一个层叠上下文。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502142149722.png" alt="img"></p><p>对于上图，由上到下分别是：</p><p>（1）背景和边框：建立当前层叠上下文元素的背景和边框。</p><p>（2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。</p><p>（3）块级盒：文档流内非行内级<strong>非定位</strong>后代元素。</p><p>（4）浮动盒：<strong>非定位</strong>浮动元素。</p><p>（5）行内盒：文档流内行内级<strong>非定位</strong>后代元素。</p><p>（6）z-index:0：层叠级数为0的定位元素。</p><p>（7）正z-index：z-index属性值为正的定位元素。</p><h2 id="6、position的属性有哪些，区别是什么"><a href="#6、position的属性有哪些，区别是什么" class="headerlink" title="6、position的属性有哪些，区别是什么"></a>6、position的属性有哪些，区别是什么</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">position: static（默认）|<span class="hljs-type">absolute</span>|<span class="hljs-type">fixed</span>|<span class="hljs-type">relative</span>|<span class="hljs-type">sticky</span>|<span class="hljs-type">initial</span>|<span class="hljs-type">inherit</span>;<br></code></pre></td></tr></table></figure><ul><li><p><strong>static：</strong>默认，静态定位。按照正常的文档流排列，元素不会脱离文档流。设置top,left等无效。</p><p>适用场景：一般用于普通文本、段落和不需要定位的元素。</p></li><li><p><strong>absolute：</strong>绝对定位。元素脱离正常文档流，不再占据空间。定位参考最近的定位祖先（不含static)，没有就相对于文档的根元素html定位。</p><p>适用场景：需要精确控制元素位置，或制作悬浮层、弹出层等效果时使用。</p></li><li><p><strong>fixed：</strong>固定定位。元素脱离正常文档流，不再占据空间。定位参考浏览器视口，即使页面滚动，元素依然保持在同一位置。</p><p>适用场景：需要元素在页面滚动时保持固定位置时使用，常用于固定导航栏、返回顶部按钮等。</p></li><li><p><strong>relative：</strong>相对定位。仍然保持在文档流中，可以通过top、left等属性对元素的原始位置进行视觉上的偏移。</p><p>适用场景：当需要微调元素位置，同时希望元素仍然占据原始空间时使用；也常用于作为绝对定位子元素的定位参考。</p></li><li><p><strong>sticky：</strong>粘性定位。在滚动到指定阈值前表现为相对定位，达到阈值后表现为固定定位。需要设置 <code>top</code>、<code>left</code>、<code>bottom</code> 或 <code>right</code> 中的一个（常用 <code>top</code>）。</p><p>适用场景：常用于表头、侧边导航等，需要在页面滚动时保持部分固定的效果，但又需要遵循文档流的元素。</p></li><li><p><strong>initial|inherit：</strong>恢复默认值 | 从父元素继承。</p></li></ul><h2 id="7、display、float、position的关系"><a href="#7、display、float、position的关系" class="headerlink" title="7、display、float、position的关系"></a>7、<strong>display、float、position的关系</strong></h2><ul><li><p><strong>display：</strong>决定元素在正常文档流中的排列方式。</p><blockquote><p><strong>block</strong>：生成块级元素，独占一行。</p><p><strong>inline</strong>：生成行内元素，不独占一行。</p><p><strong>inline-block</strong>：具有行内特性，但同时可以设置宽高。</p><p><strong>flex</strong>、<strong>grid</strong>、<strong>table</strong> 等：生成相应的布局容器。</p><p><strong>none</strong>：不生成任何盒子，不显示。</p></blockquote></li><li><p><strong>float：</strong>让元素向左或向右“浮动”，脱离正常文档流，自动块化，会占据空间，从而使后续的文本或内联元素环绕它排列。</p></li><li><p><strong>position：</strong>决定元素在页面上的定位以及在文档流的行为。</p><blockquote><p><strong>static</strong>：默认值，元素按正常文档流排列。</p><p><strong>relative</strong>：相对定位，元素在正常流中占位，但可以通过偏移属性（top、right、bottom、left）相对于原位置移动。</p><p><strong>absolute</strong>：绝对定位，元素脱离文档流，定位参考最近的定位祖先；如果没有，则相对于文档根元素定位。</p><p><strong>fixed</strong>：固定定位，元素相对于视口定位，不随页面滚动变化。</p><p><strong>sticky</strong>：粘性定位，结合了 relative 和 fixed 的特点，根据滚动位置在两种状态之间切换。</p></blockquote></li></ul><p><strong>三者的关系和相互影响</strong></p><p><strong>第一优先</strong>：display: none，直接决定元素不显示，其它属性不再起作用。</p><p><strong>第二优先</strong>：position 属性，若设置为 absolute 或 fixed，则忽略 float，且自动调整 display（转换为 block&#x2F;table 等）。</p><p><strong>第三优先</strong>：当 position 不是绝对或固定时，检查 float。如果 float 不为 none，则 display 可能需要转换为适合浮动的显示类型，同时 position: relative 的偏移是基于浮动后的位置。</p><p><strong>最后</strong>：如果既不是绝对定位也没有浮动，再根据元素是否为根元素决定 display 的处理方式。非根元素的 display 属性保持用户指定的值，不会做额外的转换。而根元素在某些情况下会有特殊处理，确保整个页面的布局正常。</p><h2 id="8、absolute与fixed共同点与不同点"><a href="#8、absolute与fixed共同点与不同点" class="headerlink" title="8、absolute与fixed共同点与不同点"></a>8、absolute与fixed共同点与不同点</h2><p>共同点：</p><ul><li><strong>脱离文档流</strong>：无论是 <code>position: absolute;</code> 还是 <code>position: fixed;</code>，它们都不会占据正常文档流中的空间，周围元素会按常规流排列，不会受到它们位置的影响。</li><li><strong>定位属性</strong>：两者都可以使用 <code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code> 属性来指定元素的位置。</li><li><strong>重叠与层叠</strong>：由于都脱离了文档流，它们容易与其他元素重叠，并且可以通过 <code>z-index</code> 来控制重叠的顺序。</li></ul><p>不同点：</p><ul><li><p><strong>定位参照对象</strong>：</p><p><code>position: absolute; </code>参照对象是其最近的定位祖先（即具有 <code>position</code> 值为 <code>relative</code>、<code>absolute</code>、<code>fixed</code> 或 <code>sticky</code> 的父元素）。如果没有定位祖先，则参照初始包含块（通常是浏览器的根元素 <code>&lt;html&gt;</code>）；</p><p><code>position: fixed;</code> 元素始终相对于视口（浏览器窗口）定位，不受任何祖先元素的影响，即使其父元素有定位也不改变这一行为。</p></li><li><p><strong>滚动行为</strong>：</p><p><code>position: absolute; </code> 由于它相对于其定位祖先定位，当页面滚动时，绝对定位元素会随其包含块一起滚动。</p><p><code>position: fixed; </code> 固定定位的元素始终固定在视口内，即使页面滚动，它们的位置也不会改变。</p></li><li><p><strong>应用场景</strong>：</p><p><code>position: absolute; </code> 适用于在某个特定区域内精确定位的情况，如弹出菜单、工具提示等，通常依赖于容器的尺寸或位置。</p><p><code>position: fixed; </code> 常用于需要在用户滚动页面时保持固定位置的元素，如固定导航栏、侧边栏或返回顶部按钮等。</p></li></ul><h2 id="9、对-sticky-定位的理解"><a href="#9、对-sticky-定位的理解" class="headerlink" title="9、对 sticky 定位的理解"></a>9、对 sticky 定位的理解</h2><p>它是一种结合了相对定位和固定定位特性的 CSS 定位方式，它使元素在滚动过程中既能保持在文档流中的相对位置，又能在达到特定阈值后“粘住”视口的某个位置。</p><p><strong>触发条件</strong></p><p>需要为元素设置一个触发粘性的偏移量（例如 <code>top: 0;</code>），告诉浏览器何时开始固定元素的位置。</p><p><strong>粘性定位的效果只在其包含块（通常是父容器）的边界内有效。</strong>当父容器滚动出视口时，粘性元素也会随之消失。</p><h2 id="10、overflow属性介绍一下"><a href="#10、overflow属性介绍一下" class="headerlink" title="10、overflow属性介绍一下"></a>10、overflow属性介绍一下</h2><p><code>overflow</code> 属性是 CSS 中用于控制当内容超出元素的框（容器）时如何处理的一种属性。</p><p><strong>visible（默认值）</strong></p><ul><li><strong>效果</strong>：<br>超出容器边界的内容会继续显示出来，不会被裁剪或隐藏。</li></ul><p><strong>hidden</strong></p><ul><li><strong>效果</strong>：<br>超出容器边界的内容会被裁剪（隐藏），不会显示出来。</li></ul><p><strong>scroll</strong></p><ul><li><strong>效果</strong>：<br>无论内容是否超出，都始终显示滚动条。即使内容不需要滚动，滚动条依然可见（可能为禁用状态或仅显示占位符）。</li></ul><p><strong>auto</strong></p><ul><li><strong>效果</strong>：<br>只有在内容超出容器边界时才显示滚动条；如果内容未超出，则不会显示滚动条。</li></ul><p><strong>补充说明</strong></p><ul><li><p><strong>overflow-x 和 overflow-y</strong><br><code>overflow</code> 是一个复合属性，也可以分别使用 <code>overflow-x</code> 和 <code>overflow-y</code> 来控制水平方向和垂直方向上的溢出行为。<br>例如，可以设置 <code>overflow-x: hidden;</code> 而 <code>overflow-y: auto;</code>，实现水平隐藏、垂直滚动的效果。</p></li><li><p><strong>创建块级格式化上下文（BFC）</strong><br>通过设置 <code>overflow</code> 属性（如 <code>hidden</code> 或 <code>auto</code>），还可以触发元素创建块级格式化上下文（BFC），从而帮助解决一些常见的布局问题，比如清除浮动和防止外边距折叠等。</p><blockquote><p><strong>清除浮动</strong>：生成 BFC 的容器会包含其内部所有的浮动元素，确保父容器的高度能正确地扩展到包含这些浮动子元素。</p><p><strong>防止外边距折叠:</strong> 当一个元素创建了 BFC 后，它的外边距不会与 BFC 外部的元素发生折叠。BFC 形成了一个独立的布局区域，使得内部和外部的边距计算互不干扰，从而防止了外边距的折叠。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>清除浮动</tag>
      
      <tag>BFC</tag>
      
      <tag>外边距折叠</tag>
      
      <tag>层叠上下文</tag>
      
      <tag>position属性</tag>
      
      <tag>overflow属性</tag>
      
      <tag>display、float、position的关系</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面布局</title>
    <link href="/2025/02/14/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/"/>
    <url>/2025/02/14/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h1><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502141608077.png" alt="flex布局（学习笔记）_flex-flow: row wrap;-CSDN博客"></p><h2 id="1、常见的CSS布局单位"><a href="#1、常见的CSS布局单位" class="headerlink" title="1、常见的CSS布局单位"></a>1、常见的CSS布局单位</h2><p>像素、百分比、em、rem、vw&#x2F;vh</p><ul><li><p><strong>像素 px</strong></p><p><strong>css像素：</strong>在css中，px是逻辑像素，是一个抽象的单位，区别于屏幕上的物理像素。一个css像素不总是对应一个物理像素，例如在高分辨率显示器上，可能多个物理像素代表一个css像素。</p><p><strong>物理像素：</strong>显示器上的实际的显示单元数量。如果显示器的分辨率是1920x1080，代表横向有1920个物理像素，纵向有1080个物理像素。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502141608184.png" alt="image-20250213192329939"></p><blockquote><p>由此引申出<strong>设备像素比</strong>（Device Pixel Ratio, DPR）：物理像素与css像素的比率。例如，一个设备具有2倍设备像素比，代表每一个css像素由2x2&#x3D;4个物理像素组成。注意，是2x2。</p></blockquote><p>图片中的每一个像素，表示一个颜色信息。显示器中的每一个像素，表示最小的显示单元。<strong>PPI（ Pixels Per Inch ），</strong>描述的是显示设备中每英寸所包含的像素数量，数值越高，每英寸包含的像素越多，图像显示越细腻、清晰。</p><p>在高倍屏上，如果按照1比1，一个显示单元显示一个图片像素，显示的尺寸就会变小。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502141608163.png" alt="image-20250213193332480"></p><p>因此，为了显示出一致的图片大小，在操作系统层面，定义了逻辑分辨率 （虚拟分辨率），可以自定义，将物理像素分组。所以css中的px是逻辑像素。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502141608123.png" alt="image-20250213193550936"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502141608190.png" alt="image-20250213193745479"></p></li><li><p><strong>百分比 相对单位</strong></p><p>1、设置元素宽度和高度（相对于其父容器的尺寸）</p><p>2、设置内边距和外边距（相对于元素自身宽度计算）</p><p>3、使用绝对定位时（相对于定位父元素，即具有定位属性的父元素）</p><p>4、使用相对定位时（表现为将元素从原始位置进行相对偏移）</p></li><li><p><strong>em 相对单位</strong></p><p>相对于当前元素的字体大小计算的。</p><p>如果某个元素的字体大小是16px，那么1em就是16px。如果当前元素没有显式设置 <code>font-size</code>，那么它会继承其父元素的字体大小。如果父元素也没有设置，则会继承到浏览器的默认字体大小（通常是 16px，但这也可能因浏览器或用户设置而异）。</p><p>嵌套元素时有累计效应，因为它们的计算是相对于各自的父元素的字体大小。</p><blockquote><p>例如，若父元素字体大小为 <code>16px</code>，子元素设置 <code>font-size: 2em</code>，那么子元素字体大小就是 <code>32px</code>；如果子元素内部还有嵌套的元素再次设置 <code>font-size: 2em</code>，那么这部分文字的字体大小就会是 <code>64px</code>，因为它是相对于其直接父元素（32px）计算的。</p></blockquote></li><li><p><strong>rem 相对单位</strong></p><p>root em，始终相对于根元素的字体大小计算的。</p><p>无论元素在嵌套层级中有多深，使用 <code>rem</code> 单位时，它始终以根元素的 <code>font-size</code> 作为基准。避免累积效应。通过修改根元素的 <code>font-size</code>，可以很容易地调整整个页面的比例，进而实现响应式设计或主题切换。</p></li><li><p><strong>vw&#x2F;vh 视口单位</strong></p><p>相对于浏览器视口（viewport）的尺寸进行计算。如果需要一个元素或背景图始终填满整个视口时，使用 <code>100vw</code> 或 <code>100vh</code> 能非常方便地实现全屏效果。</p><p>视口单位能让元素的尺寸根据当前浏览器窗口大小动态变化，适应不同设备和屏幕尺寸。</p><p>**vw (viewport width)**：</p><ul><li>1vw 等于视口宽度的 1%。</li><li>例如，如果浏览器窗口宽度为 1000px，那么 1vw 就等于 10px。</li></ul><p>**vh (viewport height)**：</p><ul><li>1vh 等于视口高度的 1%。</li><li>如果浏览器窗口高度为 800px，那么 1vh 就等于 8px。</li></ul></li></ul><h2 id="2、两栏布局的实现"><a href="#2、两栏布局的实现" class="headerlink" title="2、两栏布局的实现"></a>2、两栏布局的实现</h2><p>一般两栏布局：左边一栏宽度固定，右边一栏宽度自适应。</p><p><strong>1、浮动</strong></p><p>左元素设置固定宽度200px，向左浮动；</p><p>右元素设置左边距200px，宽度auto，自动扩展到父元素的全部可用宽度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">width</span>: auto;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、浮动</strong></p><p>左元素设置固定宽度200px，向左浮动；</p><p>右元素设置overflow: hidden; （触发BFC）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span>&#123;<br>     <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>     <span class="hljs-attribute">background</span>: red;<br>     <span class="hljs-attribute">float</span>: left;<br> &#125;<br> <span class="hljs-selector-class">.right</span>&#123;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>     <span class="hljs-attribute">background</span>: blue;<br>     <span class="hljs-attribute">overflow</span>: hidden;<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>3、Flex布局</strong></p><p>左元素设置固定宽度200px</p><p>右元素设置flex:1</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4、绝对定位</strong></p><p>父元素相对定位</p><p>左元素设置固定宽度200px，absolute定位，</p><p>右元素设置左边距200px。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>5、绝对定位</strong></p><p>父元素相对定位</p><p>左元素设置固定宽度200px</p><p>右元素设置左定位200px，absolute定位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br><span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、三栏布局的实现"><a href="#3、三栏布局的实现" class="headerlink" title="3、三栏布局的实现"></a>3、三栏布局的实现</h2><p>一般是指左右侧固定，中间自适应布局。</p><p><strong>1、浮动</strong></p><p>左栏、右栏固定宽度，并分别设置左浮动、右浮动。</p><p>中间栏设置左右外边距。（中间元素必须放在最后，保证浮动元素先渲染好。否则在渲染时可能不会“看到”后续的浮动元素，从而其宽度和位置计算会出错，导致布局混乱。）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、flex布局</strong></p><p>左栏、右栏固定宽度，中间栏设置flex:1</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3、绝对定位</strong></p><p>左栏、右栏固定宽度</p><p>中间栏设置左右外边距。（中间元素必须放在最后）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4、圣杯布局</strong></p><p>父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: -<span class="hljs-number">100px</span>;<br><br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>5、双飞翼布局</strong></p><p>双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、水平垂直居中的实现"><a href="#4、水平垂直居中的实现" class="headerlink" title="4、水平垂直居中的实现"></a>4、水平垂直居中的实现</h2><p><strong>1、绝对定位</strong></p><p>父元素相对定位，子元素绝对定位，将元素的左上角通过 left: 50%;和 top: 50%;;移动到父元素中心。</p><p>再通过 transform: translate(-50%, -50%);调整到中心。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、绝对定位</strong></p><p>父元素相对定位，子元素绝对定位，四个方向定位0，margin：auto。</p><p>盒子要有宽高。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: brown;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">margin</span>: auto;<br>    <span class="hljs-attribute">background-color</span>: aqua;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3、绝对定位</strong></p><p>父元素相对定位，子元素绝对定位，将元素的左上角通过 left: 50%;和 top: 50%;;移动到父元素中心。</p><p>再通过 margin-left: -100px; margin-top: -100px;调整到中心。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;     <span class="hljs-comment">/* 自身 height 的一半 */</span><br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">50px</span>;    <span class="hljs-comment">/* 自身 width 的一半 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4、flex布局</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>:center;<br>    <span class="hljs-attribute">align-items</span>:center;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、如何根据设计稿进行移动端适配？"><a href="#5、如何根据设计稿进行移动端适配？" class="headerlink" title="5、如何根据设计稿进行移动端适配？"></a>5、如何根据设计稿进行移动端适配？</h2><p>1、<strong>设置视口</strong></p><p>将页面的宽度设置为设备的宽度，页面首次加载时按照1:1的比例进行显示（不进行缩放）。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>2、设计稿通常会以某个固定宽度（例如 375px、750px 等）为基准，按这个基准进行布局和计算，然后通过<strong>媒体查询</strong>或<strong>相对单位</strong>（百分比、em、rem、vw&#x2F;vh）来适配不同尺寸的设备。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span>) &#123;<br>  <span class="hljs-comment">/* 针对小屏幕的样式 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>3、响应式布局。弹性盒子（Flexbox）与 CSS Grid，自适应父容器，适合处理多列布局、居中等需求。</p><p>4、图片和资源优化。根据不同屏幕分辨率准备多份图片（如使用 <code>srcset</code> 或 <code>picture</code> 标签），避免高分辨率设备加载低质量图片。使用 CSS Sprites、懒加载等技术，提升加载效率。</p><h2 id="6、对Flex布局的理解及其使用场景"><a href="#6、对Flex布局的理解及其使用场景" class="headerlink" title="6、对Flex布局的理解及其使用场景"></a>6、对Flex布局的理解及其使用场景</h2><p>Flex 布局（弹性盒子布局）是 CSS3 引入的一种布局方式。在 Flex 布局中，子元素之间的垂直边距不会发生传统的“边距折叠”现象。</p><p><strong>Flex 容器</strong>：通过在父元素上设置 <code>display: flex</code>（或 <code>display: inline-flex</code>）将其变为 Flex 容器，其直接子元素自动成为 Flex 项目。</p><p><strong>Flex 项目</strong>：Flex 容器内的直接子元素，受 Flex 布局的控制。</p><p><strong>主轴（Main Axis）</strong>：默认情况下，Flex 容器的主轴是水平方向（从左到右），但可以通过 <code>flex-direction</code> 改变为垂直方向。</p><p><strong>交叉轴（Cross Axis）</strong>：与主轴垂直的方向。例如，当主轴为水平时，交叉轴即为垂直方向。</p><p>以下6个属性设置在<strong>容器上</strong>：</p><ul><li>flex-direction属性决定主轴的方向（即项目的排列方向）。</li><li>flex-wrap属性定义，如果一条轴线排不下，如何换行。</li><li>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</li><li>justify-content属性定义了项目在主轴上的对齐方式。</li><li>align-items属性定义项目在交叉轴上如何对齐。</li><li>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li></ul><p>以下6个属性设置在<strong>项目上</strong>：</p><ul><li>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li><li>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li><li>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li><li>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li><li>flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</li><li>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li></ul><h2 id="7、flex-1-表示什么"><a href="#7、flex-1-表示什么" class="headerlink" title="7、flex:1 表示什么"></a>7、flex:1 表示什么</h2><p>flex是 <strong>flex-grow</strong>、 <strong>flex-shrink</strong>、 <strong>flex-basis</strong>的简写，默认值为1，1，0%。</p><p><strong>ex-grow: 1</strong><br>表示该项目可以“增长”，即在有剩余空间时，它会按照比例分配这些空间。</p><p><strong>flex-shrink: 1</strong><br>表示该项目可以“收缩”，即在空间不足时，它会按照比例缩小。</p><p><strong>flex-basis: 0</strong><br>表示分配剩余空间时的初始基础值为 0。</p><p>使用 <code>flex: 1</code> 后，Flex 项目会平分父容器中所有可用的剩余空间，同时在容器空间不足时能等比例收缩，达到自适应布局的效果。</p><blockquote><p> flex: auto; 等价于1,1，auto。</p><p>使用 <code>flex: auto</code> 后，Flex 项目会首先根据自身内容或设定的尺寸来确定基础大小，然后在父容器有多余空间时，按比例增长；反之，在空间不足时，按比例缩小。这种设置既保留了元素的自然尺寸，又使其具备灵活调整的能力。</p></blockquote><h2 id="8、响应式设计的概念及基本原理"><a href="#8、响应式设计的概念及基本原理" class="headerlink" title="8、响应式设计的概念及基本原理"></a>8、响应式设计的概念及基本原理</h2><p>响应式设计是一种 web 设计方法，旨在使网页在各种设备和屏幕尺寸下都能获得良好的显示效果和用户体验。其基本思想是根据用户所用设备的<strong>屏幕大小、分辨率以及方向</strong>等动态调整布局和样式，而无需为每种设备单独开发页面。</p><p>采用相对单位、流式布局、媒体查询、优化图片资源、视口设置等。</p><h2 id="9、实现“品”-字布局"><a href="#9、实现“品”-字布局" class="headerlink" title="9、实现“品” 字布局"></a>9、实现“品” 字布局</h2><p><strong>1、浮动</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123; <br>  <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>; <br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>; <br>  <span class="hljs-attribute">font-size</span>:<span class="hljs-number">40px</span>; <br>  <span class="hljs-attribute">line-height</span>:<span class="hljs-number">100px</span>; <br>  <span class="hljs-attribute">color</span>:<span class="hljs-number">#fff</span>; <br>  <span class="hljs-attribute">text-align</span>:center;<br>&#125;<br><br><span class="hljs-selector-class">.div1</span>&#123; <br>  <span class="hljs-attribute">background</span>:red; <br>  <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span> auto;<br>&#125;<br><br><span class="hljs-selector-class">.div2</span>&#123; <br>  <span class="hljs-attribute">background</span>: green; <br>  <span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>; <br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">50%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.div3</span>&#123; <br>  <span class="hljs-attribute">background</span>: blue; <br>  <span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>; <br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、inline-block实现</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123; <br>  <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>; <br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>; <br>  <span class="hljs-attribute">font-size</span>:<span class="hljs-number">40px</span>; <br>  <span class="hljs-attribute">line-height</span>:<span class="hljs-number">100px</span>; <br>  <span class="hljs-attribute">color</span>:<span class="hljs-number">#fff</span>; <br>  <span class="hljs-attribute">text-align</span>:center;<br>&#125;<br><br><span class="hljs-selector-class">.div1</span>&#123; <br>  <span class="hljs-attribute">background</span>:red; <br>  <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span> auto;<br>&#125;<br><br><span class="hljs-selector-class">.div2</span>&#123; <br>  <span class="hljs-attribute">background</span>: green; <br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">50%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.div3</span>&#123; <br>  <span class="hljs-attribute">background</span>: blue; <br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10、实现九宫格布局"><a href="#10、实现九宫格布局" class="headerlink" title="10、实现九宫格布局"></a>10、实现九宫格布局</h2><p><strong>1、flex布局</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">30%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">30%</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">5%</span>;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">5%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">3</span>n)&#123; <br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-of-type</span>(n+<span class="hljs-number">7</span>)&#123; <br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、grid实现</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">30%</span> <span class="hljs-number">30%</span> <span class="hljs-number">30%</span>; <br>  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">30%</span> <span class="hljs-number">30%</span> <span class="hljs-number">30%</span>; <br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">5%</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3、float实现</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br><span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">30%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">30%</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">5%</span>;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">5%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">3</span>n)&#123; <br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-of-type</span>(n+<span class="hljs-number">7</span>)&#123; <br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4、inline-block实现</strong></p><p>注意：将 <code>li</code> 元素设置为 <code>display: inline-block</code> 时，HTML 中元素之间的换行、空格等空白字符会被浏览器当作文本节点渲染，从而在元素之间产生额外的空隙。</p><p>在 <code>ul</code> 上设置 <code>letter-spacing: -10px;</code>，会使得这些空白字符的宽度减少，从而“收紧”相邻的 inline-block 元素，使它们之间的间隔缩小或消失。这是一种常见的 hack 技巧，用于调整 inline-block 元素间因空白导致的不期望的间隙。</p><p>另一种常见的解决方案是将父元素的 <code>font-size</code> 设置为 0，然后在子元素中重新设置合适的 <code>font-size</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">letter-spacing</span>: -<span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">30%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">30%</span>;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">5%</span>;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">5%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">3</span>n)&#123; <br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-of-type</span>(n+<span class="hljs-number">7</span>)&#123; <br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>5、table实现</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.table</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">display</span>: table;<br>  <span class="hljs-attribute">border-spacing</span>: <span class="hljs-number">10px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-row; <br>&#125;<br><br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">30%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">30%</span>;<br>  <span class="hljs-attribute">display</span>: table-cell;<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>  <span class="hljs-attribute">background</span>: skyblue;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>布局单位</tag>
      
      <tag>两栏布局</tag>
      
      <tag>三栏布局</tag>
      
      <tag>水平垂直居中</tag>
      
      <tag>flex布局</tag>
      
      <tag>flex:1 表示什么</tag>
      
      <tag>响应式设计</tag>
      
      <tag>品字布局</tag>
      
      <tag>九宫格布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS知识点（三）</title>
    <link href="/2025/02/11/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2025/02/11/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS知识点（三）"><a href="#CSS知识点（三）" class="headerlink" title="CSS知识点（三）"></a>CSS知识点（三）</h1><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502112226921.png" alt="full-vh-css"></p><h2 id="1、CSS预处理器是什么"><a href="#1、CSS预处理器是什么" class="headerlink" title="1、CSS预处理器是什么"></a>1、CSS预处理器是什么</h2><p>是扩展css功能的工具，允许开发者使用类似编程语言的语法（变量、嵌套、函数、混入、运算等）编写样式代码。预处理器会将这种扩展语法的代码编译成标准的css代码，然后在浏览器中正常使用。</p><ul><li><p><strong>常见的css预处理器</strong></p><p>Sass &#x2F; SCSS 、Less、Stylus。</p></li><li><p><strong>为什么要用</strong></p><p>提高代码的可维护性：使用变量和混入可以减少重复代码，使得样式的维护和修改更简单。</p><p>增强代码结构：嵌套语法能更直观地反映HTML结构，使得层次关系一目了然。</p><p>实现逻辑运算：预处理器支持条件判断、循环等，可以自动生成大量相似的样式，减少手写。</p><p>模块化开发：可以把css分成多个模块或者文件，然后通过编译工具合并成一个css文件。</p></li></ul><h2 id="2、css后处理器是什么"><a href="#2、css后处理器是什么" class="headerlink" title="2、css后处理器是什么"></a>2、css后处理器是什么</h2><p>css生成后，对其进行进一步处理的工具。与预处理器不同，后处理器直接作用于标准Css文件，可以自动优化代码，处理兼容性问题，添加厂商前缀，转换现代css语法等。</p><ul><li><p><strong>常见的css后处理器</strong></p><p>PostCss、Autoprefixer</p></li><li><p><strong>为什么要用</strong></p><p>自动添加浏览器前缀：不同浏览器对css某些属性的支持不同，后处理器可以自动添加必要的前缀，减少手动编写的错误风险。</p><p>代码优化和压缩：后处理器可以清理无用的代码，压缩样式文件，提高页面加载速度。</p><p>增强css语法：允许开发者使用未来的css特性或扩展语法，并在编译时转换兼容当前浏览器的代码。</p><p>统一处理兼容性问题：集中处理跨浏览器兼容性问题，降低开发和测试的复杂度。</p></li></ul><h2 id="3、-before-和-after-的双冒号和单冒号有什么区别"><a href="#3、-before-和-after-的双冒号和单冒号有什么区别" class="headerlink" title="3、::before 和 :after 的双冒号和单冒号有什么区别"></a>3、::before 和 :after 的双冒号和单冒号有什么区别</h2><p>在 CSS2 中，伪元素（例如 <code>:before</code> 和 <code>:after</code>）都是使用单冒号书写的；</p><p>而在 CSS3 规范中，为了<strong>明确区分伪类与伪元素</strong>，引入了双冒号语法，推荐使用 <code>::before</code> 和 <code>::after</code>。</p><p>除了 ::before 和 ::after，CSS3 还引入了一些其他常用的伪元素。以下是其中几个常见的 CSS3 伪元素：</p><ul><li>::first-line：用于选中元素的第一行文本，可以对其应用特定的样式。</li><li>::first-letter：用于选中元素的第一个字母，可以对其应用特定的样式。</li><li>::selection：用于选中文本时的样式，例如文本的背景色和文本颜色等。</li><li>::placeholder：用于设置表单元素的占位符文本的样式，允许自定义占位符文本的颜色、字体等。</li></ul><h2 id="4、display-inline-block-什么时候会显示间隙"><a href="#4、display-inline-block-什么时候会显示间隙" class="headerlink" title="4、display:inline-block 什么时候会显示间隙"></a>4、display:inline-block 什么时候会显示间隙</h2><p>使用 <code>display: inline-block</code> 时，元素会以行内元素的形式排列，这就意味着它们会受到 HTML 中空白字符（如空格、换行、制表符）的影响，从而产生间隙。如果元素之间有空格、换行或者其他空白字符，这些空白字符会被浏览器解析为文本节点，并且默认会占据一定的宽度，从而在元素之间形成可见的间隙。</p><ul><li><strong>移除空白字符</strong></li><li><strong>将父容器的字体大小设置为0</strong></li><li><strong>为元素设置适当的负边距</strong></li><li><strong>使用 Flexbox 或 Grid 布局</strong></li></ul><h2 id="5、单行、多行文本溢出隐藏"><a href="#5、单行、多行文本溢出隐藏" class="headerlink" title="5、单行、多行文本溢出隐藏"></a>5、单行、多行文本溢出隐藏</h2><ul><li><p><strong>单行文本溢出</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>: hidden;        <span class="hljs-comment">/* 隐藏溢出内容 */</span><br><span class="hljs-attribute">white-space</span>: nowrap;     <span class="hljs-comment">/* 强制文本在一行显示 */</span><br><span class="hljs-attribute">text-overflow</span>: ellipsis; <span class="hljs-comment">/* 溢出时显示省略号 */</span><br></code></pre></td></tr></table></figure></li><li><p><strong>多行文本溢出</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">overflow</span>: hidden;          <span class="hljs-comment">/* 隐藏溢出内容 */</span><br><span class="hljs-attribute">display</span>: -webkit-box;      <span class="hljs-comment">/* 使用伸缩盒布局 */</span><br>-webkit-box-orient: vertical; <span class="hljs-comment">/* 垂直排列子元素 */</span><br>-webkit-line-clamp: <span class="hljs-number">3</span>;     <span class="hljs-comment">/* 限制为最多显示 3 行 */</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="6、Sass、Less是什么？"><a href="#6、Sass、Less是什么？" class="headerlink" title="6、Sass、Less是什么？"></a>6、Sass、Less是什么？</h2><p>css 预处理器扩展了css语言，使开发者能够使用类似编程语言的特性（变量、嵌套、混入、运算、条件和循环等）编写样式代码，预处理器编写的代码经过编译后生成标准css文件，供浏览器解析。</p><ul><li><p><strong>SCSS</strong> </p><p>文件后缀：<code>.scss</code></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-comment">// 变量定义</span><br>$primary-<span class="hljs-keyword">color</span>:#<span class="hljs-number">3</span>f51b5;<br>$margin:<span class="hljs-number">16</span>px;<br><br><span class="hljs-comment">// 嵌套（直接嵌套选择器）</span><br>.<span class="hljs-keyword">container</span> &#123;<br>    <span class="hljs-keyword">color</span>: $primary-<span class="hljs-keyword">color</span>;<br>    margin: $margin;<br><br>    .item &#123;<br>        padding: <span class="hljs-number">10</span>px;<br>        &amp;:hover&#123;<br>        <span class="hljs-comment">// 调用内置函数 lighten 来变亮颜色</span><br>            background-<span class="hljs-keyword">color</span>: lighten($primary-<span class="hljs-keyword">color</span>,<span class="hljs-number">10</span>%);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Mixin 定义：用 @mixin 定义一个可重用代码块</span><br>@mixin border-radius($radius)&#123;<br>    -webkit-border-radius: $radius;<br>    -moz-border-radius: $radius;<br>    border-radius: $radius;<br>&#125;<br><br><span class="hljs-comment">// 使用 Mixin：用 @include 引入 mixin</span><br>.box &#123;<br>    @include border-radius(<span class="hljs-number">5</span>px);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Sass 缩进语法</strong></p><p>文件后缀：<code>.sass</code></p><p>省略大括号和分号，完全依赖缩进来表示层级关系，语法更简洁。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 变量定义</span><br><span class="hljs-variable">$primary</span>-<span class="hljs-attribute">color</span>: <span class="hljs-number">#3498db</span><br><span class="hljs-variable">$margin</span>: <span class="hljs-number">16px</span><br><br><span class="hljs-comment">// 嵌套（依赖缩进表示层级）</span><br><span class="hljs-selector-class">.container</span><br>  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$primary</span>-color<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-variable">$margin</span><br>  <span class="hljs-selector-class">.item</span><br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span><br>    <span class="hljs-selector-pseudo">&amp;:hover</span><br>      <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">lighten</span>(<span class="hljs-variable">$primary</span>-color, <span class="hljs-number">20%</span>)<br><br><span class="hljs-comment">// Mixin 定义：用 &quot;=&quot; 或 &quot;@mixin&quot; 定义（早期常用 &quot;=&quot;，新版本也支持 @mixin）</span><br>=<span class="hljs-attribute">border-radius</span>(<span class="hljs-variable">$radius</span>)<br>  -webkit-<span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">$radius</span><br>  -moz-<span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">$radius</span><br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">$radius</span><br><br><span class="hljs-comment">// 使用 Mixin：用 &quot;+&quot; 引入 mixin（如果用 &quot;=&quot; 定义）或者 @include（如果用 @mixin 定义）</span><br><span class="hljs-selector-class">.box</span><br>  +<span class="hljs-attribute">border-radius</span>(<span class="hljs-number">10px</span>)<br><br></code></pre></td></tr></table></figure></li><li><p><strong>Less</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 使用 @ 符号定义变量</span><br><span class="hljs-variable">@primary-color:</span> <span class="hljs-number">#3498db</span>;<br><span class="hljs-variable">@margin:</span> <span class="hljs-number">16px</span>;<br><br><span class="hljs-selector-class">.menu</span> &#123;<br>    <span class="hljs-selector-tag">ul</span> &#123;<br>      <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">list-style</span>: none;<br>    &#125;<br>    <span class="hljs-selector-tag">li</span> &#123;<br>      <span class="hljs-attribute">display</span>: inline-block;<br>    &#125;<br>  &#125;<br><span class="hljs-comment">// Less 中的 Mixin 可以看作普通的类或者定义的代码块，它既可以无参数也可以有参数。</span><br><span class="hljs-selector-class">.center</span>()&#123;<br>    <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.border-radius</span>(<span class="hljs-variable">@radius</span>)&#123;<br>    -webkit-<span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">@radius</span>;<br>    -moz-<span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">@radius</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">@radius</span>;<br>&#125;<br><br><br><span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-selector-class">.center</span>();<br>    <span class="hljs-selector-class">.border-radius</span>(<span class="hljs-number">10px</span>);<br>  &#125;<br><br><span class="hljs-variable">@width:</span> <span class="hljs-number">100px</span>;<br><span class="hljs-selector-class">.box</span> &#123;<br><span class="hljs-attribute">width</span>: <span class="hljs-variable">@width</span> + <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="7、对媒体查询的理解"><a href="#7、对媒体查询的理解" class="headerlink" title="7、对媒体查询的理解"></a>7、对媒体查询的理解</h2><p>根据设备的特性（如屏幕尺寸、分辨率、方向等）动态的应用不同的样式规则。</p><p>实现响应式设计的核心工具，可以确保网页在各种设备（手机、平板、桌面）上都有良好的显示效果和用户体验。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@media (<span class="hljs-params">媒体类型</span>) and (<span class="hljs-params">媒体特性</span>) &#123;</span><br>  /* 样式规则 */<br>&#125;<br></code></pre></td></tr></table></figure><p>媒体类型：例如 <code>screen</code>（屏幕）、<code>print</code>（打印）、<code>all</code>（适用于所有设备）。</p><p>媒体特性：检测设备的具体属性，例如宽度、高度、分辨率等。</p><p><strong>常见的媒体特性</strong></p><p>1、宽度和高度</p><ul><li><code>width</code> &#x2F; <code>height</code>：视口宽度或高度。</li><li><code>min-width</code> &#x2F; <code>max-width</code>：设置最小或最大宽度。</li><li>常用于响应式布局，根据屏幕宽度调整样式。</li></ul><p>2、设备方向</p><ul><li><code>orientation</code>：检测设备的方向，值为 <code>portrait</code>（纵向）或 <code>landscape</code>（横向）。</li></ul><p>3、分辨率</p><ul><li><code>resolution</code>：检测设备的分辨率（例如 DPI）。</li><li>常用于针对高分辨率设备（如 Retina 屏幕）优化图像显示。</li></ul><p>4、宽高比</p><ul><li><code>aspect-ratio</code>：检测屏幕宽高比。</li><li>例如 <code>min-aspect-ratio: 16/9</code>，可用于适配超宽屏设备。</li></ul><p><strong>实际应用</strong></p><p>1、响应式设计</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>&#125;<br><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span>) &#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">480px</span>) &#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、调整图片和资源（针对高分辨率设备加载更高质量的图片）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-resolution</span>: <span class="hljs-number">2dppx</span>) &#123;<br>  <span class="hljs-selector-class">.logo</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;logo@2x.png&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、支持深色模式(使用 <code>prefers-color-scheme</code> 检测用户的系统配色偏好)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">prefers-color-scheme</span>: dark) &#123;<br>  <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#333</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8、对-CSS-工程化的理解"><a href="#8、对-CSS-工程化的理解" class="headerlink" title="8、对 CSS 工程化的理解"></a>8、对 CSS 工程化的理解</h2><p>在大型或者复杂的项目中，为了解决传统CSS随着代码规模增长而产生的问题（样式冲突、难以维护、低复用性等，引入工程化的方法和工具来优化CSS的开发、组织和维护、协作。</p><p>CSS 工程化是为了解决以下问题：</p><ol><li><p><strong>规范化和模块化</strong>：CSS 代码如何组织、如何拆分、模块结构怎样设计？</p><ul><li><p>将样式按功能或页面模块拆分，分离每个模块的作用域。</p><p>CSS Modules：通过工具为每个样式添加唯一标识，避免全局冲突。</p><p>组件化样式：在 React、Vue 等框架中，每个组件维护自己的样式文件。</p></li><li><p>目录结构设计。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-attribute">src</span>/<br>├── styles/<br>│   ├── base<span class="hljs-selector-class">.css</span>    <span class="hljs-comment">// 基础样式（如 reset 样式）</span><br>│   ├── variables<span class="hljs-selector-class">.css</span> <span class="hljs-comment">// 变量、主题定义</span><br>│   ├── layout<span class="hljs-selector-class">.css</span>  <span class="hljs-comment">// 通用布局</span><br>│   ├── components/ <span class="hljs-comment">// 组件样式</span><br>│   │   ├── <span class="hljs-selector-tag">button</span><span class="hljs-selector-class">.css</span><br>│   │   └── card<span class="hljs-selector-class">.css</span><br>│   └── pages/      <span class="hljs-comment">// 页面样式</span><br>│       ├── home<span class="hljs-selector-class">.css</span><br>│       └── about.css<br></code></pre></td></tr></table></figure></li><li><p>BEM命名规范</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.card</span> &#123; <span class="hljs-comment">/* Block */</span> &#125;<br><span class="hljs-selector-class">.card__title</span> &#123; <span class="hljs-comment">/* Element */</span> &#125;<br><span class="hljs-selector-class">.card--highlighted</span> &#123; <span class="hljs-comment">/* Modifier */</span> &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>编码优化</strong>：怎样写出更好的 CSS？</p><ul><li><p>No Repeat：利用 CSS 变量和混入减少样式重复</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:root</span> &#123;<br>  <span class="hljs-attr">--primary-color</span>: <span class="hljs-number">#007bff</span>;<br>&#125;<br><span class="hljs-selector-tag">button</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--primary-color);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>预处理器优化</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mel">$primary-<span class="hljs-keyword">color</span>: #<span class="hljs-number">007</span>bff;<br><span class="hljs-keyword">button</span> &#123;<br>  background-<span class="hljs-keyword">color</span>: $primary-<span class="hljs-keyword">color</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>避免过度嵌套的选择器</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">/* 不推荐 */</span><br><span class="hljs-selector-class">.header</span> <span class="hljs-selector-class">.nav</span> <span class="hljs-selector-class">.menu</span> <span class="hljs-selector-class">.item</span> <span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><br><span class="hljs-comment">/* 推荐 */</span><br><span class="hljs-selector-class">.menu-item</span> <span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>构建</strong>：如何处理我的 CSS，才能让它的打包结果最优？</p><blockquote><p>重要的工程化插件： PostCss、Webpack loader 等</p></blockquote><p>自动添加浏览器前缀</p><p>压缩和合并 CSS</p><p>支持按需加载</p><p>移除未使用的 CSS</p><p>预加载关键 CSS：将关键路径样式内联到 HTML 中，提高首屏加载性能</p></li><li><p><strong>可维护性</strong>：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？</p><p>使用 Stylelint 检查 CSS 代码风格，避免不一致。</p><p>文档化。</p><p>样式文件和代码一起使用 Git 管理。</p><p>定期进行样式代码审查，确保符合团队规范。</p><p><strong>？</strong> PostCss是如何工作的</p><blockquote><p>PostCSS 是一个 <strong>CSS 处理工具</strong>，它本质上是一个插件运行平台，可以通过插件对 CSS 进行各种处理，比如自动添加前缀、代码压缩、语法转换等。</p><p>PostCSS 的核心工作原理:<strong>CSS 文件 -&gt; 抽象语法树（AST） -&gt; 插件处理 -&gt; 生成 CSS 文件</strong>。</p><p>PostCSS 首先将 CSS 转换为 <strong>抽象语法树（AST）</strong>，这个结构化的数据表示了 CSS 的内容和结构。将生成的 AST 交给各个插件进行处理。例如：Autoprefixer 会在 AST 中找到需要添加浏览器前缀的属性。CSSNano 会对 AST 进行压缩优化。处理完成后，PostCSS 将修改过的 AST 转换回普通的 CSS 文件输出。</p><p>PostCSS 本身不处理任何 CSS，它的强大功能完全依赖插件。常见的插件包括：</p><ul><li><strong>Autoprefixer</strong>：自动添加浏览器前缀。</li><li><strong>cssnano</strong>：压缩和优化 CSS 文件。</li><li><strong>PurgeCSS</strong>：移除未使用的 CSS。</li></ul></blockquote><p><strong>？</strong> Webpack如何处理CSS的</p><blockquote><p>Webpack 通过 <code>css-loader</code> 和 <code>style-loader</code> 等加载器处理 CSS 文件。</p><p>Webpack 处理 CSS 的核心流程：</p><p><strong>读取 CSS 文件</strong><br>使用 <code>css-loader</code> 将 CSS 文件解析为 JavaScript 可理解的模块内容。</p><p><strong>将 CSS 内容注入到页面中</strong><br>使用 <code>style-loader</code> 或 <code>MiniCssExtractPlugin</code>，将解析后的 CSS 内容注入到页面中。</p><p><strong>支持预处理器</strong><br>使用 <code>sass-loader</code>、<code>less-loader</code> 或 <code>postcss-loader</code> 处理 SASS、LESS 或 PostCSS 文件。</p><p><strong>优化打包结果</strong><br>在生产环境中，Webpack 会通过压缩和移除无用 CSS，优化最终的输出文件。</p></blockquote></li></ol><h2 id="9、如何判断元素是否到达可视区域"><a href="#9、如何判断元素是否到达可视区域" class="headerlink" title="9、如何判断元素是否到达可视区域"></a>9、如何判断元素是否到达可视区域</h2><p>以图片显示为例：</p><ul><li><code>window.innerHeight</code> 是浏览器可视区的高度；</li><li><code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动的过的距离；</li><li><code>imgs.offsetTop</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）；</li><li>内容达到显示区域的：<code>img.offsetTop &lt; window.innerHeight + document.body.scrollTop;</code></li></ul><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502112226234.png" alt="img"></p><h2 id="10、z-index属性在什么情况下会失效"><a href="#10、z-index属性在什么情况下会失效" class="headerlink" title="10、z-index属性在什么情况下会失效"></a>10、z-index属性在什么情况下会失效</h2><p>z-index属性：控制元素的堆叠顺序（层级）</p><ul><li><p><strong>元素必须设置定位属性</strong>：例如 <code>relative</code>、<code>absolute</code>、<code>fixed</code> 或 <code>sticky</code>。</p></li><li><p><strong>层叠上下文的概念</strong>：某些 CSS 属性（如 <code>transform</code>、<code>opacity</code>、<code>filter</code> 等）会创建新的层叠上下文，使得在不同上下文中的元素无法互相比较 <code>z-index</code>。</p></li><li><p><strong>父元素限制</strong>：子元素的 <code>z-index</code> 仅在其所在的层叠上下文内有效，即使子元素 <code>z-index</code> 数值很大，也不能超越父元素所在上下文的整体层级。</p></li><li><p><strong>特殊情况</strong>：</p><ul><li><code>display: none</code> 的元素不会展示，自然 <code>z-index</code> 也无效。</li><li>某些内联元素可能需要转换为块级元素或添加定位属性才能正确应用 <code>z-index</code>。</li><li>例如 <code>iframe</code> 会创建独立的层叠上下文，需要特殊处理。</li></ul></li><li><p><strong>浏览器默认层叠规则</strong></p></li></ul><p>  即使没有 <code>z-index</code>，浏览器也有默认的堆叠规则，以下是堆叠顺序的规则（从低到高）：</p><ol><li>背景和边框（不受 <code>z-index</code> 影响）。</li><li>正常的流式内容。</li><li>浮动元素（<code>float</code>）。</li><li>定位元素（<code>position: relative/absolute/fixed</code>）。</li><li>设置了 <code>z-index</code> 的元素。</li></ol>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>预处理器</tag>
      
      <tag>伪元素</tag>
      
      <tag>行内块元素的间隙</tag>
      
      <tag>文本溢出隐藏</tag>
      
      <tag>Sass和Less</tag>
      
      <tag>媒体查询</tag>
      
      <tag>CSS工程化</tag>
      
      <tag>元素可视区域</tag>
      
      <tag>z-index有效条件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS知识点（二）</title>
    <link href="/2025/02/10/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2025/02/10/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS知识点（二）"><a href="#CSS知识点（二）" class="headerlink" title="CSS知识点（二）"></a>CSS知识点（二）</h1><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502102252037.png" alt="full-vh-css"></p><h2 id="1、对盒模型的理解"><a href="#1、对盒模型的理解" class="headerlink" title="1、对盒模型的理解"></a>1、对盒模型的理解</h2><p>每个 HTML 元素都被看作一个矩形的盒子，该盒子主要由以下四个部分组成：</p><p><strong>内容content、内边距padding、边框border、外边距margin。</strong></p><ul><li><p><strong>标准盒子模型（W3C盒模型、content-box）</strong></p><p>通过css设置的宽高只是内容区域的宽高。</p></li><li><p><strong>IE盒子模型（怪异盒模型、border-box）</strong></p><p>通过css设置的宽高包含了内容、内边距、边框。</p></li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">box</span>-sizing: <span class="hljs-built_in">border</span>-<span class="hljs-built_in">box</span>; # 默认是<span class="hljs-built_in">content</span>-<span class="hljs-built_in">box</span><br></code></pre></td></tr></table></figure><h2 id="2、为什么有时候用translate来改变位置而不是定位"><a href="#2、为什么有时候用translate来改变位置而不是定位" class="headerlink" title="2、为什么有时候用translate来改变位置而不是定位"></a>2、为什么有时候用<strong>translate</strong>来改变位置而不是定位</h2><p> 在前端开发中，需要改变元素位置实现动画或者交互效果。常见的两种方式是使用css定位（top、left等属性）、使用css变换（transform: translate())。</p><p>在讲二者的区别前，先了解<strong>浏览器的渲染流程：</strong></p><blockquote><p>1、样式计算。（根据HTML和CSS计算出每个元素的样式）</p><p>2、布局&#x2F;重排。浏览器计算每个元素在页面中的位置和尺寸。元素的几何信息如宽高和位置改变时，会触发重排。重排不仅影响目标元素，还可能影响到其他元素的布局。</p><p>3、绘制&#x2F;重绘。浏览器将每个元素绘制在屏幕上。如果元素只有颜色或外观的变化，可能只需要重绘，而不触发布局计算。</p><p>4、合成。现代浏览器把页面分为多个图层(layer），这一阶段，这些图层会被合成起来显示在屏幕上，通常由GPU加速处理，可以在不重新布局或重绘的情况下，单独对某些图层进行移动、缩放、旋转。</p></blockquote><ul><li><p><strong>css定位</strong></p><p>修改元素的top或者left等，通常需要配合position:relative(absolute)，浏览器需要重新计算元素在页面的位置，可能影响周围元素触发重排(reflow)，之后再进行重绘。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Box Move Animation<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.box</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">            <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: lightblue;</span><br><span class="language-css">            <span class="hljs-attribute">transition</span>: top <span class="hljs-number">0.5s</span> ease, left <span class="hljs-number">0.5s</span> ease;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.box</span><span class="hljs-selector-class">.move</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">top</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">left</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;moveBox()&quot;</span>&gt;</span>Move Box<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">moveBox</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;box&#x27;</span>);</span><br><span class="language-javascript">        box.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">&#x27;move&#x27;</span>);  <span class="hljs-comment">// 切换 move 类，触发动画</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure></li><li><p><strong>css变换</strong></p><p>使用transform:translateX()&#x2F;translateY)&#x2F;translate()时，实际上是修改了元素的<strong>变换矩阵</strong>。元素值在文档流中的位置和尺寸并未改变，只有视觉上产生位移。元素被提升到一个独立的合成层，在合成阶段，浏览器只需要调整这个图层的变换矩阵，无需重新计算页面的布局或重新绘制。</p><p>由于不触发重排重绘，性能更高，而且由GPU加速，更加流畅，渲染效率高。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>            <span class="hljs-attribute">background-color</span>: red;<br>            <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.5s</span> ease;<br>        &#125;<br><br>        <span class="hljs-selector-class">.box</span><span class="hljs-selector-class">.move</span> &#123;<br>            <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">100px</span>,<span class="hljs-number">100px</span>);<br>        &#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>？</strong>什么是合成层</p><blockquote><p>浏览器在渲染过程中把页面分为若干独立的图层，每个图层的内容可以独立地进行变换（如平移、旋转、缩放），<strong>当某个元素被单独提升为一个图层后</strong>，对它的操作只影响这一层，而不用重新计算其他图层的内容和位置。 优化性能上，主要是利用<strong>局部更新</strong>和<strong>GPU加速</strong>。</p></blockquote><p><strong>?</strong> 哪些属性触发合成层</p><blockquote><p>除了 <code>transform</code> 之外，还有 <code>opacity</code>、<code>filter</code> 等属性</p></blockquote><h2 id="3、-li-与-li-之间有空白间隔"><a href="#3、-li-与-li-之间有空白间隔" class="headerlink" title="3、 li 与 li 之间有空白间隔"></a>3、 li 与 li 之间有空白间隔</h2><p>当<code>li</code>标签设置<code>display:inline-block</code>属性时，页面效果如图所示</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502102252041.png" alt="image-20250210154408230"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>原因：浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个&lt;li&gt;放在一行，这导致&lt;li&gt;换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</p><ul><li><p><strong>解决方案</strong></p><p>1、将标签写在一起，不要留空</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、把换行处注释</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、父元素设置 <code> font-size: 0;</code> （空白字符的宽度与字体大小相关）</p><p>4、将 <code>&lt;li&gt;</code> 元素设置为 <code>float: left;</code>（脱离内联布局，不受空白字符影响）</p><p>5、使用 Flex 布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> &#123;<br><span class="hljs-attribute">display</span>: flex;<br>       &#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="4、CSS3中有哪些新特性"><a href="#4、CSS3中有哪些新特性" class="headerlink" title="4、CSS3中有哪些新特性"></a>4、CSS3中有哪些新特性</h2><ul><li><p><strong>新的选择器</strong></p><p>属性选择器增强：<code>[attr^=&quot;value&quot;]</code>、<code>[attr$=&quot;value&quot;]</code>、<code>[attr*=&quot;value&quot;]</code></p><p>新增结构伪类：<code>:nth-child(n)</code>、<code>:nth-of-type(n)</code>、<code>:first-child</code>、<code>:last-child</code>、<code>:not(selector)</code>等。</p></li><li><p><strong>背景与边框的扩展</strong></p><p>多重背景、渐变背景（<code>linear-gradient</code>、 <code>radial-gradient</code>）、边框图像(<code>border-image</code>)；</p><p>圆角<code>border-radius</code>、盒阴影<code>box-shadow</code>、文本阴影<code>text-shadow</code></p></li><li><p><strong>转换</strong></p><p>二维转换：旋转（<code>rotate</code>）、缩放（<code>scale</code>）、平移（<code>translate</code>）和倾斜（<code>skew</code>）等操作。</p><p>三维转换：<code>rotateX</code>、<code>rotateY</code>、<code>rotateZ</code> 以及透视（<code>perspective</code>）属性</p></li><li><p><strong>过渡</strong></p><p><code>transition</code>属性</p></li><li><p><strong>动画</strong></p><p>利用 <code>@keyframes</code> 定义动画的关键帧，使用 <code>animation</code> 属性将动画应用到元素上。</p></li><li><p><strong>布局新特性</strong><br>弹性盒布局<code>display: flex;</code>、网格布局<code>display: grid;</code>、多列布局<code> column-count</code></p></li><li><p><strong>媒体查询</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">@media [媒体类型] and ([媒体特性]) &#123;<br>  <span class="hljs-comment">/* CSS 规则 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>字体和文本</strong></p><p>利用<code>@font-face</code>规则，引入网络字体。</p><p>除了 <code>text-shadow</code> 外，还引入了一些新的属性来改善文本的渲染效果，如 <code>word-break</code>、<code>text-overflow</code>、<code>line-clamp</code>（部分浏览器支持）等。</p></li><li><p><strong>自定义属性</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:root</span> &#123;<br>  <span class="hljs-attr">--main-color</span>: <span class="hljs-number">#3498db</span>;<br>&#125;<br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--main-color);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>calc() 函数</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100%</span> - <span class="hljs-number">20px</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="5、替换元素的概念"><a href="#5、替换元素的概念" class="headerlink" title="5、替换元素的概念"></a>5、替换元素的概念</h2><p>“替换元素”指的是那些其显示内容不来源于标签内部的文本或子节点，而是由外部资源提供的元素。</p><p>替换元素的实际内容是由外部资源（图片、视频、嵌入的内容等）决定的，例如，<code>img</code>加载图片，<code>video</code>加载视频，<code>object</code>或者<code>iframe</code>加载外部文档或插件内容。</p><ul><li><p><strong>外部资源与布局分离</strong></p><p>由于替换元素的内容由外部文件提供，它们的渲染与页面其他内容相对独立。这在响应式设计中尤为重要，可以通过 CSS 控制其尺寸和缩放行为，而不会直接改变元素内部的结构。</p></li><li><p><strong>内在尺寸的参考</strong></p><p>浏览器在渲染替换元素时，会首先考虑其内在尺寸，然后再根据 CSS 指定的尺寸规则（例如百分比宽度、固定像素值等）来调整显示大小。这使得替换元素能够在不同的设备和布局中保持一定的比例或响应性。</p></li></ul><h2 id="6、常见的图片格式及使用场景"><a href="#6、常见的图片格式及使用场景" class="headerlink" title="6、常见的图片格式及使用场景"></a>6、常见的图片格式及使用场景</h2><p>1、 <strong>JPEG&#x2F;JPG</strong>有损压缩，文件体积小，多次保存会导致质量下降。</p><p>2、<strong>PNG</strong>无损压缩，文件体积较大，保存高质量细节。支持透明通道。</p><p>3、<strong>GIF</strong>无损压缩，文件体积较大，支持动画，支持透明。</p><p>4、<strong>SVG</strong> 基于XML代码，无限缩放不失真，文件体积小，支持动画。</p><p>5、<strong>WebP</strong>支持有损&#x2F;无损压缩，支持透明通道和动画。相同质量的图片，WebP具有更小的文件体积。</p><p>6、<strong>BMP</strong>无压缩位图格式，保持原始像素数据，文件体积较大。</p><h2 id="7、对-CSSSprites-的理解"><a href="#7、对-CSSSprites-的理解" class="headerlink" title="7、对 CSSSprites 的理解"></a>7、对 CSSSprites 的理解</h2><p>CSS Sprites 是一种在网页开发中常用的优化技术，其核心思想是将<strong>多个小图片合并为一张大图</strong>，通过 CSS 的背景定位（background-position）来显示大图中的特定区域，从而在页面上实现原来分散的多个图片效果。</p><ul><li><p><strong>减少HTTP请求：</strong>传统每个图片需要一次独立的http请求，这样只需请求一次。</p></li><li><p><strong>提高加载性能：</strong>减少http请求降低服务器压力，还能加快页面渲染速度。</p></li><li><p><strong>统一管理：</strong> 所有相关图标集中在一张图片中，便于统一管理和修改。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">div &#123;<br>    width: 200px;<br>    height: 200px;<br>    background-color: #ff0000;<br>    background-image: url(../Images/cat.jpg);<br>    background-repeat: no-repeat;<br>    background-size: contain;<br>    background-position:20px 10px;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="8、物理像素，逻辑像素和像素密度"><a href="#8、物理像素，逻辑像素和像素密度" class="headerlink" title="8、物理像素，逻辑像素和像素密度"></a>8、物理像素，逻辑像素和像素密度</h2><p><strong>物理像素：</strong>设备屏幕上实际存在的最小点，一个物理像素就是显示屏上能够发光的一个单元。</p><p>比如某个手机屏幕的分辨率可能是1080 x 1920，分别代表水平和垂直方向的物理像素数。</p><p><strong>逻辑像素：</strong>（也称作设备独立像素或 DIP,Density Independent Pixel），是开发时的抽象单位，通过缩放因子与物理像素进行映射，使得应用在不同屏幕密度下都能保持相似的视觉大小和比例。</p><blockquote><p><strong>举例：</strong><br>如果一个按钮在设计稿上是 50×50 逻辑像素，在一台 2x 的设备上，实际显示就会使用 100×100 物理像素；而在 3x 的设备上，则需要 150×150 的物理像素。</p></blockquote><p><strong>像素密度：</strong>单位面积内的物理像素数，通常用DPI（Dots Per Inch）或 PPI（Pixels Per Inch）来表示。高像素密度意味着屏幕上单位面积内拥有更多的物理像素，画面会更加细腻和清晰。</p><p><strong>？</strong> 为什么在移动端开发时需要用到 @2x, @3x 这种图片？</p><blockquote><p><strong>适配不同缩放因子：</strong><br>使用 @2x、@3x 命名的图片，可以让开发者根据设备的像素比自动选择合适的资源。例如：</p><ul><li>在普通（1x）设备上使用常规图片。</li><li>在 Retina（2x）设备上使用 @2x 图片。</li><li>在更高密度（3x）设备上使用 @3x 图片。</li></ul><p>这样可以确保图像在各个设备上既不失真，又能保证视觉效果一致。</p></blockquote><h2 id="9、对line-height-的理解"><a href="#9、对line-height-的理解" class="headerlink" title="9、对line-height 的理解"></a>9、对line-height 的理解</h2><p><strong>行盒（Line Box）：</strong>当元素中包含内联内容（如文字、图片等）时，浏览器会根据字体大小、行高等属性构建行盒，行盒决定了这一行的高度。</p><p><code>line-height</code> 指文本行基线间的垂直距离，用来指定行盒的高度，从而控制文本行与行之间的垂直间距。它既可以增加行与行之间的间距，使文本看起来更加宽松，也可以减小间距，使文本更加紧凑。指文本行基线间的垂直距离</p><p><code>line-height</code> 可以采用多种形式的取值：</p><ol><li>**关键字 <code>normal</code>： **<ul><li>默认值，浏览器会根据字体和排版引擎自动计算一个合适的行高。通常大约在字体大小的 1.2 到 1.4 倍之间，但不同浏览器和字体可能有所差异。</li></ul></li><li><strong>无单位数值（Unitless Number）：</strong><ul><li>例如：<code>line-height: 1.5;</code></li><li>当使用无单位数值时，这个值会与当前元素的 <code>font-size</code> 相乘，得到实际的行高。无单位数值具有一个优点：在继承时，子元素会继承这个乘数，而不是一个固定的长度，这样即使子元素的 <code>font-size</code> 发生变化，行高也会相应调整，保持良好的比例。</li></ul></li><li><strong>带单位的长度值（Length）：</strong><ul><li>例如：<code>line-height: 24px;</code>、<code>line-height: 1.5em;</code></li><li>这种方式直接指定了行盒的高度为一个固定值。使用固定值时，行高不会随着字体大小的变化而自动调整，因此在响应式设计中需要谨慎使用。</li></ul></li><li><strong>百分比（Percentage）：</strong><ul><li>例如：<code>line-height: 150%;</code></li><li>百分比的计算基于元素的 <code>font-size</code>。比如 <code>150%</code> 实际上等于 <code>1.5</code> 倍的字体大小。</li></ul></li></ol><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502102252164.png" alt="img"></p><p>从上到下四条线分别是顶线、中线、基线、底线。</p><p>行高是指上下文本行的基线间的垂直距离，即图中两条红线间垂直距离。</p><p>行距是指一行底线到下一行顶线的垂直距离，即第一行粉线和第二行绿线间的垂直距离。</p><h2 id="10、CSS-优化和提高性能的方法有哪些"><a href="#10、CSS-优化和提高性能的方法有哪些" class="headerlink" title="10、CSS 优化和提高性能的方法有哪些"></a>10、CSS 优化和提高性能的方法有哪些</h2><ul><li><p><strong>文件体积优化</strong> </p><p>使用工具压缩css文件，删除注释、空格、重复代码，将体积最小化。（如 <strong>CSSNano</strong>、<strong>PostCSS</strong>）</p><p>扫描代码，移除未使用的css规则。（如<strong>urgeCSS</strong>、<strong>UnCSS</strong> 等工具）</p><p>避免使用<code>@import</code>，改用<code>link</code>或者构建工具合并文件，减少 HTTP 请求次数。</p></li><li><p><strong>选择器优化</strong></p><p>减少复杂选择器，避免深度嵌套。</p><p>避免使用通用选择器。</p><p>优先使用类选择器，优于标签或属性选择器。</p></li><li><p><strong>减少重排和重绘</strong></p><ul><li>使用 <code>transform</code> 和 <code>opacity</code> 实现动画（触发合成层，跳过重排）。</li><li>批量修改 DOM 样式（如通过 <code>classList</code> 一次性修改多个属性）。</li></ul></li><li><p><strong>加载与执行优化</strong></p><ul><li>将首屏渲染所需的 CSS 直接内嵌到 HTML 中，减少关键路径的阻塞时间。</li><li>使用 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 或 <code>media=&quot;print&quot;</code> 延迟加载非首屏 CSS。都依赖于 <code>onload</code> 事件。</li><li>使用媒体查询，拆分不同设备的 CSS 文件，按需加载。</li></ul></li><li><p><strong>其他优化</strong></p><ul><li>避免使用昂贵的 CSS 属性，如 box-shadow、border-radius、filter 在大量使用时可能影响性能。</li><li>使用 Flexbox&#x2F;Grid 替代传统布局，减少复杂浮动或定位的使用。</li><li>精灵图：将多个图标或小图片合并为一张大图，减少 HTTP 请求数。</li><li>利用预处理器，更好地组织代码，使用变量、混合宏和函数等机制，可以生成更简洁、高效的 CSS。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>盒模型</tag>
      
      <tag>transform</tag>
      
      <tag>li与li之间的空隙</tag>
      
      <tag>css3新特性</tag>
      
      <tag>图片类型</tag>
      
      <tag>精灵图是什么</tag>
      
      <tag>物理像素与逻辑像素</tag>
      
      <tag>像素密度</tag>
      
      <tag>行高</tag>
      
      <tag>css性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS知识点（一）</title>
    <link href="/2025/02/10/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2025/02/10/CSS%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS知识点（一）"><a href="#CSS知识点（一）" class="headerlink" title="CSS知识点（一）"></a>CSS知识点（一）</h1><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502100005453.png" alt="full-vh-css"></p><h2 id="1、CSS选择器"><a href="#1、CSS选择器" class="headerlink" title="1、CSS选择器"></a>1、CSS选择器</h2><ul><li><p><strong>基本选择器</strong></p><ul><li>元素选择器（直接使用HTML元素）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>类选择器（使用 . 加上类名)</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ID选择器（使用 # 加上ID名）</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">#header&#123;</span><br>    <span class="hljs-keyword">background-color: </span><span class="hljs-keyword">black;</span><br><span class="hljs-keyword"></span>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>组合选择器</strong></p><ul><li>后代选择器（选择某元素内部（不论层级）的另一个元素，嵌套中的也算后代。）</li></ul><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">ul</span> <span class="hljs-string">li</span> &#123;<br>    <span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">none</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>子元素选择器（仅选择直接子元素，必须是第一顺位的亲儿子）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &gt; <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通用兄弟选择器（选择某元素后所有同级的兄弟元素，表面兄弟~）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> ~ <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>相邻兄弟选择器（选择紧跟在某元素后的第一好兄弟元素，紧紧并列又相依）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> + <span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: large;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>群组选择器（多个选择器用逗号分隔，可以一次性为多个元素定义样式）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>,<span class="hljs-selector-tag">h2</span>,<span class="hljs-selector-tag">h3</span>&#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通配符选择器（使用星号 (<code>*</code>) 选择文档中所有元素)</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">*&#123;<br>    <span class="hljs-built_in">box</span>-sizing: <span class="hljs-built_in">border</span>-<span class="hljs-built_in">box</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>属性选择器</strong></p><ul><li><p>基础属性选择器（选择所有带有 <code>target</code> 属性的 <code>&lt;a&gt;</code> 元素）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[target]</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>精确匹配   （&#x3D;）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&#x27;text&#x27;</span>]</span>&#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>开头匹配 （^&#x3D;）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href ^= <span class="hljs-string">&#x27;http&#x27;</span>]</span>&#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>结尾匹配  （$&#x3D;）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">img</span><span class="hljs-selector-attr">[src$=<span class="hljs-string">&#x27;.jpg&#x27;</span>]</span>&#123;<br>    <span class="hljs-attribute">border</span>: none;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>包含匹配  （*&#x3D;）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href*=<span class="hljs-string">&#x27;google&#x27;</span>]</span>&#123;<br>    <span class="hljs-attribute">text-decoration</span>: underline;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>伪类选择器</strong></p><p>伪类选择器用于选择元素的特定状态或位置，而这些状态或位置在文档树中并不通过实际的 HTML 属性来表达。</p><ul><li>动态伪类 根据用户的交互或状态来选择元素</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>    <span class="hljs-attribute">color</span>: yellowgreen;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>结构性伪类 根据元素在文档结构中的位置来选择元素</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first</span>-child&#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>&#125; <br># （选择每个列表中第一个 `&lt;<span class="hljs-selector-tag">li</span>&gt;` 元素） <br></code></pre></td></tr></table></figure><ul><li>排除伪类（否定伪类）（选择所有不具有 <code>special</code> 类的 <code>&lt;p&gt;</code> 元素）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-class">.special</span>) &#123;<br>  <span class="hljs-attribute">color</span>: black;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>:last-child</code>、<code>:nth-child(n)</code>、<code>:nth-of-type(n)</code>、<code>:focus</code>、<code>:active</code> 等，用于更精细地控制元素状态和位置。</p></li><li><p><strong>伪元素选择器</strong></p><p>伪元素选择器用于创建或选择文档中不存在的“虚拟”元素，这些元素可以用来应用样式或生成内容。</p><p>伪元素是用于选取元素的某一部分并为其添加样式。</p><p><code>::before</code>：在元素的内容前插入内容。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::before</span> &#123;<br><span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;NOTE&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>::after</code>：在元素的内容后插入内容。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::after</span> &#123;<br><span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;END&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 选择每个 <code>&lt;p&gt;</code> 元素的第一行文本：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123;<br><span class="hljs-attribute">color</span>: beige;<br>&#125;<br></code></pre></td></tr></table></figure><p>在每个 <code>&lt;div&gt;</code> 元素后生成一个清除浮动的伪元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>css3新增选择器</strong></p><ul><li><code>:not()</code> 选择器（用于选择不符合某个条件的元素)</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">button</span><span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-class">.disabeld</span>)&#123;<br><span class="hljs-attribute">cursor</span>: pointer;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>结构选择器</li></ul><p>如 <code>:nth-child()</code>、<code>:nth-last-child()</code>、<code>:nth-of-type()</code> 等，用于基于元素在父元素中的位置进行选择。</p></li></ul><h2 id="2、选择器优先级"><a href="#2、选择器优先级" class="headerlink" title="2、选择器优先级"></a>2、选择器优先级</h2><p>在 CSS 中，当多个规则应用到同一元素时，浏览器需要一种机制来决定哪个规则最终生效，这就是所谓的 <strong>选择器优先级</strong>（Specificity）。</p><ul><li><p><strong>计算规则</strong></p><p>每个css选择器都可以转换为一个由四部分组成的权重值，通常表示为：（A,B,C,D)</p><p>每出现一个，相应的值加一。</p><p>A：内联样式1000</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>B：ID选择器个数   0100</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing">#main &#123;<br><span class="hljs-built_in">background</span>-<span class="hljs-type">color</span>: <span class="hljs-built_in">red</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>C：类选择器、属性选择器、伪类选择器的个数 0010</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.contain</span> &#123;<br> <span class="hljs-attribute">background-color</span>: blue;<br>    &#125;<br><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;text&quot;</span>]</span>&#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>    &#125;<br>    <br><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: aqua;<br>    &#125;<br></code></pre></td></tr></table></figure><p>D：元素选择器、伪元素选择器的个数 0001</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br><span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">::first-line</span>&#123;<br><span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p><strong>组合符号</strong>（如空格、<code>&gt;</code>、<code>+</code>、<code>~</code>）和<strong>通配符</strong>（<code>*</code>）<strong>不会</strong>增加任何权重。</p><p><strong>否定伪类</strong> <code>:not()</code> 内部的选择器不会计入优先级，但 <code>:not()</code> 本身作为伪类会计算到 C 中。</p></li><li><p><strong>优先级比较规则</strong></p><p>当多个规则应用到同一元素时，浏览器会按照以下顺序进行比较：</p></li></ul><ol><li><strong>A 值</strong>：内联样式最高（A 值为 1 的规则优先级最高）。</li><li><strong>B 值</strong>：ID 数量越多，优先级越高。</li><li><strong>C 值</strong>：类、属性和伪类数量越多，优先级越高。</li><li><strong>D 值</strong>：元素和伪元素数量越多，优先级越高。</li></ol><ul><li><strong>关于 <code>!important</code></strong></li></ul><p>​<code>!important</code> 声明可以让某条样式规则具有最高的<strong>声明优先级</strong>，即使其选择器权重较低也能覆盖其他规则。</p><p>​但应谨慎使用 <code>!important</code>，因为它会使样式难以维护和调试。</p><ul><li><p><strong>其他</strong></p><p>如果优先级相同，则最后出现的样式生效；</p><p>继承得到的样式的优先级最低；</p><p>内部样式和外部样式都属于<strong>作者样式</strong>（Author Stylesheet），从来源上讲，它们在优先级上是平等的。也就是说，仅仅因为样式是写在 <code>&lt;style&gt;</code> 标签内（内部样式）还是存放在外部 CSS 文件中（外部样式），并不会决定它们的优先级高低。真正影响最终样式生效的因素主要有：</p><p>1、选择器的特异性（Specificity）— 相同来源内，不同选择器的权重不同。</p><p>2、源代码中的出现顺序（Source Order）。</p><p>3、<code>!important</code> 声明。</p></li></ul><h2 id="3、CSS继承与不继承元素"><a href="#3、CSS继承与不继承元素" class="headerlink" title="3、CSS继承与不继承元素"></a>3、CSS继承与不继承元素</h2><p>在 CSS 中，属性是否被子元素自动继承主要取决于该属性的设计初衷。大致来说，<strong>与文本、字体、颜色等相关的属性默认是可继承的</strong>，而大多数<strong>与布局、盒模型、背景、定位等相关的属性默认是不继承的</strong>。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             </p><ul><li><p><strong>可继承</strong></p><blockquote><p><strong>文本和字体相关：</strong></p><ul><li><code>color</code>：文本颜色</li><li><code>font-family</code>：字体系列</li><li><code>font-size</code>：字体大小</li><li><code>font-style</code>：字体样式（如斜体）</li><li><code>font-weight</code>：字体粗细</li><li><code>line-height</code>：行高</li><li><code>text-align</code>：文本对齐方式</li><li><code>text-indent</code>：首行缩进</li><li><code>text-transform</code>：文本大小写转换</li><li><code>letter-spacing</code>：字母间距</li><li><code>word-spacing</code>：单词间距</li><li><code>white-space</code>：空白处理方式</li><li><code>direction</code>：文本方向（例如从左到右或从右到左）</li></ul><p><strong>列表与引用相关：</strong></p><ul><li><code>list-style</code>：列表样式（包括 <code>list-style-type</code>、<code>list-style-position</code> 等）</li><li><code>quotes</code>：用于设置引用内容的引号</li></ul><p><strong>其他：</strong></p><ul><li><code>visibility</code>：可见性（虽然主要用于控制显示与隐藏，但其值也会被子元素继承）</li><li>（部分情况下，<code>cursor</code> 也会继承，但不同浏览器的实现可能略有差异）</li></ul></blockquote></li><li><p><strong>不可继承</strong></p><blockquote><p><strong>盒模型与布局：</strong></p><ul><li><code>margin</code>：外边距</li><li><code>padding</code>：内边距</li><li><code>border</code>（以及相关的 <code>border-width</code>、<code>border-style</code>、<code>border-color</code>）</li><li><code>width</code>、<code>height</code>、<code>min-width</code>、<code>max-width</code>、<code>min-height</code>、<code>max-height</code></li><li><code>box-sizing</code>：盒模型的计算方式</li></ul><p><strong>背景与装饰：</strong></p><ul><li><code>background</code>、<code>background-color</code></li><li><code>background-image</code></li><li><code>background-position</code></li><li><code>background-size</code></li><li><code>background-repeat</code></li></ul><p><strong>定位与显示：</strong></p><ul><li><code>display</code>：元素的显示类型（如 <code>block</code>、<code>inline</code>、<code>flex</code> 等）</li><li><code>position</code>：定位方式（如 <code>static</code>、<code>relative</code>、<code>absolute</code>、<code>fixed</code>、<code>sticky</code>）</li><li>定位偏移属性：<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code></li><li><code>float</code>：浮动</li><li><code>clear</code>：清除浮动</li><li><code>z-index</code>：层叠顺序</li><li><code>overflow</code>：溢出处理方式</li></ul><p><strong>视觉效果与动画：</strong></p><ul><li><code>opacity</code>：透明度</li><li><code>transform</code>：变换效果</li><li><code>transition</code>：过渡效果</li><li><code>animation</code>：动画效果</li><li><code>box-shadow</code>：盒子阴影</li><li><code>border-radius</code>：圆角</li></ul></blockquote></li><li><p><strong>强制继承：<code>inherit</code> 关键字</strong></p></li></ul><p>即使属性默认不可继承，也可以通过 <code>inherit</code> 强制继承父元素的值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">width</span>: inherit; <span class="hljs-comment">/* 强制继承父元素的 width */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、display的属性值及其作用"><a href="#4、display的属性值及其作用" class="headerlink" title="4、display的属性值及其作用"></a>4、display的属性值及其作用</h2><p>基本显示类型：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">display: </span><span class="hljs-keyword">block; </span><span class="hljs-comment"># 元素作为块级元素显示，独占一行</span><br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">display: <span class="hljs-keyword">inline</span>; #  元素作为行内元素显示，不会独占一行，宽度根据内容自适应，无法设置宽高<br></code></pre></td></tr></table></figure><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">display: <span class="hljs-keyword">inline</span>-<span class="hljs-keyword">block</span><span class="hljs-punctuation">;</span> # 结合了 <span class="hljs-keyword">inline</span> 和 <span class="hljs-keyword">block</span> 的特性：元素本身在一行内显示，但又可以设置宽高，行为上类似块级盒子。<br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">display</span>: none; <span class="hljs-meta"># 元素不生成任何盒子，也不占据空间，相当于完全从页面中移除（但仍存在于 DOM 中）。</span><br></code></pre></td></tr></table></figure><p>布局上下文相关类型：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>: flex; # 将元素定义为弹性容器（<span class="hljs-attribute">flex</span> container），其子元素（<span class="hljs-attribute">flex</span> items）会按照弹性布局排列。该元素呈块级显示。 <br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>: inline-flex; # 与 <span class="hljs-attribute">flex</span> 类似，但容器本身作为行内元素显示。<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>: grid; # 将元素定义为网格容器（<span class="hljs-attribute">grid</span> container），子元素以二维网格方式排列。该元素呈块级显示。<br><span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);<br><span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">10px</span>;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>: inline-grid; # 类似 <span class="hljs-attribute">grid</span>，但容器本身呈行内显示。<br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">display</span>: flow-root; <span class="hljs-meta"># 父容器自动包裹浮动子元素，解决浮动元素导致的父容器高度塌陷问题，不破坏文档流</span><br></code></pre></td></tr></table></figure><p>表格相关显示类型：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">display</span>: table; # <span class="hljs-selector-tag">table</span>-row、<span class="hljs-selector-tag">table</span>-cell、<span class="hljs-selector-tag">table</span>-<span class="hljs-selector-tag">caption</span>、<span class="hljs-selector-tag">table</span>-row-group（模拟 &lt;<span class="hljs-selector-tag">tbody</span>&gt;）<br><span class="hljs-selector-tag">table</span>-<span class="hljs-selector-tag">header</span>-group（模拟 &lt;<span class="hljs-selector-tag">thead</span>&gt;）、<span class="hljs-selector-tag">table</span>-<span class="hljs-selector-tag">footer</span>-group（模拟 &lt;<span class="hljs-selector-tag">tfoot</span>&gt;）、<span class="hljs-selector-tag">table</span>-column、<span class="hljs-selector-tag">table</span>-column-group（用于列的布局）<br></code></pre></td></tr></table></figure><h2 id="5、行内和块级元素的区别"><a href="#5、行内和块级元素的区别" class="headerlink" title="5、行内和块级元素的区别"></a>5、行内和块级元素的区别</h2><p>行内：在一行内排列，宽度由内容决定，不能设置宽高。只能在水平方向设置margin和padding。</p><p>块级：独占一行，默认宽度是父容器的100%。可以设置宽高、垂直和水平方向的margin和padding。</p><h2 id="6、-隐藏元素的方法"><a href="#6、-隐藏元素的方法" class="headerlink" title="6、 隐藏元素的方法"></a>6、 隐藏元素的方法</h2><p>1、<code>display: none;</code> （不占用布局）</p><p>2、<code>visibility: hidden;</code> </p><p>3、<code>opacity: 0;</code>（可交互)</p><p>4、元素添加 <code>hidden</code> 属性 （不占用布局，类似 <code>display: none;</code>）</p><p>5、移出视口 （JS可操作、屏幕阅读器可阅读）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">position</span>: absolute;<br><span class="hljs-attribute">left</span>: -<span class="hljs-number">9999px</span>;<br></code></pre></td></tr></table></figure><p>6、裁剪</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">position</span>: absolute;<br><span class="hljs-attribute">clip</span>: <span class="hljs-built_in">rect</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>); # 过时<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">inset</span>(<span class="hljs-number">100%</span>);<br></code></pre></td></tr></table></figure><p>7、 z-index: 负值 （使其被其他元素覆盖）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">z-index</span>: -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>8、在水平方向和垂直方向都缩放为原来的 0 倍。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h2 id="7、link和-import的区别"><a href="#7、link和-import的区别" class="headerlink" title="7、link和@import的区别"></a>7、link和@import的区别</h2><p>HTML标签，通常在<code>head</code>内，直接链接外部CSS文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;styles.css&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>CSS的一种at-rule，通常在CSS文件顶部使用，导入其他样式表</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">@<span class="hljs-keyword">import</span> url(&#x27;style.css&#x27;)<br></code></pre></td></tr></table></figure><ul><li><p><strong>区别</strong></p><p><strong><code>&lt;link&gt;</code> 标签：</strong></p><ul><li>加载快、并行加载、兼容性好、适合全局引用。在解析 HTML 时就会发现 <code>&lt;link&gt;</code> 标签，并立即发起请求加载样式文件。</li></ul><p><strong><code>@import</code> 语句：</strong></p><ul><li>语法上更灵活，适用于模块化和条件加载，但可能带来额外延迟和性能问题，且兼容性在老版本浏览器上较差。当浏览器加载主样式表后，才会解析 <code>@import</code> 语句再加载其它样式表。</li></ul></li></ul><h2 id="8、display-none与visibility-hidden的区别"><a href="#8、display-none与visibility-hidden的区别" class="headerlink" title="8、display:none与visibility:hidden的区别"></a>8、display:none与visibility:hidden的区别</h2><ul><li><p><strong>布局和空间</strong> </p><p>display:none  元素会从文档流中完全移除，既不显示也不占据任何空间。</p><p>visibility:hidden 仍保留在文档流中，占据原有的布局空间。</p></li><li><p><strong>交互性</strong></p><p>display:none  不可交互，因为它们完全不参与页面渲染。</p><p>visibility:hidden  通常不可交互 </p></li><li><p><strong>DOM 结构</strong></p><p>无论使用哪种方式，元素依然保留在 DOM 结构中，可以通过 JavaScript 进行访问和操作（例如在需要时显示该元素）。</p></li><li><p><strong>继承属性</strong></p><p>display:none  非继承 父元素整个都不生成盒子，而其下所有内容也因此不会出现在页面上。</p><p>visibility:hidden 继承属性，子孙节点消失是由于继承了<code>hidden</code></p></li><li><p><strong>重排重绘</strong></p><p>display:none  造成文档的重排</p><p>visibility:hidden 造成元素的重绘</p></li><li><p><strong>屏幕阅读器</strong></p><p>display:none  不会被读取</p><p>visibility:hidden 不会被读取</p></li></ul><h2 id="9、伪元素和伪类的区别和作用"><a href="#9、伪元素和伪类的区别和作用" class="headerlink" title="9、伪元素和伪类的区别和作用"></a>9、伪元素和伪类的区别和作用</h2><p>1、伪元素:  选取元素中的某个部分或生成虚拟的内容</p><p><strong>常见伪元素：</strong></p><ul><li><code>::before</code>：在元素内容前插入内容。</li><li><code>::after</code>：在元素内容后插入内容。</li><li><code>::first-letter</code>：选择元素中第一个字母，用于设置首字母的特殊样式。</li><li><code>::first-line</code>：选择元素中第一行文本。</li></ul><p>2、伪类：描述元素在特定状态或条件下的样式</p><p><strong>常见伪类：</strong></p><ul><li><code>:hover</code>：当鼠标悬停在元素上时应用的样式。</li><li><code>:active</code>：当元素处于激活状态（例如点击时）应用的样式。</li><li><code>:focus</code>：当元素获得焦点时应用的样式。</li><li><code>:visited</code>：用于已访问过的链接。</li><li><code>:nth-child(n)</code>、<code>:first-child</code>、<code>:last-child</code> 等，用于选择特定位置的子元素。</li></ul><h2 id="10、对requestAnimationframe的理解"><a href="#10、对requestAnimationframe的理解" class="headerlink" title="10、对requestAnimationframe的理解"></a>10、对requestAnimationframe的理解</h2><p>由浏览器提供的API，用于高效执行动画和视觉更新。<code>requestAnimationFrame</code> 会自动调整调用频率，而且当页面处于后台（比如切换到了其他标签页）时，浏览器会暂停这些回调，节省资源。传统的 <code>setTimeout</code> 或 <code>setInterval</code> 固定时间调用函数，可能与浏览器的刷新时机不同步，从而导致动画卡顿或者多余的计算。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">div</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: antiquewhite;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>1111<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;box&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> pos = <span class="hljs-number">0</span>;</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params">timestamp</span>) &#123;</span><br><span class="language-javascript">      pos += <span class="hljs-number">1</span>;  <span class="hljs-comment">// 每帧增加一点位置</span></span><br><span class="language-javascript">      box.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = pos + <span class="hljs-string">&#x27;px&#x27;</span>;  <span class="hljs-comment">// 更新盒子的位置</span></span><br><span class="language-javascript">      <span class="hljs-title function_">requestAnimationFrame</span>(animate);  <span class="hljs-comment">// 请求下一帧</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-title function_">requestAnimationFrame</span>(animate);  <span class="hljs-comment">// 启动动画</span></span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>   <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>优点</p><p>与浏览器刷新率同步</p><p>降低 CPU 使用</p><p>平滑动画（由于回调执行时机与浏览器重绘周期一致，可以避免不必要的重排（reflow）和重绘（repaint），提升动画流畅度。）</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>选择器及优先级</tag>
      
      <tag>display</tag>
      
      <tag>行内和块级</tag>
      
      <tag>隐藏元素</tag>
      
      <tag>伪元素和伪类</tag>
      
      <tag>link和@import</tag>
      
      <tag>requestAnimationframe</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ServiceWorker</title>
    <link href="/2025/02/07/ServiceWorker/"/>
    <url>/2025/02/07/ServiceWorker/</url>
    
    <content type="html"><![CDATA[<h1 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h1><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502072222038.png" alt="image-20250207174059456"></p><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Service Worker 是一种在浏览器后台运行的脚本，与网页（主线程）完全分离。运行在独立线程中，不直接操作 DOM，而是通过事件机制与页面进行通信。它要求在 HTTPS 环境下运行（或 localhost 环境下开发）。</p><p>其主要作用包括：</p><p><strong>拦截网络请求</strong>：通过监听 <code>fetch</code> 事件，Service Worker 能够捕获页面的网络请求，返回缓存内容或自定义响应。</p><p><strong>离线支持</strong>：通过缓存静态资源，实现网络断线时依然可用的离线体验。</p><p><strong>后台任务</strong>：支持后台同步（Background Sync）和推送通知（Push Notifications），即使页面关闭也可处理一些任务。</p><h2 id="二、Service-Worker-注册"><a href="#二、Service-Worker-注册" class="headerlink" title="二、Service Worker 注册"></a>二、Service Worker 注册</h2><p>在使用 Service Worker 之前，需要在网页的主线程中注册它。</p><p>通常的注册代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;serviceWorker&#x27;</span> <span class="hljs-keyword">in</span> navigator)&#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;../JS/16_sw.js&#x27;</span>)<br>            .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">registration</span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Service Worker 注册成功，作用域：&#x27;</span>,registration.<span class="hljs-property">scope</span>);<br>        &#125;)<br>            .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Service Worker 注册失败：&#x27;</span>,error);<br>        &#125;)<br><br>    &#125;)<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;当前浏览器不支持 Service Worker。&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><p>检查 <code>serviceWorker</code> 是否存在于 <code>navigator</code> 对象中，确保浏览器支持该特性。</p></li><li><p>监听 <code>load</code> 事件确保页面资源加载完毕后再注册。</p></li><li><p><code>registration.scope</code> 表示 Service Worker 控制的范围。</p></li></ul><p><strong>?</strong> navigator是什么</p><blockquote><p> 是 <strong>JavaScript</strong> 中的一个全局对象，提供了关于浏览器和操作系统的有用信息。它通常用于访问浏览器的状态、用户的设备信息以及其他与浏览器相关的功能。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">navigator.<span class="hljs-keyword">user</span>Agent  <span class="hljs-comment"># 返回一个字符串，包含了浏览器的信息，如浏览器类型、版本、操作系统等</span><br></code></pre></td></tr></table></figure><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">navigator.platform <span class="hljs-meta">#  返回浏览器所在操作系统的名称。常见的返回值包括 <span class="hljs-string">&quot;Win32&quot;</span>, <span class="hljs-string">&quot;Linux x86_64&quot;</span>, <span class="hljs-string">&quot;MacIntel&quot;</span> 等。</span><br></code></pre></td></tr></table></figure><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">navigator.<span class="hljs-keyword">on</span>Line <span class="hljs-comment"># 返回一个布尔值，表示浏览器是否处于在线状态（即是否连接到互联网）</span><br></code></pre></td></tr></table></figure><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">navigator.language # 返回浏览器的首选语言设置。通常返回类似 <span class="hljs-keyword">en</span>-<span class="hljs-keyword">US</span>、zh-CN 这样的语言标识符。<br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">navigator.geolocation <span class="hljs-meta"># 是一个对象，提供定位服务。</span><br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">navigator.connection <span class="hljs-meta"># 提供网络连接的详细信息，如网络类型（Wi-Fi、4G等）和带宽。</span><br></code></pre></td></tr></table></figure><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">navigator.vendor <span class="hljs-meta"># 返回浏览器的供应商名，如 <span class="hljs-string">&quot;Google Inc.&quot;</span>、<span class="hljs-string">&quot;Apple Computer, Inc.&quot;</span> 等。</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">navigator<span class="hljs-selector-class">.cookieEnabled</span> / navigator<span class="hljs-selector-class">.plugins</span> / navigator<span class="hljs-selector-class">.deviceMemory</span>...<br></code></pre></td></tr></table></figure></blockquote><h2 id="三、Service-Worker-文件（sw-js）的代码示例"><a href="#三、Service-Worker-文件（sw-js）的代码示例" class="headerlink" title="三、Service Worker 文件（sw.js）的代码示例"></a>三、Service Worker 文件（sw.js）的代码示例</h2><h3 id="①-定义缓存名称和缓存资源列表"><a href="#①-定义缓存名称和缓存资源列表" class="headerlink" title="① 定义缓存名称和缓存资源列表"></a>① 定义缓存名称和缓存资源列表</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">const CACHE_NAME = <span class="hljs-string">&#x27;cache-v1&#x27;</span>;<br>const urlsToCache = [<br>    <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;/index.html&#x27;</span>,<br>    <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;/styles/main.css&#x27;</span>,<br>    <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;/scripts/main.js&#x27;</span>,<br>    <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;/images/logo.png&#x27;</span><br>]<br></code></pre></td></tr></table></figure><h3 id="②-安装事件-install"><a href="#②-安装事件-install" class="headerlink" title="② 安装事件 install"></a>② 安装事件 install</h3><p>安装阶段，会预缓存一些必要的资源。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;service worker installing&#x27;</span>);<br>    event.<span class="hljs-title function_">waitUntil</span>(<br>        caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CACHE_NAME</span>)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">cache</span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;打开缓存，准备缓存资源&#x27;</span>);<br>            <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">addAll</span>(urlsToCache) <span class="hljs-comment">// 将资源添加到缓存中</span><br>        &#125;)<br>    )<br>&#125;)<br></code></pre></td></tr></table></figure><p>**?**为什么要加上event.waitUntil</p><blockquote><p>默认情况下，Service Worker 的事件处理函数是 <strong>同步执行</strong> 的。如果直接把异步操作（比如缓存文件）放在事件处理函数中，事件处理器会继续执行，并且很快结束，而异步操作可能还没有完成。so，为了确保事件处理函数等待异步操作完成后才结束，保证了操作的完整性。</p></blockquote><p><strong>？</strong>caches是什么</p><blockquote><p> 是 <strong>Service Worker API</strong> 中的一个全局对象，<code>caches</code> 对象提供了几种常用的操作方法，比如：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">caches.<span class="hljs-built_in">open</span>(cacheName) <span class="hljs-comment"># 打开一个缓存，如果缓存不存在，则会创建一个新的缓存。返回一个 Promise，该 Promise 成功时会返回一个 Cache 对象。</span><br></code></pre></td></tr></table></figure><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">caches.match(<span class="hljs-built_in">request</span>) # 查找缓存中是否已经有与给定请求（<span class="hljs-built_in">request</span>）匹配的响应。如果找到，会返回一个 <span class="hljs-built_in">Response</span> 对象。<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">caches.<span class="hljs-keyword">delete</span>(cacheName) <span class="hljs-comment"># 删除指定名称的缓存。返回一个 Promise，表示删除操作的结果。</span><br></code></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">caches.has(cacheName) # 检查指定的缓存是否存在。返回一个 Promise，如果存在，Promise 会返回 <span class="hljs-literal">true</span>，否则返回 <span class="hljs-literal">false</span>。<br></code></pre></td></tr></table></figure></blockquote><h3 id="③-激活事件-activate"><a href="#③-激活事件-activate" class="headerlink" title="③ 激活事件 activate"></a>③ 激活事件 activate</h3><p>激活阶段通常用于清理旧版本缓存，确保客户端使用最新的资源。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;service worker activating&#x27;</span>);<br>    event.<span class="hljs-title function_">waitUntil</span>(<br>        caches.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<br>           <span class="hljs-keyword">function</span>(<span class="hljs-params">cacheNames</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<br>                cacheNames.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">cacheName</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(cacheName !== <span class="hljs-variable constant_">CACHE_NAME</span>)&#123;<br>                        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;删除旧缓存：&#x27;</span>,cacheName);<br>                        <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">delete</span>(cacheName); <br>                    &#125;<br>                &#125;)<br>            )<br>           &#125;<br>        )<br>    )<br>    <br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="④-拦截网络请求事件-fetch"><a href="#④-拦截网络请求事件-fetch" class="headerlink" title="④ 拦截网络请求事件 fetch"></a>④ 拦截网络请求事件 fetch</h3><p>通过监听 <code>fetch</code> 事件，Service Worker 可以拦截所有网络请求，并根据缓存情况返回相应资源，从而实现离线支持。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;fetch&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;拦截请求：&quot;</span>, event.<span class="hljs-property">request</span>.<span class="hljs-property">url</span>);<br>  event.<span class="hljs-title function_">respondWith</span>( <span class="hljs-comment">//让 Service Worker 对拦截的请求做出响应。</span><br>    caches<br>      .<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>) <span class="hljs-comment">// 检查请求是否已在缓存中。</span><br>      .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>        <span class="hljs-keyword">if</span> (response) &#123;<br>          <span class="hljs-keyword">return</span> response;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">netResponse</span>) &#123;<br>          <span class="hljs-comment">// 可选：动态缓存新的资源</span><br>          <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CACHE_NAME</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">cache</span>) &#123;<br>            <span class="hljs-comment">// 克隆响应后缓存，注意 response 只能使用一次</span><br>            cache.<span class="hljs-title function_">put</span>(event.<span class="hljs-property">request</span>, netResponse.<span class="hljs-title function_">clone</span>());<br>            <span class="hljs-keyword">return</span> netResponse;<br>          &#125;);<br>        &#125;);<br>      &#125;)<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err)<br>      &#125;)<br>  );<br>&#125;);<br><br></code></pre></td></tr></table></figure><p><strong>?</strong> response 只能使用一次什么意思</p><blockquote><p>在处理 HTTP 请求时，服务器的响应是一次性的。例如，收到一个 HTTP 响应后，你可以读取响应体、状态码等信息，但是如果你已经读取过响应体内容（比如通过 <code>.json()</code> 或 <code>.text()</code> 方法），这个响应体内容就不能再读取一次。第二次访问会抛出错误或返回 <code>null</code>，因为响应体已经被消耗了。这是因为大多数响应对象（比如 HTTP 响应）是 <strong>流式的</strong>，即数据是在网络传输过程中逐步到达的。读取数据时就会把它“消耗”掉，后续就无法再访问这些已经消耗的数据。为了避免重复读取，可以在获取数据时尽早存储一份副本。</p></blockquote><h3 id="⑤-后台同步-sync"><a href="#⑤-后台同步-sync" class="headerlink" title="⑤ 后台同步 sync"></a>⑤ 后台同步 sync</h3><p>后台同步允许在网络恢复时执行延迟的任务。使用示例如下（需浏览器支持 Sync API）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;sync&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">tag</span> === <span class="hljs-string">&quot;sync-tag&quot;</span>) &#123;<br>    event.<span class="hljs-title function_">waitUntil</span>(<br>      <span class="hljs-comment">// 这里放置需要在后台同步的任务，例如把离线保存的数据发送到服务器</span><br>      <span class="hljs-title function_">sendDataToServer</span>()<br>    );<br>  &#125;<br>&#125;);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendDataToServer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 模拟异步任务，如 fetch 请求</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/sync&#x27;</span>, &#123; <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; <span class="hljs-comment">/* data */</span> &#125;) &#125;);<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>？</strong> event.tag 是什么</p><blockquote><p>用来识别事件的类型或者标识某个特定的同步任务。后台同步允许在用户的网络连接恢复时，浏览器通过 Service Worker 自动发送请求来同步未完成的操作。例如，用户在离线时提交了一个表单，Service Worker 会将此请求保存并在恢复连接后进行同步。sync 事件会带有一个 tag，可以用它来区分不同的同步任务。</p></blockquote><h3 id="⑥-推送通知-push"><a href="#⑥-推送通知-push" class="headerlink" title="⑥ 推送通知 push"></a>⑥ 推送通知 push</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;push&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;接收到推送消息&#x27;</span>);<br>    <span class="hljs-keyword">const</span> data = event.<span class="hljs-property">data</span> ? event.<span class="hljs-property">data</span>.<span class="hljs-title function_">json</span>() : &#123;&#125;<br>    <span class="hljs-keyword">const</span> title = data.<span class="hljs-property">title</span> || <span class="hljs-string">&#x27;默认标题：安安第一棒！&#x27;</span><br>    <span class="hljs-keyword">const</span> options = &#123;<br>        <span class="hljs-attr">body</span>: data.<span class="hljs-property">body</span> || <span class="hljs-string">&#x27;默认消息&#x27;</span>,<br>        <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;../Images/cat.jpg&#x27;</span><br>    &#125;<br><br>    event.<span class="hljs-title function_">waitUntil</span>(<br>        self.<span class="hljs-property">registration</span>.<span class="hljs-title function_">showNotification</span>(title,options)<br>    )<br>    <br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="四、调试与注意事项"><a href="#四、调试与注意事项" class="headerlink" title="四、调试与注意事项"></a>四、调试与注意事项</h2><p><strong>调试</strong>：<br>现代浏览器（如 Chrome 和 Firefox）在开发者工具中提供了专门的 Service Worker 调试面板，可以查看注册情况、日志和缓存内容。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502072222956.png" alt="image-20250207221719935"></p><p><strong>HTTPS 环境</strong>：<br>Service Worker 仅在 HTTPS 环境下工作（或在 localhost 开发环境中），以确保安全性。</p><p><strong>注册</strong>：在主页面通过 <code>navigator.serviceWorker.register()</code> 注册 Service Worker 文件。</p><p><strong>生命周期</strong>：包括 <code>install</code>（安装、预缓存资源）、<code>activate</code>（激活、清理旧缓存）以及 <code>fetch</code>（拦截网络请求）等事件。Service Worker 的安装和激活可能需要一些时间，更新机制（如 <code>skipWaiting()</code> 和 <code>clients.claim()</code>）可以帮助加速新版本的激活，但也需要谨慎使用。</p>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>资源缓存</tag>
      
      <tag>安装事件</tag>
      
      <tag>激活事件</tag>
      
      <tag>拦截网络请求</tag>
      
      <tag>后台同步</tag>
      
      <tag>推送通知</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ApplicationCache</title>
    <link href="/2025/02/07/ApplicationCache/"/>
    <url>/2025/02/07/ApplicationCache/</url>
    
    <content type="html"><![CDATA[<h1 id="应用缓存-Application-Cache"><a href="#应用缓存-Application-Cache" class="headerlink" title="应用缓存(Application Cache)"></a>应用缓存(Application Cache)</h1><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502071714581.png" alt="image-20250207162900227"></p><h2 id="一、需求来源"><a href="#一、需求来源" class="headerlink" title="一、需求来源"></a>一、需求来源</h2><p>在 HTML5 出现之前，Web 应用主要依赖 Cookie 或服务器端技术来实现部分离线功能，但这两种方式都有明显的局限性（如容量小、同步性差等）。应用缓存旨在解决离线运行问题，使得用户即使在没有网络连接的情况下也能访问预先缓存好的静态资源，提升用户体验。</p><h2 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a>二、工作原理</h2><ul><li><p><strong>清单文件（manifest file）</strong></p><p>应用缓存的核心在于一个纯文本文件，通常以 <code>.appcache</code> 为后缀。这个文件列出了需要缓存的资源，以及一些额外的配置信息（如哪些资源不缓存、离线页面的替代方案等）。</p></li><li><p><strong>缓存机制</strong></p><p>浏览器在加载带有 manifest 属性的 HTML 页面时，会读取清单文件，并根据其中的配置将相应的资源缓存到本地。后续即使网络断开，浏览器也会从缓存中加载这些资源。</p></li></ul><h2 id="三、使用方法"><a href="#三、使用方法" class="headerlink" title="三、使用方法"></a>三、使用方法</h2><ul><li><p><strong>1、创建Manifest文件</strong></p><p>纯文本文件，通常以 <code>.appcache</code> 为后缀</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">CACHE MANIFEST <br><span class="hljs-comment"># 版本号或注释，用于强制更新缓存</span><br><span class="hljs-comment"># v1.0</span><br><br>CACHE:<br><span class="hljs-comment"># 列出需要缓存的资源</span><br>index.html<br>styles/main.css<br>scripts/app.js<br>images/logo.png<br><br>NETWORK<br><span class="hljs-comment"># 列出必须通过网络加载的资源（如果是*表示其他所有资源）</span><br>*<br><br>FALLBACK<br><span class="hljs-comment"># 当网络请求失败时的替代资源（格式：请求资源路径 空格 替代资源路径）</span><br>/ /offline.html<br></code></pre></td></tr></table></figure></li></ul><p><strong>？</strong>CACHE下罗列的文件路径是</p><blockquote><ul><li>如果路径以 <code>/</code> 开头，则它是 <strong>绝对路径</strong>，表示从网站根目录开始。</li><li>如果路径不以 <code>/</code> 开头，那么它是 <strong>相对路径</strong>，表示相对于 <code>manifest</code> 文件的路径。</li></ul></blockquote><ul><li><p><strong>2、在 HTML 中引用 Manifest</strong></p><p>为了启用应用缓存，需要在 HTML 文件的 <code>&lt;html&gt;</code> 标签上添加 <code>manifest</code> 属性，指向上述 manifest 文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">manifest</span>=<span class="hljs-string">&quot;demo.appcache&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>注意：</strong>manifest 文件需要设置正确的 MIME-type，即 “text&#x2F;cache-manifest”。必须在 web 服务器上进行配置。</p><h2 id="四、缓存更新机制"><a href="#四、缓存更新机制" class="headerlink" title="四、缓存更新机制"></a>四、缓存更新机制</h2><ul><li><strong>版本管理</strong>：由于 manifest 文件是纯文本格式，所以通常在文件中添加注释或版本号来控制缓存更新。每次当 manifest 文件内容（包括注释）发生变化时，浏览器都会认为缓存需要更新，并重新下载所有资源。</li><li><strong>更新时机</strong>：更新检测通常在页面加载时自动进行，也可以通过 JavaScript 监听相关事件（如 <code>updateready</code>、<code>cached</code>、<code>noupdate</code> 等）来处理缓存更新逻辑。</li></ul><h2 id="五、优缺点"><a href="#五、优缺点" class="headerlink" title="五、优缺点"></a>五、优缺点</h2><ul><li><p><strong>优点</strong></p><p><strong>离线访问</strong>：用户即使在无网络状态下也能访问 Web 应用的基本功能。</p><p><strong>性能提升</strong>：缓存资源可以加快页面加载速度，减少对服务器的请求。</p></li><li><p><strong>缺点和限制</strong></p><p><strong>更新复杂性</strong>：由于浏览器检测缓存更新的机制相对简单，只要 manifest 文件内容有任何变化，就会触发全部资源的重新下载，可能导致更新不够灵活或出现意外的缓存问题。</p><p><strong>调试困难</strong>：在开发过程中，缓存机制有时会导致调试变得复杂，因为即使修改了资源，浏览器可能仍然使用旧的缓存文件。</p><p><strong>细粒度控制不足</strong>：应用缓存对资源的管理方式较为粗粒度，不能针对单个资源进行灵活的缓存控制。</p><p><strong>替代方案出现</strong>：由于上述缺点，W3C 后来推出了更强大、更灵活的 Service Worker 及其 Cache API，能够更精细地控制缓存行为，取代了应用缓存的许多功能。</p></li></ul><h2 id="六、被弃用"><a href="#六、被弃用" class="headerlink" title="六、被弃用"></a>六、被弃用</h2><p>由于设计缺陷和使用上的诸多问题，应用缓存已经被广泛认为是一个过时的技术。目前大部分现代 Web 应用已经转向使用 Service Worker 来实现离线缓存与离线体验。</p><p><strong>未来方向</strong>：Service Worker 提供了更加灵活和精细的离线缓存控制能力，允许开发者编写脚本来决定缓存哪些资源、如何更新缓存，以及在离线时如何响应网络请求，因此成为构建渐进式 Web 应用（PWA）的核心技术之一。</p>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>manifest file</tag>
      
      <tag>离线运行</tag>
      
      <tag>缓存更新</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode10：和为K的数组</title>
    <link href="/2025/02/07/LeetCode10/"/>
    <url>/2025/02/07/LeetCode10/</url>
    
    <content type="html"><![CDATA[<h1 id="10-和为K的数组"><a href="#10-和为K的数组" class="headerlink" title="10.和为K的数组"></a>10.和为K的数组</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p><p>子数组是数组中元素的连续非空序列。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,1,1], k = 2</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,2,3], k = 3</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-107 &lt;= k &lt;= 107</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li><p><strong>子数组是数组中连续的一段元素。</strong></p><p>例如，对于数组 <code>nums = [a, b, c, d]</code>，以下都是子数组：</p><ul><li><code>[a]</code></li><li><code>[a, b]</code></li><li><code>[b, c, d]</code></li><li><code>[c]</code></li></ul><p>注意：子数组要求连续，因此 <code>[a, c]</code> 不是子数组，因为中间缺了 <code>b</code>。</p></li></ul><h3 id="一、暴力枚举"><a href="#一、暴力枚举" class="headerlink" title="一、暴力枚举"></a><strong>一、暴力枚举</strong></h3><p>由于子数组的长度不确定，无法确定是由几个数字求得的K，采用暴力枚举，尝试所有可能。需要确定起点和终点：</p><p><strong>外层循环确定子数组的起点</strong>：假设数组的长度为 n，我们可以让起点 <code>i</code> 从 0 到 n-1 遍历。</p><p><strong>内层循环确定子数组的结束点</strong>：<br>对于固定起点 <code>i</code>，结束点 <code>j</code> 从 <code>i</code> 开始遍历到 n-1。这样可以确保子数组是连续的，即子数组为 <code>nums[i]</code> 到 <code>nums[j]</code>（包含两端）。</p><p><strong>计算子数组的和</strong>：<br>对于每个确定的起点 <code>i</code> 和结束点 <code>j</code>，计算子数组 <code>[nums[i], nums[i+1], ..., nums[j]]</code> 的和，并检查是否等于 k。如果等于 k，则计数器加 1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-comment"># 暴力枚举</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subarraySum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>):<br>        length = <span class="hljs-built_in">len</span>(nums)<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length):<br>            cur_sum = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i,length):<br>                cur_sum += nums[j]  <span class="hljs-comment"># 第一个和是0加上起点</span><br>                <span class="hljs-keyword">if</span> cur_sum == k:<br>                    count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure><h3 id="二、前缀和-哈希表（优化）"><a href="#二、前缀和-哈希表（优化）" class="headerlink" title="二、前缀和+哈希表（优化）"></a>二、前缀和+哈希表（优化）</h3><p>子数组的和可以通过两个前缀和的差来计算。这是一种常见的算法技巧：如果我们维护每个索引的前缀和，那么对于每个索引，可以通过哈希表快速查找之前存在的前缀和（即当前前缀和减去k）。这种方法将时间复杂度从O(n^2)降低到O(n)。</p><ul><li><p><strong>思路概述</strong></p><ol><li><p><strong>前缀和</strong><br>定义 <code>prefix[i]</code> 为从数组开始到第 i 个元素（包含 i）的和。</p><p>对于任意子数组 <code>nums[i..j]</code>，其和为：<code>sum(i,j)=prefix[j]-prefix[i-1]</code>。</p><p>特别地，令 <code>prefix[-1] = 0</code>。</p></li><li><p><strong>转换问题</strong><br>若要求 <code>prefix[j] - prefix[i-1] = k</code>，则可以转换为：<code>prefix(i-1)=prefix[j]-k</code>。</p><p>也就是说，当遍历到第 <code>j</code> 个元素时，如果之前存在某个前缀和等于 <code>prefix[j] - k</code>，则从该位置之后到 <code>j</code> 的子数组之和为 <code>k</code>。</p></li><li><p><strong>使用哈希表记录前缀和出现次数</strong></p><ul><li>初始化哈希表（例如 Python 中的字典），令 <code>prefix_count[0] = 1</code>，表示空前缀和 0 出现一次。</li><li>遍历数组，累计前缀和 <code>prefix_sum</code>，并检查 <code>prefix_sum - k</code> 是否在哈希表中出现过，若出现过，则将对应的次数累加到结果中。</li><li>最后更新哈希表中当前前缀和 <code>prefix_sum</code> 的出现次数。</li></ul></li></ol><p>这样可以将时间复杂度降低到 O(n)。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">subarraySum</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], k: <span class="hljs-built_in">int</span></span>):<br>        prefix_sum = <span class="hljs-number">0</span><br>        prefix_count = &#123;<span class="hljs-number">0</span>:<span class="hljs-number">1</span>&#125; <span class="hljs-comment"># 哈希表：键为前缀和，值为出现的次数，初始时 0 出现 1 次</span><br>        count = <span class="hljs-number">0</span><br>        <br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>            prefix_sum += num<br>            <span class="hljs-keyword">if</span> prefix_sum - k <span class="hljs-keyword">in</span> prefix_count:<br>                count += prefix_count[prefix_sum-k]<br>            prefix_count[prefix_sum] = prefix_count.get(prefix_sum,<span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br>            <br>        <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li><p>子数组是否考虑去重？</p><blockquote><p>由题目给的示例，不需要。只要和为k都计入。</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,1,1], k = 2</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>prefix_count字典的作用？</p><blockquote><p>用于记录遍历数组过程中，每个前缀和出现的次数。</p><p>因为在遍历到索引<code>j</code>时，计算当前的前缀和<code>prefix_sum</code>，再从字典查找是否存在<code>prefix_sum - k</code>，字典中存储了该前缀和出现的次数，就可以直接累加到最终的计数中。</p></blockquote></li><li><p>初始化{0:1}的作用</p><p>相当于一个虚拟的起点。因为在开始累加前，前缀和必定是 0。只有在累加过程中，当前缀和等于 k 时，通过 <code>prefix_sum - k = 0</code> 查找，才能正确计数那些从数组起始开始的满足条件的子数组。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>题库</tag>
      
      <tag>哈希表</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebWorker</title>
    <link href="/2025/02/06/WebWorker/"/>
    <url>/2025/02/06/WebWorker/</url>
    
    <content type="html"><![CDATA[<h1 id="WebWorker（HTML5新引入技术）"><a href="#WebWorker（HTML5新引入技术）" class="headerlink" title="WebWorker（HTML5新引入技术）"></a>WebWorker（HTML5新引入技术）</h1><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502062245909.png" alt="image-20250206211458551"></p><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>JS 在浏览器中默认运行在单线程环境中，所有任务（渲染、事件处理等）都在同一线程上执行。如果某个任务耗时过长，就可能导致页面冻结、响应迟缓。Web Worker允许我们创建新的线程，专门用来处理耗时任务，从而避免主进程被阻塞。</p><h2 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a>二、工作原理</h2><p>Web Worker 与主线程之间采用<strong>消息传递</strong>进行通信。主线程与 Worker 线程之间不能共享同一上下文（例如不能直接访问 Dom）。只能通过<code>postMessage</code>方法传递消息，Worker 接收到消息后，通过<code>onMessage</code>事件处理消息，返回结果。</p><p><strong>？</strong>什么叫做不能共享同一上下文？</p><blockquote><p>上下文是指在特定环境中执行的代码和能够访问的资源。在浏览器中，主线程的上下文包括对DOM的访问、事件处理、UI渲染等。Worker 线程的上下文是独立的，没有访问DOM的能力，也无法直接和主线程共享变量、对象等。Worker 线程主要用于 计算密集型任务，例如数据处理、文件读取等，执行这些任务时并不需要与 DOM 交互，因此将它们隔离开有助于性能优化。</p></blockquote><h2 id="三、多种类型"><a href="#三、多种类型" class="headerlink" title="三、多种类型"></a>三、多种类型</h2><p><strong>Dedicated Worker（专用工作者）</strong><br>最常见的Worker类型，专门为主线程（调用它的脚本）服务，每个Worker只能由一个主线程使用。主线程和Worker通过postMessage()和onmessage进行通信。</p><ul><li><strong>1、创建专用Worker脚本</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// worker.js 后台执行的代码</span><br><span class="hljs-comment">// 监听来自主线程的消息</span><br>self.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Worker received:&#x27;</span>, event.<span class="hljs-property">data</span>);<br>  <span class="hljs-comment">// 执行一些耗时操作，比如计算斐波那契数列</span><br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">fibonacci</span>(event.<span class="hljs-property">data</span>);<br>  <span class="hljs-comment">// 将结果发送回主线程</span><br>  self.<span class="hljs-title function_">postMessage</span>(result);<br>&#125;;<br><br><span class="hljs-comment">// 一个简单的递归函数来计算斐波那契数列（注意：实际项目中应避免递归带来的性能问题）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fibonacci</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-title function_">fibonacci</span>(n - <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>2、在主线程中创建Worker实例</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-comment">// 创建 Worker 对象，指定 worker.js 为执行脚本</span><br><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;worker.js&#x27;</span>);<br><span class="hljs-comment">// 发送消息给 Worker，开始计算</span><br>worker.<span class="hljs-title function_">postMessage</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 比如计算 fibonacci(10)</span><br><span class="hljs-comment">// 接收 Worker 发回的消息</span><br>worker.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Result from worker:&#x27;</span>, event.<span class="hljs-property">data</span>);<br>&#125;;<br><span class="hljs-comment">// 错误处理</span><br>worker.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Worker error:&#x27;</span>, error);<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>3、终止 Worker</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">worker.<span class="hljs-title function_">terminate</span>();<br></code></pre></td></tr></table></figure><p><strong>Shared Worker（共享工作者）</strong><br>允许多个脚本（甚至来自不同窗口、iframe 或 web worker）共享一个 Worker 实例，通过共享的通信端口（MessagePort）进行交互。允许多个 JavaScript 线程（例如多个网页窗口）与一个 Worker 进行通信，适合多个页面或多个上下文间共享资源和数据的情况。共享 Worker 的生命周期由浏览器管理，当所有连接的页面关闭时，Worker 才会结束运行。</p><ul><li><strong>创建共享Worker脚本</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// sharedWorker.js</span><br><span class="hljs-comment">// 用于保存所有连接的 MessagePort 对象</span><br><span class="hljs-keyword">var</span> connections = [];<br><span class="hljs-comment">// 当有新的连接建立时，会触发 onconnect 事件</span><br>onconnect = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-comment">// e.ports 是一个数组，通常只有一个端口</span><br>  <span class="hljs-keyword">var</span> port = e.<span class="hljs-property">ports</span>[<span class="hljs-number">0</span>];<br>  connections.<span class="hljs-title function_">push</span>(port);<br><br>  <span class="hljs-comment">// 监听来自页面的消息</span><br>  port.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;SharedWorker 收到消息:&#x27;</span>, event.<span class="hljs-property">data</span>);<br>    <br>    <span class="hljs-comment">// 示例：将收到的消息广播给所有连接的页面</span><br>    connections.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">p</span>) &#123;<br>      p.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Worker 广播: &#x27;</span> + event.<span class="hljs-property">data</span>);<br>    &#125;);<br>  &#125;;<br><br>  <span class="hljs-comment">// 可选：监听 port 的关闭等事件</span><br>  port.<span class="hljs-property">onclose</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 这里可以实现移除断开的 port</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Port 关闭&#x27;</span>);<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>使用共享 Worker</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>共享 Worker 示例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>共享 Worker 示例<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 创建共享 Worker 实例，注意路径与文件名要正确</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">var</span> mySharedWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedWorker</span>(<span class="hljs-string">&#x27;sharedWorker.js&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 获取通信端口并启动通信通道</span></span></span><br><span class="language-javascript"><span class="language-xml">    mySharedWorker.<span class="hljs-property">port</span>.<span class="hljs-title function_">start</span>(); <span class="hljs-comment">// 某些浏览器可能自动启动，也可以不调用，但为了保险建议调用</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 发送消息到共享 Worker</span></span></span><br><span class="language-javascript"><span class="language-xml">    mySharedWorker.<span class="hljs-property">port</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Hello from 页面1&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 监听来自共享 Worker 的消息</span></span></span><br><span class="language-javascript"><span class="language-xml">    mySharedWorker.<span class="hljs-property">port</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;页面1收到消息:&#x27;</span>, event.<span class="hljs-property">data</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 示例：可以添加按钮，点击后向 Worker 发送消息</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// document.getElementById(&#x27;sendBtn&#x27;).onclick = function() &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//   mySharedWorker.port.postMessage(&#x27;点击按钮发送的消息&#x27;);</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// &#125;;</span></span></span><br><span class="language-javascript"><span class="language-xml">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>Service Worker（服务工作者）</strong><br>与传统的 Worker 不同，Service Worker 是一种特殊类型的 Web Worker，通常用于拦截网络请求、实现离线缓存、消息推送等功能。与传统的 Worker 不同，它的生命周期并不与浏览器页面绑定，而是与整个网站相关联。主要与浏览器的主线程和 Web 页面进行交互。它还可以处理浏览器的网络请求，拦截和缓存请求。运行在浏览器的独立线程中，不依赖于网页的生命周期，即使网页关闭，也可以继续运行（直至被浏览器回收）。</p><ul><li><p><strong>生命周期</strong></p><ul><li><strong>安装（install）</strong>：初次注册或更新时触发，可用于缓存静态资源。</li><li><strong>激活（activate）</strong>：安装完成后触发，通常用于清理旧缓存或旧版本数据。</li><li><strong>闲置（idle）</strong>：在不拦截请求时进入闲置状态。</li></ul></li><li><p><strong>注册Service Worker</strong></p><p>在网页的主线程中，通过 <code>navigator.serviceWorker.register()</code> 方法注册 Service Worker 脚本。注册后，浏览器会下载、安装并激活 Service Worker。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 主线程</span><br><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;serviceWorker&#x27;</span> <span class="hljs-keyword">in</span> navigator) &#123;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;/serviceWorker.js&#x27;</span>)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">registration</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Service Worker 注册成功，作用域:&#x27;</span>, registration.<span class="hljs-property">scope</span>);<br>      &#125;)<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Service Worker 注册失败:&#x27;</span>, error);<br>      &#125;);<br>  &#125;);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;当前浏览器不支持 Service Worker&#x27;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p><strong>Service Worker 脚本</strong></p><p>在安装阶段，可以预缓存一些必要的静态资源，这样即使在离线时也可以快速加载页面。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义缓存名称和要缓存的资源列表</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_NAME</span> = <span class="hljs-string">&#x27;my-site-cache-v1&#x27;</span>;<br><span class="hljs-keyword">const</span> urlsToCache = [<br>  <span class="hljs-string">&#x27;/&#x27;</span>,<br>  <span class="hljs-string">&#x27;/styles/main.css&#x27;</span>,<br>  <span class="hljs-string">&#x27;/script/main.js&#x27;</span>,<br>  <span class="hljs-string">&#x27;/images/logo.png&#x27;</span><br>];<br><span class="hljs-comment">// self 指向 Service Worker 的全局作用域</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Service Worker 正在安装...&#x27;</span>);<br>  <span class="hljs-comment">// 预缓存资源</span><br>  event.<span class="hljs-title function_">waitUntil</span>( <span class="hljs-comment">// 让浏览器等待缓存操作完成后再认为安装成功。</span><br>    caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CACHE_NAME</span>) <span class="hljs-comment">//  打开一个缓存容器</span><br>      .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">cache</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;打开缓存&#x27;</span>);<br>        <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">addAll</span>(urlsToCache);<span class="hljs-comment">// 一次性添加多个资源</span><br>      &#125;)<br>  );<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li><p><strong>激活阶段</strong></p><p>激活阶段通常用于清理旧的缓存或执行其他更新任务。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Service Worker 激活中...&#x27;</span>);<br>  <span class="hljs-comment">// 定义白名单，保留当前缓存的名称</span><br>  <span class="hljs-keyword">const</span> cacheWhitelist = [<span class="hljs-variable constant_">CACHE_NAME</span>];<br>  event.<span class="hljs-title function_">waitUntil</span>(<br>    caches.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">cacheNames</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<br>        cacheNames.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">cacheName</span>) &#123;<br>          <span class="hljs-keyword">if</span> (cacheWhitelist.<span class="hljs-title function_">indexOf</span>(cacheName) === -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 删除不在白名单中的旧缓存</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;删除缓存:&#x27;</span>, cacheName);<br>            <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">delete</span>(cacheName);<br>          &#125;<br>        &#125;)<br>      );<br>    &#125;)<br>  );<br>&#125;);<br><br></code></pre></td></tr></table></figure><ul><li><p><strong>拦截网络请求（fetch 事件）</strong></p><p>Service Worker 最重要的功能之一就是拦截网络请求，并决定返回缓存数据或网络数据。监听 <code>fetch</code> 事件后，使用 <code>event.respondWith()</code> 直接提供一个响应。先查找缓存中是否存在请求的资源，如果存在则返回缓存内容；否则，执行网络请求。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;拦截请求:&#x27;</span>, event.<span class="hljs-property">request</span>.<span class="hljs-property">url</span>);<br>  event.<span class="hljs-title function_">respondWith</span>(<br>    caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) &#123;<br>        <span class="hljs-comment">// 如果缓存中有匹配的资源，直接返回缓存</span><br>        <span class="hljs-keyword">if</span> (response) &#123;<br>          <span class="hljs-keyword">return</span> response;<br>        &#125;<br>        <span class="hljs-comment">// 否则，通过网络请求获取资源</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(event.<span class="hljs-property">request</span>);<br>      &#125;)<br>  );<br>&#125;);<br><br></code></pre></td></tr></table></figure><ul><li><strong>进阶用法</strong></li></ul><p>1 离线体验</p><p>通过上述缓存策略，用户在离线时依然可以加载部分预缓存的页面和资源。开发者还可以扩展逻辑，当网络请求失败时返回离线页面或自定义错误页面。</p><p>2 后台同步和推送通知</p><ul><li><strong>后台同步（Background Sync）</strong><br>Service Worker 可以在网络恢复后自动同步数据。需要借助 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/SyncManager">SyncManager API</a> 实现。</li><li><strong>推送通知（Push Notifications）</strong><br>结合 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API">Push API</a> 与 Service Worker，可以实现消息推送，即使网页未打开也能收到通知。</li></ul><p>3 与页面通信</p><p>通过 <code>postMessage</code> 方法，可以在 Service Worker 和网页之间进行双向通信。例如，当缓存更新时通知页面刷新数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">self.<span class="hljs-property">clients</span>.<span class="hljs-title function_">matchAll</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">clients</span>) &#123;<br>  clients.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">client</span>) &#123;<br>    client.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;缓存已更新，请刷新页面&#x27;</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h2><ul><li><strong>不支持 DOM 操作</strong><br>由于 Worker 运行在独立的线程中，它没有访问 DOM、window 对象或 document 对象的权限。如果需要更新 UI，必须通过消息将结果传回主线程，然后在主线程中进行 DOM 操作。</li><li><strong>同源策略</strong><br>Worker 脚本必须遵循同源策略（同一协议、域名、端口）。跨域加载 Worker 脚本需要额外配置 CORS。</li><li><strong>调试困难</strong><br>由于 Worker 在单独的线程中运行，调试时可能会比主线程稍微复杂一些，但现代浏览器大多已经支持 Worker 的调试功能。</li><li><strong>数据传输</strong><br>消息传递过程中的数据会被序列化（通过结构化克隆算法），因此有些数据类型（如函数、DOM 节点等）无法传递。如果数据量特别大，可以考虑使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Transferable">Transferable Objects</a> 来避免不必要的复制，提高效率。</li><li><strong>错误处理</strong><br>Worker 中发生的错误不会直接抛出到主线程，需要通过 <code>onerror</code> 事件监听进行捕获和处理。</li></ul><h2 id="五、使用场景"><a href="#五、使用场景" class="headerlink" title="五、使用场景"></a>五、使用场景</h2><ul><li><strong>计算密集型任务</strong><br>如复杂数学计算、大量数据处理、图像处理、音视频编解码等，可以将这些任务放在 Worker 中执行，避免页面卡顿。</li><li><strong>数据处理和预处理</strong><br>例如在接收到网络数据后进行预处理，然后再传回主线程进行显示。</li><li><strong>离线缓存和网络拦截</strong><br>通过 Service Worker 实现离线访问、网络请求缓存、后台数据同步等功能。</li><li><strong>多窗口&#x2F;标签页共享数据</strong><br>共享 Worker 可以在多个页面之间共享数据和状态，实现进程间通信。</li></ul>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>性能优化</tag>
      
      <tag>WebWorker</tag>
      
      <tag>消息传递</tag>
      
      <tag>独立线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT09：数字黑洞</title>
    <link href="/2025/02/06/PAT09/"/>
    <url>/2025/02/06/PAT09/</url>
    
    <content type="html"><![CDATA[<h1 id="9-数字黑洞"><a href="#9-数字黑洞" class="headerlink" title="9.数字黑洞"></a>9.数字黑洞</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序，然后用第1个数字减第2个数字，将得到</span><br> <span class="hljs-string">一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。</span><br> <br> <span class="hljs-string">例如，我们从6767开始，将得到</span><br> <br> <span class="hljs-number">7766</span> <span class="hljs-bullet">-</span> <span class="hljs-number">6677</span> <span class="hljs-string">=</span> <span class="hljs-number">1089</span><br> <span class="hljs-number">9810</span> <span class="hljs-bullet">-</span> <span class="hljs-number">0189</span> <span class="hljs-string">=</span> <span class="hljs-number">9621</span><br> <span class="hljs-number">9621</span> <span class="hljs-bullet">-</span> <span class="hljs-number">1269</span> <span class="hljs-string">=</span> <span class="hljs-number">8352</span><br> <span class="hljs-number">8532</span> <span class="hljs-bullet">-</span> <span class="hljs-number">2358</span> <span class="hljs-string">=</span> <span class="hljs-number">6174</span><br> <span class="hljs-number">7641</span> <span class="hljs-bullet">-</span> <span class="hljs-number">1467</span> <span class="hljs-string">=</span> <span class="hljs-number">6174</span><br> <span class="hljs-string">...</span> <span class="hljs-string">...</span><br> <br> <span class="hljs-string">现给定任意4位正整数，请编写程序演示到达黑洞的过程。</span><br></code></pre></td></tr></table></figure><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入给出一个[<span class="hljs-number">1000</span>, <span class="hljs-number">10000</span>)区间内的正整数<span class="hljs-built_in">N</span>。<br></code></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">如果<span class="hljs-built_in">N</span>的<span class="hljs-number">4</span>位数字全相等，则在一行内输出“<span class="hljs-built_in">N</span> - <span class="hljs-built_in">N</span> = <span class="hljs-number">0000</span>”；否则将计算的每一步在一行内输出，直到<span class="hljs-number">6174</span>作为差出现，输出格式见样例,每行中间没有空行。注意每个数字按<span class="hljs-number">4</span>位数格<br> 式输出。<br></code></pre></td></tr></table></figure><h3 id="输入例子"><a href="#输入例子" class="headerlink" title="输入例子:"></a><strong>输入例子:</strong></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">6767</span><br></code></pre></td></tr></table></figure><h3 id="输出例子"><a href="#输出例子" class="headerlink" title="输出例子:"></a><strong>输出例子:</strong></h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7766 </span>- <span class="hljs-number">6677</span> = <span class="hljs-number">1089</span><br><span class="hljs-symbol">9810 </span>- <span class="hljs-number">0189</span> = <span class="hljs-number">9621</span><br><span class="hljs-symbol">9621 </span>- <span class="hljs-number">1269</span> = <span class="hljs-number">8352</span><br><span class="hljs-symbol">8532 </span>- <span class="hljs-number">2358</span> = <span class="hljs-number">6174</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li><p><strong>输入与处理</strong></p><p>首先，要考虑输入的读取，使用<code>input</code>方法读取的是字符串类型。如果不满4位，需要使用字符串的<code>zfill</code>方法进行补齐。</p></li><li><p><strong>字符串排序</strong></p><p>使用<code>sort</code>方法对4位字符串进行排序，默认是非递减。使用参数<code>reverse=True</code>，得到非递增。</p></li><li><p><strong>差值计算</strong></p><p>将排序后的字符串使用<code>int</code>转换为整数，相减得到结果。</p></li><li><p><strong>格式化输出</strong></p><p>根据题目的格式进行输出，再利用递归，将输出作为下一步的输入再判断。</p></li><li><p><strong>边界条件</strong></p><p>如果输入字符串的4位数字均相等，则做特殊输出：’N - N &#x3D; 0000’。</p><p>如果输入为目标字符串6147，则终止递归。（特殊情况，如果第一次输入是6147需计算一次）</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">num,count</span>):<br>    num = num.zfill(<span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(num) == <span class="hljs-number">6174</span>:<br>        <span class="hljs-keyword">if</span> count != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> num[<span class="hljs-number">0</span>]==num[<span class="hljs-number">1</span>]==num[<span class="hljs-number">2</span>]==num[<span class="hljs-number">3</span>]:<br>        <span class="hljs-built_in">print</span>(num+<span class="hljs-string">&#x27; - &#x27;</span>+num+<span class="hljs-string">&#x27; = 0000 &#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    max_com = <span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-built_in">sorted</span>(num,reverse=<span class="hljs-literal">True</span>))<br>    min_com = <span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-built_in">sorted</span>(num))<br>    resTmp = <span class="hljs-built_in">int</span>(max_com) - <span class="hljs-built_in">int</span>(min_com)<br>    <span class="hljs-built_in">print</span>(max_com+<span class="hljs-string">&#x27; - &#x27;</span>+min_com+<span class="hljs-string">&#x27; = &#x27;</span>+<span class="hljs-built_in">str</span>(resTmp))<br>    count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> func(<span class="hljs-built_in">str</span>(resTmp),count)<br>    <br>num = <span class="hljs-built_in">input</span>()<br>count = <span class="hljs-number">0</span><br>func(num,count)<br><span class="hljs-comment"># func(&#x27;6214&#x27;)</span><br><br></code></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><strong>输入的读取</strong></p><blockquote><p>1、input()方法：读取一行输入，返回的是字符串类型，去掉了换行符。</p><p>2、sys.stdin文件对象（不会自动转换类型、包含换行符）：</p><ul><li>read()方法：读取所有输入</li><li>readline()方法：读取一行输入</li></ul></blockquote><p><strong>字符串补齐</strong></p><blockquote><p>1、zfill()方法（使用0填充）：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">s = <span class="hljs-string">&quot;42&quot;</span><br>s = s.zfill(4)<br>print(s) <span class="hljs-comment"># 0042</span><br></code></pre></td></tr></table></figure><p>2、 rjust()方法（可指定字符填充）:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">s = <span class="hljs-string">&quot;42&quot;</span><br>s = s<span class="hljs-selector-class">.rjust</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;2&quot;</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(s)</span></span><br></code></pre></td></tr></table></figure><p>3、使用 f-string方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;42&quot;</span><br>s = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;<span class="hljs-built_in">int</span>(s):04d&#125;</span>&quot;</span>  <span class="hljs-comment"># 04d 表示至少 4 位，不足的地方用零填充</span><br><span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure><p>可以填充的为0和空格。04中的0表示填充字符，4表示填充到哪个宽度。</p><p>还可以选择填充后的对齐：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">f&quot;<span class="hljs-subst">&#123;<span class="hljs-number">5</span>:&lt;4d&#125;</span>&quot;</span>  <span class="hljs-comment"># 左对齐</span><br><span class="hljs-string">f&quot;<span class="hljs-subst">&#123;<span class="hljs-number">5</span>:&gt;4d&#125;</span>&quot;</span>  <span class="hljs-comment"># 右对齐</span><br><span class="hljs-string">f&quot;<span class="hljs-subst">&#123;<span class="hljs-number">5</span>:^4d&#125;</span>&quot;</span>  <span class="hljs-comment"># 居中对齐</span><br></code></pre></td></tr></table></figure><p>常见的类型转换符：</p><ul><li>**<code>d</code>**：整数（decimal）</li><li>**<code>f</code>**：浮动小数点数</li><li>**<code>s</code>**：字符串</li><li>**<code>x</code>**：十六进制整数（小写）</li><li>**<code>X</code>**：十六进制整数（大写）</li><li>**<code>e</code>**：科学计数法表示的浮动小数</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>题库</tag>
      
      <tag>字符串排序</tag>
      
      <tag>字符串填充</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML知识点（三）</title>
    <link href="/2025/02/05/HTML%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2025/02/05/HTML%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML知识点（三）"><a href="#HTML知识点（三）" class="headerlink" title="HTML知识点（三）"></a>HTML知识点（三）</h1><h2 id="1、Canvas和SVG的区别"><a href="#1、Canvas和SVG的区别" class="headerlink" title="1、Canvas和SVG的区别"></a>1、Canvas和SVG的区别</h2><ul><li><p><strong>Canvas</strong></p><p>使用是基于像素（位图）的绘图方式。当调用绘图API时，实际是在对一个固定分辨率的像素矩阵进行修改，绘制完成后，这个矩阵的状态就保存在Canvas中。后续的每一次绘制都是在当前画布进行重新绘制。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCanvas&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border:2px aqua solid;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span>  canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#myCanvas&#x27;</span>)</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&#x27;2d&#x27;</span>)</span><br><span class="language-javascript">        ctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&#x27;green&#x27;</span></span><br><span class="language-javascript">        ctx.<span class="hljs-title function_">fillRect</span>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">210</span>,<span class="hljs-number">20</span>)</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>SVG</strong></p><p>使用的是矢量图形，所有的图形都是由数学公式描述的。图形是无分辨率的，可以无限放大缩小而不会失真。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border:2px aqua solid;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;40&quot;</span> <span class="hljs-attr">stroke</span>=<span class="hljs-string">&quot;green&quot;</span> <span class="hljs-attr">stroke-width</span>=<span class="hljs-string">&quot;4&quot;</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;yellow&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>它们的区别</strong></p><p>1、渲染模式：</p><p>canvas：即时渲染。绘图指令会立即影响画布像素，所有元素成为一个整体的像素图，若改变图形，往往需要清空画布然后重新绘制所有元素。</p><p>svg：保留模式。每个图形元素是一个DOM节点，浏览器维护节点信息。需要修改图形只需要更新对应的DOM节点，不必重新绘制整个画面。</p><p>2、交互性：</p><p>canvas：无法对单个图形元素绑定事件，需要手动进行坐标计算，给整个canvas元素绑定事件，然后在事件处理函数中根据鼠标点击、移动的坐标等判断交互，决定操作。</p><p>svg：每个元素是DOM节点，可以直接操作和绑定事件。内置的命中测试使得 SVG 在处理交互时更为便捷和直观。开发者只需将事件直接绑定到具体的 SVG 元素上，而无需手动判断鼠标位置与图形区域的关系。</p><p>3、适用场景：</p><p>Canvas：更适合需要高性能、频繁更新和复杂动画效果的场景，但在交互性和分辨率适应方面需要开发者额外处理。</p><p>SVG：适用于静态图形、矢量图形和需要良好交互体验的场景，但当图形数量巨大时可能会导致性能瓶颈。</p></li></ul><h2 id="2、head标签的作用？"><a href="#2、head标签的作用？" class="headerlink" title="2、head标签的作用？"></a>2、head标签的作用？</h2><p>head标签主要用于包含那些不会直接显示在网页内容区域中的信息（元数据），帮助浏览器、搜索引擎、其他外部工具了解页面信息，如何处理页面资源。</p><ul><li><p><strong>定义文档标题</strong>（必不可少）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>声明字符编码</strong>（必不可少）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>描述网页信息</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;这是一个示例网页，展示 head 标签的基本用法。&quot;</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>引用外部资源</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;styles.css&quot;</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>其他用途</strong></p><p>&lt;style&gt;内嵌css样式、&lt;base&gt;基础链接等。</p></li></ul><h2 id="3、Doctype的作用？"><a href="#3、Doctype的作用？" class="headerlink" title="3、Doctype的作用？"></a>3、Doctype的作用？</h2><p>文档声明：告诉浏览器当前页面使用的HTML版本，决定浏览器使用标准模式还是混杂模式进行渲染。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span> #HTML5的简洁声明<br></code></pre></td></tr></table></figure><ul><li><p><strong>标准模式&#x2F;严格模式</strong></p><p>只要以<code>!Doctype</code>或其他正确的完整的文档声明开始，浏览器一般是标准模式渲染。</p></li><li><p><strong>怪异模式&#x2F;混杂模式&#x2F;兼容模式</strong></p><p><code>Doctype</code> 声明不完整或者书写错误，就自动切换到混杂模式兼容旧版页面。</p></li></ul><p><strong>？</strong>DTD是什么？</p><blockquote><p><strong>DTD</strong> 是文档类型定义（Document Type Definition）的缩写，用于定义 XML 或早期 HTML 文档的结构和合法内容。早期 HTML 文件可能会包含如下的 DTD 声明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span></span><br><span class="hljs-meta">   <span class="hljs-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="4、浏览器乱码问题"><a href="#4、浏览器乱码问题" class="headerlink" title="4、浏览器乱码问题"></a>4、浏览器乱码问题</h2><ul><li><p><strong>编码和解码</strong></p><p>编码：人类文字转换为二进制数据的过程。不同的字符编码(UTF-8、GBK、ISO-8859-1)规定了不同字符与二进制数据之间的对应关系。</p><p>解码：当浏览器或者其他程序打开一个文件时，将文件中的二进制数据转换回人类文字的过程。</p></li><li><p><strong>乱码</strong></p><p>声明的编码（或者没有声明）与文件实际保存时候的编码不一致，浏览器就可能错误地将二进制解析成其他字符，从而乱码。多因字符编码不匹配，包括文件实际编码、HTML 声明和服务器响应头中指定的编码不一致或错误导致乱码。</p></li><li><p><strong>解决乱码</strong></p><p>1、使用统一合适的编码（推荐UTF-8）</p><p>2、在head部分添加字符集声明</p><p>3、配置服务器返回正确的<code>Content-Type</code>响应头</p><p>4、检查引用的外部资源编码是否一致</p></li><li><p><strong>浏览器解析文档时参考优先级</strong></p><p>1、服务器响应头中的编码信息；</p><p>2、HTML 文件内 <code>&lt;meta charset=&quot;...&quot;&gt;</code> 的声明；</p></li></ul><h2 id="5、渐进增强和优雅降级"><a href="#5、渐进增强和优雅降级" class="headerlink" title="5、渐进增强和优雅降级"></a>5、渐进增强和优雅降级</h2><p>它们是两种核心策略，目标是兼容性，确保网站能够在不同浏览器、设备、网络环境下提供最佳的用户体验。</p><ul><li><p><strong>渐进增强</strong>（基础到高级）</p><p>1、核心理念：先确保网站的核心内容和功能在所有环境下（包括老旧浏览器或低性能设备）都能正常工作，再逐步为支持新特性的现代浏览器添加增强效果（如动画、复杂布局、交互功能等）。优先保障内容的可访问性，再考虑视觉和交互的增强。</p><p>2、实现步骤：</p><ul><li><strong>基础层</strong>：使用语义化的 HTML 实现内容和基本功能（如链接、表单提交）。</li><li><strong>表现层</strong>：通过 CSS 增强布局和视觉效果（如响应式设计、动画）。</li><li><strong>行为层</strong>：通过 JavaScript 添加交互功能（如动态加载数据、复杂交互）</li></ul></li><li><p><strong>优雅降级</strong>（高级到基础）</p><p>1、核心理念：先为现代浏览器开发完整的功能和视觉效果，再为老旧浏览器提供“降级”方案，确保基本功能可用。优先实现最新技术，再处理兼容性问题。</p><p>2、实现步骤：</p><ul><li><strong>完整功能层</strong>：使用最新的 HTML5&#x2F;CSS3&#x2F;JavaScript 实现所有功能。</li><li><strong>降级处理</strong>：通过浏览器检测或特性检测（如 CSS Hack、Polyfill），为老旧浏览器提供简化版的功能或界面。</li></ul></li></ul><p><strong>？</strong>什么是浏览器检测</p><blockquote><p>识别用户的浏览器类型（Chrome、Firefox、Safari等）和版本号，来决定如何呈现内容或者加载特定代码。</p><p>1、<strong>User-Agent 检测</strong>：每个浏览器在发送请求时都会包含 <code>User-Agent</code> 字符串，这个字符串描述了浏览器的名称、版本号和运行环境（如操作系统）。前端可以通过 JavaScript 获取并分析 <code>navigator.userAgent</code>，从而判断用户的浏览器类型。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const isChrome = <span class="hljs-regexp">/Chrome/</span>.test(navigator.userAgent) &amp;&amp; <span class="hljs-regexp">/Google Inc/</span>.test(navigator.vendor);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(isChrome ? <span class="hljs-string">&quot;这是 Chrome 浏览器&quot;</span> : <span class="hljs-string">&quot;不是 Chrome 浏览器&quot;</span>);<br></code></pre></td></tr></table></figure><p>2、<strong>使用特定 API</strong>：有些浏览器支持特定的 API，检测这些 API 的存在可以帮助判断浏览器类型。例如，通过检测 <code>window.chrome</code> 对象可以判断是否为 Chrome 浏览器。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (window.chrome) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;这是 Chrome 浏览器 &quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;这不是 Chrome 浏览器&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure></blockquote><p><strong>？</strong>什么是特性检测</p><blockquote><p>检测浏览器是否支持某项特性（例如某种 CSS 属性、HTML 元素或 JavaScript API），从而决定是否启用该特性或使用替代方案。</p><p><strong>1、CSS 特性检测</strong>： <code>CSS.supports</code> 方法</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (CSS.supports(<span class="hljs-string">&quot;display&quot;</span>,<span class="hljs-string">&quot;grid&quot;</span>))&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;支持CSS Grid&quot;</span>)<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>2、JavaScript 特性检测</strong>：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(window.fetch)</span></span>&#123;<br>    console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&quot;支持fetch API&quot;</span>)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>    console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&quot;不支持fetch API，使用 XMLHttpRequest 替代&quot;</span>)<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>3、使用Polyfill：</strong>Polyfill可以实现一些现代Web特性，如Promise、fetch API等，即使老旧浏览器不支持这些特性。选择合适的Polyfill库，如polyfill.io、babel-polyfill等。在代码中引入Polyfill库。根据需要，在代码中调用Polyfill库提供的特定函数或API。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Canvas和SVG的区别</tag>
      
      <tag>head标签的作用</tag>
      
      <tag>Doctype的作用</tag>
      
      <tag>浏览器乱码</tag>
      
      <tag>渐进增强和优雅降级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML知识点（二）</title>
    <link href="/2025/02/05/HTML%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2025/02/05/HTML%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML知识点（二）"><a href="#HTML知识点（二）" class="headerlink" title="HTML知识点（二）"></a>HTML知识点（二）</h1><h2 id="1、img的srcset属性作用？"><a href="#1、img的srcset属性作用？" class="headerlink" title="1、img的srcset属性作用？"></a>1、img的srcset属性作用？</h2><p>srcset：提供实际可用的图片资源。</p><ul><li><p>按图像宽度描述</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;small.jpg&quot;</span> <br>     <span class="hljs-attribute">srcset</span>=<span class="hljs-string">&quot;small.jpg 500w, medium.jpg 1000w, large.jpg 1500w&quot;</span> <br>     <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>按图像分辨率描述</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;default.jpg&quot;</span><br>     <span class="hljs-attribute">srcset</span>=<span class="hljs-string">&quot;small.jpg 1x, medium.jpg 2x, large.jpg 3x&quot;</span><br>     <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;<br></code></pre></td></tr></table></figure></li></ul><p>sizes：告诉浏览器图片的显示大小。通常，<code>srcset</code> 属性会与 <code>sizes</code> 属性一起使用，后者用来指定在不同视口宽度下图像的显示大小（即图像在页面上实际占据的空间），帮助浏览器更准确地选择最佳图像资源。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;default.jpg&quot;</span><br>     <span class="hljs-attribute">srcset</span>=<span class="hljs-string">&quot;small.jpg 500w, medium.jpg 1000w, large.jpg 1500w&quot;</span><br>     <span class="hljs-attribute">sizes</span>=<span class="hljs-string">&quot;(max-width: 600px) 480px, (max-width: 1200px) 800px, 1200px&quot;</span><br>     <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;响应式图片示例&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>核心目标：减少不必要的带宽浪费，保证图片在不同设备下清晰度适配。</p><ul><li><strong><code>sizes</code> 计算显示宽度</strong>：<br>根据当前视口宽度和 <code>sizes</code> 规则，计算出图片的显示宽度（CSS 像素）。</li><li><strong>计算需要的图片实际宽度</strong>：<br>需要的图片实际宽度 &#x3D; 显示宽度 × 设备像素比。</li><li><strong>从 <code>srcset</code> 中选择图片</strong>：<br>选择一张实际宽度 ≥ 计算值且最接近的图片。</li></ul><h2 id="2、行内元素和块级元素"><a href="#2、行内元素和块级元素" class="headerlink" title="2、行内元素和块级元素"></a>2、行内元素和块级元素</h2><ul><li><p><strong>行内元素</strong></p><p>多个行内元素可以排在一行上，宽度高度内边距外边距通常只对水平方向有效。</p><blockquote><p>1、文字样式：b、strong、i、em、u、mark、small、sub、sup、span</p><p>2、链接交互：a、button</p><p>3、媒体相关：img、video、audio、svg</p><p>4、表单相关：input、label、select、textarea、option</p></blockquote></li><li><p><strong>块级元素</strong></p><p>每个块级元素独占一行，宽度默认是父容器的100%，可以设置宽度高度。</p><blockquote><p>1、布局容器：div、section、article、aside、nav、header、footer、main</p><p>2、文字相关：p、h1-h6、hr</p><p>3、表格相关：tabel、thead、tbody、tfoot、tr、th、td</p><p>4、列表相关：ul、ol、li、dl、dt、dd</p><p>5、媒体相关：figure、figcaption</p></blockquote></li><li><p><strong>空元素</strong></p><p>没有子元素，通常是自闭合标签。</p><blockquote><p>1、文档结构：br、hr</p><p>2、媒体相关：img、track</p><p>3、表单相关：input、textarea</p><p>4、其他：meta、link、base</p></blockquote></li></ul><h2 id="3、title与h1的区别、b与strong的区别、i与em的区别"><a href="#3、title与h1的区别、b与strong的区别、i与em的区别" class="headerlink" title="3、title与h1的区别、b与strong的区别、i与em的区别"></a>3、title与h1的区别、b与strong的区别、i与em的区别</h2><p>1、title定义网页的标题，h1定义网页内容的主标题。h1-h6更具有层次感。</p><p>2、b表示文本加粗，而strong有语义强调加粗，对seo有影响。</p><p>3、i表示文本斜体，em有语义强调斜体，对seo有影响。</p><h2 id="4、iframe-的优点和缺点？"><a href="#4、iframe-的优点和缺点？" class="headerlink" title="4、iframe 的优点和缺点？"></a>4、iframe 的优点和缺点？</h2><p>iframe是HTML 中用于嵌入其他 HTML 文档的标签，允许将一个独立的网页嵌入到当前页面中。</p><ul><li><p><strong>优点</strong></p><p>页面嵌套：可以将其他网页嵌入当前页面，例如外部资源、广告、第三方工具等。实现独立的内容区块，不影响主页面的结构和样式。</p><p>独立性：嵌入的内容是一个独立的文档，有自己的 DOM 和 CSS 范围。主页面与嵌入的文档相互独立，互不干扰。</p><p>安全性：主页面与 iframe 中的内容隔离，某些安全风险（如 XSS 攻击）会被限制。通过 <code>sandbox</code> 属性，可以限制 <code>&lt;iframe&gt;</code> 的行为。</p><p>跨域通信：通过 postMessage API，可以实现 iframe 与父页面之间的跨域通信。</p><p>懒加载：通过 loading&#x3D;”lazy” 属性实现 iframe 的懒加载，优化页面性能。</p></li><li><p><strong>缺点</strong></p><p>性能问题：额外的资源请求，如果嵌入的文档加载慢，会拖慢整体页面性能。每个 iframe&gt;都会创建一个独立的文档上下文，增加内存和 CPU 开销。</p><p>用户体验：iframe大小要手动设置，内容溢出可能出现双滚动条。</p><p>seo优化：可能无法正确索引iframe中的内容。</p><p>跨域限制：虽然可以嵌入跨域内容，但与主页面的通信受到浏览器同源策略的限制（即不能直接访问 iframe 中的 DOM）。</p><p>嵌套复杂性：如果 iframe 中再嵌套 iframe，会导致维护难度增加，同时引发额外的性能问题。</p></li></ul><p><strong>？</strong>什么是懒加载</p><blockquote><p>主要思想是：<strong>仅在需要时才加载内容</strong>。在用户滚动到相应位置或满足特定条件时才加载相应的资源。</p><p>实现方式：</p><p>1、使用HTML属性，loading&#x3D;”lazy”；</p><p>2、使用JS中的IntersectionObserver。</p></blockquote><p><strong>？</strong>什么是沙盒属性</p><blockquote><p><code>sandbox</code> 属性通常用于 <code>&lt;iframe&gt;</code> 标签上，用于对嵌入的内容启用一系列安全限制。简单来说，它为嵌入的文档创建了一个沙盒环境，限制其能执行的操作，以增强安全性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://example.com&quot;</span> <span class="hljs-attr">sandbox</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure><p>限制脚本执行、限制表单提交、阻止插件和导航、隔离同源策略。也可以配置allow等。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;iframe <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;https://example.com&quot;</span> <span class="hljs-attribute">sandbox</span>=<span class="hljs-string">&quot;allow-scripts allow-forms&quot;</span>&gt;&lt;/iframe&gt;<br></code></pre></td></tr></table></figure></blockquote><h2 id="5、HTML5-drag-API"><a href="#5、HTML5-drag-API" class="headerlink" title="5、HTML5 drag API"></a>5、HTML5 drag API</h2><ul><li>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。 </li><li>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。 </li><li>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。 </li><li>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。 </li><li>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。 </li><li>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。 </li><li>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。</li></ul>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>drag</tag>
      
      <tag>iframe</tag>
      
      <tag>srcset</tag>
      
      <tag>行内与块级元素</tag>
      
      <tag>b与strong</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML知识点（一）</title>
    <link href="/2025/02/04/HTML%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2025/02/04/HTML%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML知识点（一）"><a href="#HTML知识点（一）" class="headerlink" title="HTML知识点（一）"></a>HTML知识点（一）</h1><h2 id="1、src和href的区别"><a href="#1、src和href的区别" class="headerlink" title="1、src和href的区别"></a>1、src和href的区别</h2><ul><li><p><strong>资源加载方式</strong></p><p>src 加载资源并且把资源嵌入到页面中，加载资源的过程中页面可能会等待资源加载完成。（比如 script 标签在加载时会阻塞页面渲染）。</p><p>href 用于建立连接，加载外部资源（比如 css）后并不直接嵌入内容，或仅在用户交互后导航到该资源。</p></li><li><p><strong>适用标签</strong></p><p>src 常用于 &lt;img&gt;  、 &lt;script&gt;  、 &lt;frame&gt;  等需要直接加载并显示内容的标签。</p><p>href 常用语 &lt;a&gt;  、 &lt;link&gt;  标签，分别用于建立超链接和加载外部样式&#x2F;其他资源。</p></li><li><p><strong>加载时机</strong></p><p>src：浏览器在解析标签的时候，立即加载指定资源。</p><p>href：对于&lt;a&gt; 标签，用户点击链接后才会加载资源。对于 &lt;link&gt; 标签（比如css），浏览器在解析&lt;head&gt;时加载，但不会阻塞页面渲染。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 加载外部CSS样式表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;../CSS/demo.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 图片 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../Images/cat.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 引入JS --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../JS/demo.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Frame --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://oyoanan.github.io/&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;600&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;400&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><br>     <span class="hljs-comment">&lt;!-- 超链接 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://oyoanan.github.io/&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;noopener&quot;</span>&gt;</span>访问安安的博客<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>?</strong> 为什么script标签默认阻塞页面渲染？</p><blockquote><p> &lt;script&gt; 标签默认的行为：浏览器必须停下渲染页面，先处理脚本，再继续渲染。</p><p> 因为脚本可能改变页面内容、可能依赖已渲染的内容。</p></blockquote><p><strong>？</strong>那如何让脚本不阻塞渲染？</p><blockquote><p>使用 async 属性（异步加载）— 下载完立即执行，但执行时机不确定，适合独立脚本（比如广告）。</p><p>使用 defer 属性（延迟执行） — 页面渲染完成后执行，保证了先后顺序，适合依赖页面内容的脚本。</p></blockquote><h2 id="2、HTML语义化的理解"><a href="#2、HTML语义化的理解" class="headerlink" title="2、HTML语义化的理解"></a>2、HTML语义化的理解</h2><ul><li><p><strong>提升可读性和可维护性</strong></p><p>开发者使用具有明确含义的标签（比如 <code>&lt;header&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;main&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;footer&gt;</code> 等）,代码的结构和目的更直观，其他开发者或者后续自己的维护时也能更快理解页面结构。</p></li><li><p><strong>搜索引擎优化 SEO</strong></p><p>搜索引擎根据页面的语义信息更好理解内容的层次和重点，有助于提升页面在搜索结果中的排名。</p></li><li><p><strong>无障碍访问</strong></p><p>使用语义化的标签可以帮助屏幕阅读器或者其他辅助技术正确的解释页面内容，帮助残障人士更好地使用网页。</p></li><li><p><strong>标准化开发</strong></p><p>遵循HTML语义化标准，提高代码的可移植性，确保代码在不同的浏览器或者设备上都有较好的表现。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>文章标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>文章作者<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>发表时间<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>文章主体<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>文章内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>版权所有<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>？</strong>常见的HTML语义化标签</p><blockquote><p>分为结构性标签、文本标签</p><p>结构性标签：&lt;header&gt; 、&lt;nav&gt; 、&lt;aside&gt; 、&lt;section&gt; 、&lt;article&gt; 、&lt;footer&gt; 、&lt;main&gt; </p><p>文本标签：&lt;h1-h6&gt; 、&lt;p&gt; 、&lt;blockqueto&gt; 、&lt;a&gt; 、&lt;q&gt; </p></blockquote><h2 id="3、DOCTYPE的作用"><a href="#3、DOCTYPE的作用" class="headerlink" title="3、DOCTYPE的作用"></a>3、DOCTYPE的作用</h2><p><code>&lt;!DOCTYPE&gt;</code> 声明，也称为文档类型声明。它的作用是告诉浏览器当前文档使用的是哪种HTML或XHTML规范，如何解析和渲染页面。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span> 触发标准模式 HTML5<br></code></pre></td></tr></table></figure><ul><li><p><strong>告诉浏览器使用哪种渲染模式</strong></p><p>标准模式：浏览器安装W3C标准来渲染。</p><p>怪异模式：为了兼容老旧网页，用非标准的方式渲染页面，可能导致不同浏览器之间的显示效果差异。</p></li></ul><p><strong>？</strong>如何启动怪异模式</p><blockquote><p>只要 DOCTYPE 的声明符合某个标准格式，就自动进入标准模式。反之，如果没有声明 DOCTYPE，或者使用了不完整或过时的  DOCTYPE 声明，进入怪异模式。</p></blockquote><p><strong>？</strong>差异具体表现在哪里</p><blockquote><p>CSS盒模型的计算方式：标准模式下的宽高只包含了内容 content 区域，不包含边框或者内边距、外边距。而怪异模式下的宽高为它们的总和。</p><p>默认布局和对齐差异：怪异模式中，一些默认样式和行内元素的垂直对齐可能与标准模式下有所差别。例如，图片或内联块元素的基线对齐行为可能会不同。</p></blockquote><h2 id="4、常用的meta标签"><a href="#4、常用的meta标签" class="headerlink" title="4、常用的meta标签"></a>4、常用的meta标签</h2><p><code>meta</code> 是HTML中用于提供元数据的标签。不会直接显示在页面，但对于SEO、浏览器解析和移动设备优化等方面很重要。</p><ul><li><p><strong>字符集声明</strong></p><p>字符编码定义了字符与二进制数据之间的映射关系。如果编码设置不正确，浏览器可能会显示乱码。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt; <br><span class="hljs-comment"># 支持几乎所有的语言字符（中文、英文、日文、韩文等），兼容ASCII码。</span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">charset</span>=<span class="hljs-string">&quot;ISO-8859-1&quot;</span>&gt; <br><span class="hljs-comment"># 支持西欧语言（如英语、法语、德语、西班牙语等），不支持中文、日文等非拉丁字符。</span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">charset</span>=<span class="hljs-string">&quot;GBK&quot;</span>&gt; &lt;meta <span class="hljs-attribute">charset</span>=<span class="hljs-string">&quot;GB2312&quot;</span>&gt;<br><span class="hljs-comment"># 支持简体中文和部分繁体中文，是 GB2312 的扩展，支持更多汉字。</span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">charset</span>=<span class="hljs-string">&quot;Big5&quot;</span>&gt;<br><span class="hljs-comment">#支持繁体中文，主要用于台湾、香港等地区。</span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">charset</span>=<span class="hljs-string">&quot;Shift_JIS&quot;</span>&gt;<br><span class="hljs-comment"># 支持日文，是日本常用的字符编码。</span><br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">charset</span>=<span class="hljs-string">&quot;EUC-KR&quot;</span>&gt;<br><span class="hljs-comment"># 支持韩文，是韩国常用的字符编码。</span><br></code></pre></td></tr></table></figure><p> <strong>其他编码</strong></p><p>ASCII：仅支持英文字符和基本符号，不适合多语言网页。</p><p>UTF-16：支持 Unicode 字符，但文件体积较大，不推荐用于网页。</p><p>UTF-32：支持 Unicode 字符，但文件体积更大，极少使用。</p></li><li><p><strong>视口设置</strong></p><p>控制网页在不同设备上的显示和缩放行为。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 还可以设置minimum-scale、maximum-scale、user-scalable --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>搜索引擎相关</strong></p><p>允许&#x2F;禁止 — 搜索引擎索引此网页内容、跟踪网页中的链接并爬取它们的内容。</p><p>noarchive： 禁止搜索引擎保存页面的缓存版本。</p><p>nosnippet：禁止搜索引擎在搜索结果中显示页面内容的摘要。</p><p>noimageindex：禁止搜索引擎索引页面上的图片。</p><p>nocache：禁止搜索引擎缓存页面（类似于 <code>noarchive</code>）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- index/ follow/ noindex/ nofollow --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robots&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;index,follow&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>其他元数据</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 设置作者 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;anan&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 设置版权 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;copyright&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;© 2025 AnCompany&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 页面描述 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;This is a description&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 页面关键字 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;HTML, meta, 标签, 示例&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 设置页面自动刷新 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;refresh&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;5;url=https://www.google.com&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 针对IE浏览器，使用最新的渲染模式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 内容安全策略 只允许这些特定来源加载相应的资源 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">content</span>=<span class="hljs-string">&quot;default-src &#x27;self&#x27;;</span></span><br><span class="hljs-string"><span class="hljs-tag">script-src &#x27;self&#x27; https://trusted.cdn.com;</span></span><br><span class="hljs-string"><span class="hljs-tag">style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;;</span></span><br><span class="hljs-string"><span class="hljs-tag">img-src &#x27;self&#x27; https://images.example.com;</span></span><br><span class="hljs-string"><span class="hljs-tag">font-src &#x27;self&#x27;;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="5、HTML5有哪些更新？"><a href="#5、HTML5有哪些更新？" class="headerlink" title="5、HTML5有哪些更新？"></a>5、HTML5有哪些更新？</h2><ul><li><p><strong>新语义化标签</strong></p><p><code>header</code>, <code>main</code>, <code>footer</code>, <code>nav</code>, <code>aside</code>, <code>section</code>, <code>article</code>等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 新增语义化标签 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">details</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">details</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">summary</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">summary</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">figure</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">figcaption</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">figcaption</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>多媒体支持</strong></p><p><code>audio</code>, <code>video</code>, <code>source</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 多媒体支持 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">autoplay</span> <span class="hljs-attr">loop</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">poster</span>=<span class="hljs-string">&quot;../Images/cat.jpg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">audio</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;audio.mp3&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;audio/mp3&#x27;</span>&gt;</span><br>       您的浏览器不支持音频标签。<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">video</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;video.mp4&#x27;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;video/mp4&#x27;</span>&gt;</span><br>       您的浏览器不支持视频标签。<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>？</strong> label是什么标签？</p><blockquote><p><code>label</code>是为表单控件定义标签的元素，点击<code>label</code>标签浏览器自动转移焦点到相应控件。</p><p>将它与表单控件关联的方式有：</p><p>1、通过for属性的值与控件的id属性值一致。</p><p>2、将表单控件嵌套在<code>label</code>标签内部。</p></blockquote><p><strong>？</strong> name属性的含义？</p><blockquote><p>name属性为表单控件指定名称，这个名称是键，控件输入内容为值，键值对会发送给服务器。</p><p>多个控件可以共享相同的 name，这样服务器会将这些值当作一组数据处理。（比如单选框、多选框）</p></blockquote></li><li><p><strong>表单增强</strong></p><p>新增输入类型 <code>input type</code>：email、url、date、time、detetime-local、number、range、color</p><p>新增属性：required、placeholder、pattern、autofocus。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 表单增强 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span>电子邮件<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">required</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;输入电子邮件地址&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;birthdate&quot;</span>&gt;</span>出生日期<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;date&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;birthdate&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;birthdate&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span> 时间<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;time&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;datetime-local&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span> 数字<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">autofocus</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span> 滑块<br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;range&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;color&quot;</span>&gt;</span>颜色<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;color&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;color&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;color&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>选择性别：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>选择爱好：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobbies[]&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;reading&quot;</span>&gt;</span> 阅读<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobbies[]&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sports&quot;</span>&gt;</span> 运动<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobbies[]&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;music&quot;</span>&gt;</span> 音乐<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>图形和绘图支持</strong></p><p>新增<code>canvas</code>标签，允许使用 JavaScript在页面上绘制图形。对 SVG 矢量图的支持进一步增强。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-comment">&lt;!-- canvas --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCanvas&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">       <span class="hljs-keyword">var</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myCanvas&quot;</span>);</span><br><span class="language-javascript">       <span class="hljs-keyword">var</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;2d&quot;</span>);</span><br><span class="language-javascript">       ctx.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;red&quot;</span>;</span><br><span class="language-javascript">       ctx.<span class="hljs-title function_">fillRect</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);</span><br><span class="language-javascript">   </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>？</strong> canvas的 getContext 方法？</p><blockquote><p> 是 canvas 元素的核心 API，用于获取指定类型的绘图上下文。</p><p> 传入参数”2d”：获取一个二维绘图上下文。</p><p> 传入参数”webgl”或者”experimental-webgl”：进行 3D 绘图和高性能图形渲染。</p></blockquote><p>强化对<code>svg</code>标签的支持：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;svg width<span class="hljs-operator">=</span><span class="hljs-string">&quot;200&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;200&quot;</span> xmlns<span class="hljs-operator">=</span><span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;<br>     &lt;circle<br>       cx<span class="hljs-operator">=</span><span class="hljs-string">&quot;100&quot;</span><br>       cy<span class="hljs-operator">=</span><span class="hljs-string">&quot;100&quot;</span><br>       r<span class="hljs-operator">=</span><span class="hljs-string">&quot;80&quot;</span><br>       stroke<span class="hljs-operator">=</span><span class="hljs-string">&quot;green&quot;</span><br>       stroke-width<span class="hljs-operator">=</span><span class="hljs-string">&quot;4&quot;</span><br>       fill<span class="hljs-operator">=</span><span class="hljs-string">&quot;yellow&quot;</span><br>     /&gt;<br> &lt;/svg&gt;<br></code></pre></td></tr></table></figure><p><strong>？</strong>xmlns属性是什么？</p><blockquote><p>全称：XML Namespace（XML 命名空间）。</p><p>命名空间的作用是防止在不同 XML 语言中可能存在的标签名称冲突。告诉浏览器，“这里定义的所有元素都属于 SVG 标准（由 W3C 定义的 SVG 规范）”，</p></blockquote><p><strong>？</strong> XML是什么？和HTML的区别？</p><blockquote><p>XML（可扩展标记语言）和 HTML（超文本标记语言）都是基于标记的语言，但它们的设计目的和使用场景有明显的不同。</p><p>XML：主要目标是存储和传输数据，强调数据的结构和内容，而不是数据的显示。语法非常严格。“可扩展”的，意味着可以自定义标签和结构，以适应不同的需求。</p><p>HTML：主要用于在网页上显示和呈现数据。关注页面内容的结构、格式和外观，而不是数据本身的存储。语法较宽松，浏览器具有容错性。</p></blockquote></li><li><p><strong>存储和离线</strong></p><p><strong>1、本地存储：</strong>在用户浏览器中存储数据。</p><p>**<code>localStorage</code>**：持久化存储，键值对形式，存储容量比COOKIE大。</p><p>**<code>sessionStorage</code>**：仅在浏览器会话 session 期间存储，关闭页面后数据会被清除。键值对形式，适合存储临时数据。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 存储和离线支持 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">       <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;name1&quot;</span>, <span class="hljs-string">&quot;anan1&quot;</span>);</span><br><span class="language-javascript">       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;name1&quot;</span>));</span><br><span class="language-javascript">       <span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&quot;name2&quot;</span>, <span class="hljs-string">&quot;anan2&quot;</span>);</span><br><span class="language-javascript">       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&quot;name2&quot;</span>));</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2、离线支持：</strong>网页或 Web 应用在没有网络连接的情况下，仍能正常运行或展示部分功能。</p><p>AppCache 已被视为过时技术，现代方法是使用 Service Worker 和 Cache API。</p><p>**<code>AppCache</code>**：在 HTML 页面中添加一个 <code>manifest</code> 属性，指定一个清单文件（manifest file）。这个文件列出了应用所需的所有资源，浏览器会将这些资源缓存到本地。当离线时，浏览器会使用缓存的资源加载页面。</p><p>**<code>Service Worker</code>**：是运行在浏览器后台的独立线程，可以拦截网络请求，控制资源缓存和离线加载行为。它允许开发者精确控制哪些文件需要缓存，以及如何在离线时响应请求。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 检查浏览器是否支持 Service Worker</span></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;serviceWorker&#x27;</span> <span class="hljs-keyword">in</span> navigator) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 注册 Service Worker 脚本（sw.js）</span></span><br><span class="language-javascript">        navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;../JS/serviceworker.js&#x27;</span>)</span><br><span class="language-javascript">          .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">registration</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Service Worker 注册成功，范围：&#x27;</span>, registration.<span class="hljs-property">scope</span>);</span><br><span class="language-javascript">          &#125;)</span><br><span class="language-javascript">          .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Service Worker 注册失败：&#x27;</span>, error);</span><br><span class="language-javascript">          &#125;);</span><br><span class="language-javascript">      &#125;);</span><br><span class="language-javascript">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;当前浏览器不支持 Service Worker。&#x27;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>？</strong>什么是manifest文件？</p><blockquote><p>用于列出一个 Web 应用中所有需要缓存的资源（例如 CSS、JavaScript、图片、字体等）。根据该文件的内容将指定资源下载并保存到本地缓存中。</p><p>第一行必须是 <code>CACHE MANIFEST</code>，告诉浏览器这是一个应用缓存文件。<code>CACHE</code> 部分列出所有需要缓存的资源 URL，<code>NETWORK</code> 部分指定哪些资源在离线时不缓存，而是始终通过网络请求。如果写 <code>*</code>，表示所有不在 CACHE 部分的资源都需要通过网络获取。</p><p>由于存在更新不灵活、错误处理较差等问题，现在已被 Service Worker 替代。</p></blockquote><p><strong>?</strong> 使用manifest的注意事项：</p><blockquote><p>1、创建 manifest 文件</p><p>2、在 HTML 文件的 <code>&lt;html&gt;</code> 标签中添加 <code>manifest</code> 属性，指定该 manifest 文件的 URL。</p><p>3、当应用中的资源发生变化时，需要更新 <code>.manifest</code> 文件的内容或修改版本号，这样浏览器才会检测到变化并更新缓存。</p><p>4、使用 <code>.manifest</code> 文件时，需要确保服务器正确配置了 MIME 类型（<code>text/cache-manifest</code>），否则浏览器可能无法正确解析文件。— 每个文件都有一个<strong>MIME 类型</strong>（也称为媒体类型）</p></blockquote><p><strong>?</strong> navigator是什么？</p><blockquote><p>在浏览器中，<code>navigator</code> 是 <code>window</code> 对象的一个属性，可以直接通过 <code>navigator</code> 来访问。</p><p><code>navigator</code> 包含了关于浏览器和操作系统的一些基本信息，navigator 对象提供了多种接口，比如：</p><p>navigator.geolocation：用于访问地理位置信息。<br>navigator.serviceWorker：用于注册和管理 Service Worker，从而实现离线支持、后台同步等。<br>navigator.mediaDevices：用于访问摄像头和麦克风等媒体设备。】</p></blockquote></li><li><p><strong>文档声明</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"># 更简洁的文档声明和默认字符编码：<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>设备适配</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>Geolocation API（地理定位）</strong></p><p>允许网页或 Web 应用在获得用户授权后，获取用户的地理位置信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (navigator.<span class="hljs-property">geolocation</span>) &#123;</span><br><span class="language-javascript">        navigator.<span class="hljs-property">geolocation</span>.<span class="hljs-title function_">getCurrentPosition</span>(</span><br><span class="language-javascript">          <span class="hljs-keyword">function</span>(<span class="hljs-params">position</span>) &#123; <span class="hljs-comment">// 成功回调</span></span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> latitude = position.<span class="hljs-property">coords</span>.<span class="hljs-property">latitude</span>;</span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> longitude = position.<span class="hljs-property">coords</span>.<span class="hljs-property">longitude</span>;</span><br><span class="language-javascript">            <span class="hljs-keyword">const</span> accuracy = position.<span class="hljs-property">coords</span>.<span class="hljs-property">accuracy</span>;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;纬度：&#x27;</span> + latitude);</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;经度：&#x27;</span> + longitude);</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;精度：&#x27;</span> + accuracy + <span class="hljs-string">&#x27; 米&#x27;</span>);</span><br><span class="language-javascript">          &#125;,</span><br><span class="language-javascript">          <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123; <span class="hljs-comment">// 错误回调</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;获取位置信息失败：&#x27;</span>, error);</span><br><span class="language-javascript">          &#125;,</span><br><span class="language-javascript">          &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">enableHighAccuracy</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 尽可能获取高精度位置</span></span><br><span class="language-javascript">            <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>,            <span class="hljs-comment">// 5 秒超时</span></span><br><span class="language-javascript">            <span class="hljs-attr">maximumAge</span>: <span class="hljs-number">0</span>             <span class="hljs-comment">// 不使用缓存，获取最新的位置</span></span><br><span class="language-javascript">          &#125;</span><br><span class="language-javascript">        );</span><br><span class="language-javascript">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;浏览器不支持 Geolocation API&quot;</span>);</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>拖放 API（Drag and Drop API）</strong></p><p>拖放 API 允许用户在网页上拖动元素，并将它们放置到目标区域。例如，文件上传可以通过拖拽文件实现。</p><p>拖放的实现基于以下事件：</p><ul><li><strong>拖拽开始阶段</strong>：<code>dragstart</code></li><li><strong>拖拽过程中的监控</strong>：<code>drag</code></li><li><strong>进入目标区域时</strong>：<code>dragenter</code></li><li><strong>在目标区域内移动</strong>：<code>dragover</code></li><li><strong>离开目标区域时</strong>：<code>dragleave</code></li><li><strong>放置时</strong>：<code>drop</code></li><li><strong>拖拽结束时</strong>：<code>dragend</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>拖放 API 示例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-id">#drag-item</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">      <span class="hljs-attribute">color</span>: white;</span><br><span class="language-css">      <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">      <span class="hljs-attribute">justify-content</span>: center;</span><br><span class="language-css">      <span class="hljs-attribute">align-items</span>: center;</span><br><span class="language-css">      <span class="hljs-attribute">cursor</span>: grab;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-id">#drop-area</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> dashed gray;</span><br><span class="language-css">      <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">      <span class="hljs-attribute">justify-content</span>: center;</span><br><span class="language-css">      <span class="hljs-attribute">align-items</span>: center;</span><br><span class="language-css">      <span class="hljs-attribute">color</span>: gray;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-id">#drop-area</span><span class="hljs-selector-class">.drag-over</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">border-color</span>: green;</span><br><span class="language-css">      <span class="hljs-attribute">color</span>: black;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;drag-item&quot;</span> <span class="hljs-attr">draggable</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>拖我<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;drop-area&quot;</span>&gt;</span>放到这里<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> dragItem = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;drag-item&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> dropArea = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;drop-area&#x27;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    dragItem.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;dragstart&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">      event.<span class="hljs-property">dataTransfer</span>.<span class="hljs-title function_">setData</span>(<span class="hljs-string">&#x27;text/plain&#x27;</span>, <span class="hljs-string">&#x27;我是拖拽的数据&#x27;</span>);</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    dropArea.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;dragover&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">      event.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">// 允许放置</span></span><br><span class="language-javascript">      dropArea.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;drag-over&#x27;</span>);</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    dropArea.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;dragleave&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">      dropArea.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;drag-over&#x27;</span>);</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    dropArea.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;drop&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">      event.<span class="hljs-title function_">preventDefault</span>();</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> data = event.<span class="hljs-property">dataTransfer</span>.<span class="hljs-title function_">getData</span>(<span class="hljs-string">&#x27;text/plain&#x27;</span>);</span><br><span class="language-javascript">      dropArea.<span class="hljs-property">textContent</span> = <span class="hljs-string">`接收到的数据：<span class="hljs-subst">$&#123;data&#125;</span>`</span>;</span><br><span class="language-javascript">      dropArea.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;drag-over&#x27;</span>);</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><strong>？</strong> event.dataTransfer.setData方法</p><blockquote><p>用于在拖拽开始时将数据与拖拽事件关联起来，方便在放置时通过 <code>getData()</code> 获取该数据。</p></blockquote><p><strong>?</strong> event.preventDefault方法</p><blockquote><p>用于取消或阻止浏览器对特定事件的默认处理，确保拖放操作能够按照自定义逻辑执行（例如允许放置、阻止默认文件打开行为）。</p></blockquote></li><li><p><strong>Web Workers</strong></p><p>Web Workers 允许在后台线程运行 JavaScript，不阻塞主线程。适用于耗时操作（如复杂计算、数据处理），提升页面响应速度和用户体验。</p><p>特点：</p><p>1、异步线程：运行在单独的线程中，与主线程通信通过 postMessage 和 onmessage。<br>2、无 DOM 访问权限：Workers 无法直接操作 DOM，需通过主线程间接操作。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> Worker(<span class="hljs-string">&#x27;worker.js&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>WebSocket</strong></p><p>WebSocket 是 HTML5 提供的一种实时双向通信协议，允许浏览器和服务器在单个持久连接上进行数据交换。适用于聊天、实时更新等应用。</p><p>特点：</p><p>1、双向通信：浏览器和服务器都能主动发送和接收数据。<br>2、低延迟：持久连接降低了通信延迟，适合实时场景。<br>3、轻量级：相比 HTTP 长轮询，WebSocket 更高效。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const WebSocket</span> = require(<span class="hljs-string">&#x27;ws&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>src和href的区别</tag>
      
      <tag>HTML语义化的理解</tag>
      
      <tag>DOCTYPE的作用</tag>
      
      <tag>常用的meta标签</tag>
      
      <tag>HTML5有哪些更新</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSP第35次_01：密码</title>
    <link href="/2024/12/08/CSP01/"/>
    <url>/2024/12/08/CSP01/</url>
    
    <content type="html"><![CDATA[<h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>西西艾弗网对用户密码有一套安全级别评定标准。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在西西艾弗网上，用户的密码是一个由大写字母（<code>A-Z</code>）、小写字母（<code>a-z</code>）、数字（<code>0-9</code>）和特殊字符（<code>*</code> 和 <code>#</code>）共 6464 种字符组成的字符串。</p><p>根据复杂程度不同，密码安全度被分为高、中、低三档。</p><ul><li>高：由上述 6464 种字符组成，长度大于等于 66 个字符，包含字母、数字和特殊字符，同一个字符出现不超过 22 次；</li><li>中：由上述 6464 种字符组成，长度大于等于 66 个字符，包含字母、数字和特殊字符，且未达到高安全度要求；</li><li>低：由上述 6464 种字符组成，长度大于等于 66 个字符，且未达到中安全度要求；</li></ul><p>小 P 为自己准备了 n<em>n</em> 个候选密码，试编写程序帮小 P 自动判别每个密码的安全级别。保证这 n<em>n</em> 个密码都至少满足低安全度要求，当安全度为高、中、低时分别输出 <code>2</code>、<code>1</code>、<code>0</code> 即可。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>从标准输入读入数据。</p><p>输入共 n+1<em>n</em>+1 行。</p><p>第一行包含一个正整数 n<em>n</em>，表示待判别的密码个数；</p><p>接下来 n<em>n</em> 行，每行一个字符串，表示一个安全度至少为低的候选密码。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出到标准输出。</p><p>输出共 n<em>n</em> 行，每行输出一个整数 <code>2</code>、<code>1</code> 或 <code>0</code>，表示对应密码的安全度。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">4<br>csp#ccsp<br>csp#ccsp2024<br>Csp#ccsp2024<br>CSP#2024<br></code></pre></td></tr></table></figure><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">0<br>1<br>2<br>2<br></code></pre></td></tr></table></figure><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p>第一个密码不含数字，安全度为低；</p><p>第二个密码中小写字母 <code>c</code> 出现 33 次，安全度为中；</p><p>和第二个密码相比，第三个密码把一个小写字母 <code>c</code> 变为了大写，满足了高安全度要求；</p><p>第四个密码同样满足高安全度要求。</p><h2 id="子任务"><a href="#子任务" class="headerlink" title="子任务"></a>子任务</h2><p>全部的测试数据满足 n≤100<em>n</em>≤100，且输入的每个字符串均不超过 2020 个字符。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这道题很简单，主要是对于字符的判断（数字、大小写字母、特殊字符）。</p><p>使用<strong>正则表达式</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">judge_security</span>(<span class="hljs-params">u_pwd</span>):<br>    <span class="hljs-keyword">if</span> re.search(<span class="hljs-string">r&#x27;[a-z]&#x27;</span>, u_pwd) <span class="hljs-keyword">or</span> re.search(<span class="hljs-string">r&#x27;[A-Z]&#x27;</span>, u_pwd):<br>        <span class="hljs-keyword">if</span> re.search(<span class="hljs-string">r&#x27;[0-9]&#x27;</span>, u_pwd):<br>            <span class="hljs-keyword">if</span> re.search(<span class="hljs-string">r&#x27;[^a-zA-Z0-9]&#x27;</span>, u_pwd):<br>                char_dict = Counter(u_pwd)<br>                char_show_nums = <span class="hljs-built_in">list</span>(char_dict.values())<br>                <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> char_show_nums:<br>                    <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">2</span>:<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><p>更简洁：</p><p>使用<code>bool</code>和<code>not</code>和<code>any</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">judge_security</span>(<span class="hljs-params">u_pwd</span>):          <br>    <span class="hljs-comment"># 判断密码中是否包含字母、数字和特殊字符</span><br>    has_letter = <span class="hljs-built_in">bool</span>(re.search(<span class="hljs-string">r&#x27;[a-zA-Z]&#x27;</span>, u_pwd))<br>    has_digit = <span class="hljs-built_in">bool</span>(re.search(<span class="hljs-string">r&#x27;[0-9]&#x27;</span>, u_pwd))<br>    has_special = <span class="hljs-built_in">bool</span>(re.search(<span class="hljs-string">r&#x27;[^a-zA-Z0-9]&#x27;</span>, u_pwd)) <br>    <br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(has_letter <span class="hljs-keyword">and</span> has_digit <span class="hljs-keyword">and</span> has_special):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <br>    char_count = Counter(u_pwd)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(count &gt; <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> count <span class="hljs-keyword">in</span> char_count.values()):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p><strong>字符判断</strong></p><blockquote><p>1、使用内置函数：</p><ul><li><code>isnumeric()</code>：检查字符串是否只包含数字字符。</li><li><code>isalpha()</code>：检查字符串是否只包含字母。</li><li><code>isspace()</code>：检查字符串是否只包含空白字符（如空格、制表符、换行符等）。</li><li><code>ispunct()</code>：检查字符串是否只包含标点符号。</li><li><code>isalnum()</code>：检查字符串是否只包含字母和数字。</li><li><code>isupper()</code> 方法判断是否为大写字母。</li><li><code>islower()</code> 方法判断是否为小写字母。</li></ul></blockquote><blockquote><p>2、使用正则表达式：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">re.search(<span class="hljs-string">r&#x27;[a-zA-Z]&#x27;</span>, u_pwd) <span class="hljs-comment"># 字母</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">re.search(<span class="hljs-string">r&#x27;[0-9]&#x27;</span>, u_pwd) <span class="hljs-comment"># 数字</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">re.search(<span class="hljs-string">r&#x27;^[a-zA-Z0-9]&#x27;</span>, u_pwd) <span class="hljs-comment"># 特殊字符</span><br></code></pre></td></tr></table></figure></blockquote><blockquote><p>3、使用ASCII值：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;0&#x27;</span> &lt;= <span class="hljs-type">char</span> &lt;= <span class="hljs-string">&#x27;9&#x27;</span>:<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;数字&quot;</span><br>   elif <span class="hljs-string">&#x27;A&#x27;</span> &lt;= <span class="hljs-type">char</span> &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;a&#x27;</span> &lt;= <span class="hljs-type">char</span> &lt;= <span class="hljs-string">&#x27;z&#x27;</span>:<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;字母&quot;</span><br>   <span class="hljs-keyword">else</span>:<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;特殊字符&quot;</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>re.search和re.match的区别</strong></p><blockquote><p>re.match 只能在<strong>起始</strong>位置匹配，而re.search可以扫描<strong>整个</strong>字符串并返回<strong>第一个</strong>成功的匹配</p><p>re.findall 方法可以找到<strong>所有</strong>满足匹配条件的结果，并以列表的形式返回</p></blockquote><p><strong>字符统计出现次数</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br></code></pre></td></tr></table></figure><blockquote><p>主要功能：可以支持方便、快速的计数，将元素数量统计，然后计数并返回一个字典，键为元素，值为元素个数。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CSP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>题库</tag>
      
      <tag>字符判断</tag>
      
      <tag>字符统计</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode09：找到字符串中所有字母异位词</title>
    <link href="/2024/12/07/LeetCode09/"/>
    <url>/2024/12/07/LeetCode09/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode09：找到字符串中所有字母异位词"><a href="#LeetCode09：找到字符串中所有字母异位词" class="headerlink" title="LeetCode09：找到字符串中所有字母异位词"></a>LeetCode09：找到字符串中所有字母异位词</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>示例 1:</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;cbaebabacd&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出: <span class="hljs-selector-attr">[0,6]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;cba&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">6</span> 的子串是 <span class="hljs-string">&quot;bac&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><p> <strong>示例 2:</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;abab&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;ab&quot;</span><br>输出: <span class="hljs-selector-attr">[0,1,2]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">1</span> 的子串是 <span class="hljs-string">&quot;ba&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">2</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>使用的是双层for循环，通过将p字符串的字母添加到列表，再依次遍历s字符串中数量为len(p)的字符，如果遍历到的字符属于列表，就将列表中的字符remove移除。如果遍历完后，列表为空，则证明此次遍历符合要求。否则进行下一次遍历。每次遍历都需要重新初始化列表。</p><p>缺点：遇到字符串超级长的时候，会超出时间限制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findAnagrams</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, p: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        res = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            char_in_b = [c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> p]<br>            num = <span class="hljs-built_in">len</span>(char_in_b)<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i,i+num):<br>                <span class="hljs-keyword">if</span> j &gt; <span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">if</span> s[j] <span class="hljs-keyword">in</span> char_in_b:<br>                    char_in_b.remove(s[j])<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> char_in_b == []:<br>                res.append(i)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><p><strong>初始化滑动窗口</strong></p><p>依次在s和p中初始化滑动窗口，并且初始化26个字母的数组用来统计两个窗口中出现的字母次数。</p><p><strong>特殊情况</strong></p><p>首先考虑特殊情况，当p字符串比s字符串长，肯定不存在，返回空列表结果。</p><p><strong>比较初始窗口</strong></p><p>再比较两个初始化滑动窗口中的字母统计，是否相等，相等就添加一个初始化索引0。</p><p><strong>开始滑动</strong></p><p>开始滑动，滑动次数为<code>len_s - len_p</code>，<code>s[i]</code>对应的是左边待剔除的字母，需要-1；<code>s[i+len(p)]</code>对应的是右边待进入的字母，需要+1。每次滑动，需要比较字母统计是否相等，如果相等，结果需要添加<code>i+1</code>，因为滑动后的起始索引加1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findAnagrams</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, p: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]:<br>        res = []<br>        <span class="hljs-comment"># 特殊情况</span><br>        len_s = <span class="hljs-built_in">len</span>(s)<br>        len_p = <span class="hljs-built_in">len</span>(p)<br>        <span class="hljs-keyword">if</span> len_p &gt; len_s:<br>            <span class="hljs-keyword">return</span> []<br>        <span class="hljs-comment"># 初始化窗口</span><br>        s_count = [<span class="hljs-number">0</span>] * <span class="hljs-number">26</span><br>        p_count = [<span class="hljs-number">0</span>] * <span class="hljs-number">26</span><br>        <span class="hljs-comment"># 比较初始化窗口中的内容</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len_p):<br>            s_count[<span class="hljs-built_in">ord</span>(s[i]) - <span class="hljs-number">97</span>] += <span class="hljs-number">1</span><br>            p_count[<span class="hljs-built_in">ord</span>(p[i]) - <span class="hljs-number">97</span>] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> s_count == p_count:<br>            res.append(<span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 逐个滑动窗口</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(len_s - len_p):<br>            s_count[<span class="hljs-built_in">ord</span>(s[i]) - <span class="hljs-number">97</span>] -= <span class="hljs-number">1</span><br>            s_count[<span class="hljs-built_in">ord</span>(s[i+len_p]) - <span class="hljs-number">97</span>] += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> s_count == p_count:<br>                res.append(i+<span class="hljs-number">1</span>)           <br>        <span class="hljs-keyword">return</span> res <br></code></pre></td></tr></table></figure><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p><strong>根据字母获取对应字母表的索引</strong></p><blockquote><p><code>&#39;a&#39;</code> 的 Unicode 码点值是 97 (<code>ord(&#39;a&#39;) == 97</code>)</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">ord</span><span class="hljs-params">(char)</span></span> - <span class="hljs-number">97</span><br></code></pre></td></tr></table></figure><p><strong>滑动</strong></p><blockquote><p>滑动次数是两个字符串的长度差，当前for循环其实是滑动前的状态，因为 i 从0开始的。</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span> i in range(len_s - len_p):<br>    <span class="hljs-attribute">s_count</span>[ord(s[i]) - <span class="hljs-number">97</span>] -= <span class="hljs-number">1</span><br>    <span class="hljs-attribute">s_count</span>[ord(s[i+len_p]) - <span class="hljs-number">97</span>] += <span class="hljs-number">1</span><br>    <span class="hljs-attribute">if</span> s_count == p_count:<br>    <span class="hljs-attribute">res</span>.append(i+<span class="hljs-number">1</span>)     <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>题库</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>数组初始化</tag>
      
      <tag>字母统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT08：锤子剪刀布</title>
    <link href="/2024/12/06/PAT08/"/>
    <url>/2024/12/06/PAT08/</url>
    
    <content type="html"><![CDATA[<h1 id="8-锤子剪刀布"><a href="#8-锤子剪刀布" class="headerlink" title="8.锤子剪刀布"></a>8.锤子剪刀布</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">大家应该都会玩“锤子剪刀布”的游戏：<br>现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。<br></code></pre></td></tr></table></figure><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">输入第<span class="hljs-number">1</span>行给出正整数<span class="hljs-built_in">N</span>（<span class="hljs-operator">&lt;=</span><span class="hljs-number">105</span>），即双方交锋的次数。随后<span class="hljs-built_in">N</span>行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。<span class="hljs-built_in">C</span>代表“锤子”、<span class="hljs-variable">J</span>代表“剪刀”、<span class="hljs-variable">B</span>代<br>表“布”，第<span class="hljs-number">1</span>个字母代表甲方，第<span class="hljs-number">2</span>个代表乙方，中间有<span class="hljs-number">1</span>个空格。<br></code></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">输出第1、2行分别给出甲、乙的胜、平、负次数，数字间以1个空格分隔。第3行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有1个空格。如果解不唯一，则输出按字母序最小的解。<br></code></pre></td></tr></table></figure><h3 id="输入例子"><a href="#输入例子" class="headerlink" title="输入例子:"></a><strong>输入例子:</strong></h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">10</span><br>C <span class="hljs-keyword">J</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">J </span><span class="hljs-keyword">B</span><br><span class="hljs-keyword"></span>C <span class="hljs-keyword">B</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">B </span><span class="hljs-keyword">B</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">B </span>C<br>C C<br>C <span class="hljs-keyword">B</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">J </span><span class="hljs-keyword">B</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">B </span>C<br><span class="hljs-keyword">J </span><span class="hljs-keyword">J</span><br></code></pre></td></tr></table></figure><h3 id="输出例子"><a href="#输出例子" class="headerlink" title="输出例子:"></a><strong>输出例子:</strong></h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">5</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">B</span> B<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import sys<br><br>lst = sys<span class="hljs-selector-class">.stdin</span><span class="hljs-selector-class">.readlines</span>()<br>playNum = lst<span class="hljs-selector-attr">[0]</span><br><br>win_a = <span class="hljs-number">0</span><br>draw_a = <span class="hljs-number">0</span><br>lose_a = <span class="hljs-number">0</span><br>win_b = <span class="hljs-number">0</span><br>draw_b = <span class="hljs-number">0</span><br>lose_b = <span class="hljs-number">0</span><br>a_c = <span class="hljs-number">0</span><br>a_j = <span class="hljs-number">0</span><br>a_b = <span class="hljs-number">0</span><br>b_c = <span class="hljs-number">0</span><br>b_j = <span class="hljs-number">0</span><br>b_b = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lst<span class="hljs-selector-attr">[1:]</span>:<br>    line = line<span class="hljs-selector-class">.split</span>(<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-selector-tag">a</span> = line<span class="hljs-selector-attr">[0]</span><br>    <span class="hljs-selector-tag">b</span> = line<span class="hljs-selector-attr">[1]</span><span class="hljs-selector-class">.strip</span>()<br>    <span class="hljs-keyword">if</span> <span class="hljs-selector-tag">a</span> == <span class="hljs-selector-tag">b</span>:<br>        draw_a += <span class="hljs-number">1</span><br>        draw_b += <span class="hljs-number">1</span><br>    elif <span class="hljs-selector-tag">a</span> == <span class="hljs-string">&#x27;C&#x27;</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-selector-tag">b</span> == <span class="hljs-string">&#x27;B&#x27;</span>:<br>            lose_a += <span class="hljs-number">1</span><br>            win_b += <span class="hljs-number">1</span><br>            b_b += <span class="hljs-number">1</span><br>        elif <span class="hljs-selector-tag">b</span> == <span class="hljs-string">&#x27;J&#x27;</span>:<br>            win_a += <span class="hljs-number">1</span><br>            lose_b += <span class="hljs-number">1</span><br>            a_c += <span class="hljs-number">1</span><br>    elif <span class="hljs-selector-tag">a</span> == <span class="hljs-string">&#x27;J&#x27;</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-selector-tag">b</span> == <span class="hljs-string">&#x27;B&#x27;</span>:<br>            win_a += <span class="hljs-number">1</span><br>            lose_b += <span class="hljs-number">1</span><br>            a_j += <span class="hljs-number">1</span><br>            <br>        elif <span class="hljs-selector-tag">b</span> == <span class="hljs-string">&#x27;C&#x27;</span>:<br>            lose_a += <span class="hljs-number">1</span><br>            win_b += <span class="hljs-number">1</span><br>            b_c += <span class="hljs-number">1</span><br>    elif <span class="hljs-selector-tag">a</span> == <span class="hljs-string">&#x27;B&#x27;</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-selector-tag">b</span> == <span class="hljs-string">&#x27;J&#x27;</span>:<br>            lose_a += <span class="hljs-number">1</span><br>            win_b += <span class="hljs-number">1</span><br>            b_b += <span class="hljs-number">1</span><br>        elif <span class="hljs-selector-tag">b</span> == <span class="hljs-string">&#x27;C&#x27;</span>:<br>            win_a += <span class="hljs-number">1</span><br>            lose_b += <span class="hljs-number">1</span><br>            a_b += <span class="hljs-number">1</span><br><br>a_all = <span class="hljs-selector-attr">[a_b, a_j, a_c]</span><br>a_paly = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]</span><br>b_all = <span class="hljs-selector-attr">[b_b, b_j, b_c]</span><br>b_paly = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]</span><br><br>maxNum_a = <span class="hljs-built_in">max</span>(a_all)<br>maxNum_b = <span class="hljs-built_in">max</span>(b_all)<br>most_a = None<br>most_b = None<br><br><span class="hljs-keyword">for</span> index, <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a_all):<br>    <span class="hljs-keyword">if</span> <span class="hljs-selector-tag">i</span> == maxNum_a:<br>        <span class="hljs-keyword">if</span> most_a is None:<br>            most_a = a_paly<span class="hljs-selector-attr">[index]</span><br>        elif <span class="hljs-built_in">ord</span>(a_paly<span class="hljs-selector-attr">[index]</span>) &lt;= <span class="hljs-built_in">ord</span>(most_a):<br>            most_a = a_paly<span class="hljs-selector-attr">[index]</span><br><span class="hljs-keyword">for</span> index, <span class="hljs-selector-tag">i</span>  <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(b_all):<br>    <span class="hljs-keyword">if</span> <span class="hljs-selector-tag">i</span> == maxNum_b:<br>        <span class="hljs-keyword">if</span> most_b is None:<br>            most_b = b_paly<span class="hljs-selector-attr">[index]</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">ord</span>(b_paly<span class="hljs-selector-attr">[index]</span>) &lt;= <span class="hljs-built_in">ord</span>(most_b):<br>            most_b = b_paly<span class="hljs-selector-attr">[index]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(win_a, draw_a, lose_a)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(win_b, draw_b, lose_b)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(most_a, most_b)</span></span><br></code></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><strong>若最大值相同，按字母顺序选择</strong></p><blockquote><p>直接先按照字母顺序排列，依次判断是否为最大值</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">most_win</span>(<span class="hljs-params">b, c, j</span>):<br>    <span class="hljs-keyword">if</span> b == <span class="hljs-built_in">max</span>(b, c, j):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;B&#x27;</span><br>    <span class="hljs-keyword">elif</span> c == <span class="hljs-built_in">max</span>(b, c, j):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;C&#x27;</span><br>    <span class="hljs-keyword">elif</span> j == <span class="hljs-built_in">max</span>(b, c, j):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;J&#x27;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>题库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode08：无重复字符的最长子串</title>
    <link href="/2024/07/17/LeetCode08/"/>
    <url>/2024/07/17/LeetCode08/</url>
    
    <content type="html"><![CDATA[<h1 id="8-无重复字符的最长子串"><a href="#8-无重复字符的最长子串" class="headerlink" title="8.无重复字符的最长子串"></a>8.无重复字符的最长子串</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>首先考虑特殊情况，如果字符串为空，结果为0</p><p>初始化一个字典lettersIndex ，用于存储字符和相应的索引；</p><p>初始化最长不重复子串的长度max_length ，0</p><p>初始化子串的起始索引start ，0</p><p><strong>遍历字符串，获取每一个字符和其索引。</strong></p><ul><li><p>检查当前字符，如果在字典中，并且字典中该字符的索引不小于start ，代表已经重复，更新start （该字符在字典中的索引加1，也就是起始索引加1），更新字典中该字符的索引为当前索引。</p></li><li><p>遍历每一个字符，需要计算当前子串的长度，<code>i - start + 1</code></p></li><li><p>更新全局最大长度。<code>max_length = max(max_length, current_length)</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        lettersIndex = &#123;&#125;<br>        max_length = <span class="hljs-number">0</span><br>        start = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> i, char <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">in</span> lettersIndex <span class="hljs-keyword">and</span> lettersIndex[char] &gt;= start:<br>                start = lettersIndex[char] + <span class="hljs-number">1</span><br><br>            lettersIndex[char] = i<br>            current_length = i - start + <span class="hljs-number">1</span><br>            max_length = <span class="hljs-built_in">max</span>(max_length, current_length)<br><br>        <span class="hljs-keyword">return</span> max_length<br></code></pre></td></tr></table></figure><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h3><p>这种方法的<strong>核心思想</strong>是使用两个指针（左指针和右指针）来维护一个动态的窗口，窗口内的字符都是不重复的。通过不断移动这两个指针，可以找到最长的不重复子串。</p><ol><li><strong>初始化变量</strong>:<ul><li><code>occ = set()</code> 初始化一个集合，用于记录当前子串中出现的字符。</li><li><code>n = len(s)</code> 获取字符串 <code>s</code> 的长度。</li><li><code>rk, ans = -1, 0</code> 初始化右指针 <code>rk</code> 为 -1（表示在字符串左侧），初始化最长子串长度 <code>ans</code> 为 0。</li></ul></li><li><strong>遍历字符串</strong>:<ul><li><code>for i in range(n):</code> 遍历字符串 <code>s</code> 的每一个字符。</li></ul></li><li><strong>左指针移动</strong>:<ul><li><code>if i != 0:</code> 当不是第一个字符时，将左指针左侧的字符从集合中移除，从而缩小子串的范围。</li></ul></li><li><strong>右指针移动</strong>:<ul><li><code>while rk + 1 &lt; n and s[rk + 1] not in occ:</code> 只要右指针右侧的字符不在当前集合中，就不断移动右指针，并将字符加入集合。</li></ul></li><li><strong>更新最长子串长度</strong>:<ul><li><code>ans = max(ans, rk - i + 1)</code> 更新最长不重复子串的长度。这里 <code>rk - i + 1</code> 表示从左指针 <code>i</code> 到右指针 <code>rk</code> 的子串长度。</li></ul></li><li><strong>返回结果</strong>:<ul><li><code>return ans</code> 返回最长不重复子串的长度。</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-comment"># 哈希集合，记录每个字符是否出现过</span><br>        occ = <span class="hljs-built_in">set</span>()<br>        n = <span class="hljs-built_in">len</span>(s)<br>        <span class="hljs-comment"># 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span><br>        rk, ans = -<span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> i != <span class="hljs-number">0</span>:<br>                <span class="hljs-comment"># 左指针向右移动一格，移除一个字符</span><br>                occ.remove(s[i - <span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">while</span> rk + <span class="hljs-number">1</span> &lt; n <span class="hljs-keyword">and</span> s[rk + <span class="hljs-number">1</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> occ:<br>                <span class="hljs-comment"># 不断地移动右指针</span><br>                occ.add(s[rk + <span class="hljs-number">1</span>])<br>                rk += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 第 i 到 rk 个字符是一个极长的无重复字符子串</span><br>            ans = <span class="hljs-built_in">max</span>(ans, rk - i + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>题库</tag>
      
      <tag>哈希表</tag>
      
      <tag>双指针</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT07：A除以B</title>
    <link href="/2024/07/17/PAT07/"/>
    <url>/2024/07/17/PAT07/</url>
    
    <content type="html"><![CDATA[<h1 id="7-A除以B"><a href="#7-A除以B" class="headerlink" title="7.A除以B"></a>7.A除以B</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">本题要求计算<span class="hljs-keyword">A</span>/B，其中<span class="hljs-keyword">A</span>是不超过<span class="hljs-number">1000</span>位的正整数，B是<span class="hljs-number">1</span>位正整数。你需要输出商数Q和余数R，使得<span class="hljs-keyword">A</span> = B * Q + R成立。<br></code></pre></td></tr></table></figure><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">输入在<span class="hljs-number">1</span>行中依次给出<span class="hljs-selector-tag">A</span>和<span class="hljs-selector-tag">B</span>，中间以<span class="hljs-number">1</span>空格分隔。<br></code></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">在<span class="hljs-number">1</span>行中依次输出<span class="hljs-selector-tag">Q</span>和R，中间以<span class="hljs-number">1</span>空格分隔。<br></code></pre></td></tr></table></figure><h3 id="输入例子"><a href="#输入例子" class="headerlink" title="输入例子:"></a><strong>输入例子:</strong></h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">123456789050987654321 </span><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h3 id="输出例子"><a href="#输出例子" class="headerlink" title="输出例子:"></a><strong>输出例子:</strong></h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">17636684150141093474 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>太简单了。。</p><p>求商—-&gt; <code>//</code></p><p>求余—-&gt;<code>%</code></p><p>输出以空格分割—-&gt; <code>print(a,b)</code></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">import sys<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">line</span> <span class="hljs-keyword">in</span> sys.<span class="hljs-keyword">stdin</span>:<br>    <span class="hljs-keyword">a</span>,b = <span class="hljs-built_in">line</span>.strip().<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-keyword">a</span>,b = int(<span class="hljs-keyword">a</span>),int(b)<br>    q = <span class="hljs-comment">a//b</span><br>    r = <span class="hljs-keyword">a</span> % b <br>    print(q,r)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>题库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode07：接雨水</title>
    <link href="/2024/06/15/LeetCode07/"/>
    <url>/2024/06/15/LeetCode07/</url>
    
    <content type="html"><![CDATA[<h1 id="7-接雨水"><a href="#7-接雨水" class="headerlink" title="7.接雨水"></a>7.接雨水</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202406171729580.png" alt="image-20240615192506854"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="（1）动态规划法"><a href="#（1）动态规划法" class="headerlink" title="（1）动态规划法"></a>（1）动态规划法</h3><p>动态规划（Dynamic Programming, DP）是一种算法设计技巧，它将一个复杂的问题分解为更小的子问题，并存储这些子问题的解，以避免重复计算。这种方法特别适用于具有以下两个特性的问题：</p><ol><li><strong>重叠子问题</strong>：问题可以分解为多个子问题，这些子问题会重复出现多次。</li><li><strong>最优子结构</strong>：问题的最优解包含其子问题的最优解。</li></ol><p><strong>思路</strong></p><ol><li>对于下标<code>i</code>，雨水能达到的最大高度是<code>i</code>两边的最大高度的最小值。</li><li>对于下标<code>i</code>，雨水量是能达到的最大高度减去<code>i</code>处的柱子高度<code>height[i]</code></li></ol><ul><li>如何计算两边的最大高度呢？</li></ul><p>朴素的做法是：对于每一个位置，分别向左和向右扫描，记录左右两边的最大高度。</p><p>时间复杂度：O($n^2$)</p><p><strong>动态规划法：</strong>如果已知每个位置两边的最大高度，就可以在O(n)的时间得出结果。</p><p>时间复杂度：O(n)</p><ul><li>如何计算每个位置两边的最大高度呢</li></ul><p>创建2个长度为n的数组<code>leftMax</code>和<code>rightMax</code>。<code>leftMax[i]</code>表示下标<code>i</code>及其左边位置的最大高度，<code>rightMax[i]</code>表示下标<code>i</code>及其右边位置的最大高度。</p><p>显然，两端的元素已经确定。<code>leftMax[0] = height[0]</code>，<code>rightMax[n-1]=height[n-1]</code></p><p>其他元素的计算方式：正向遍历数组height得到<code>leftMax</code>，反向遍历数组height得到<code>rightMax</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">trap</span>(<span class="hljs-params">self, height</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> height:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        n = <span class="hljs-built_in">len</span>(height)<br>        <br>        leftMax = [height[<span class="hljs-number">0</span>]] + [<span class="hljs-number">0</span>] * (n-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>            leftMax[i] = <span class="hljs-built_in">max</span>(leftMax[i-<span class="hljs-number">1</span>],height[i])<br>            <br>        rightMax = [<span class="hljs-number">0</span>] * (n-<span class="hljs-number">1</span>) + [height[n-<span class="hljs-number">1</span>]]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>            rightMax[i] = <span class="hljs-built_in">max</span>(rightMax[i+<span class="hljs-number">1</span>],height[i])<br>        <br>        ans = <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">min</span>(leftMax[i],rightMax[i])-height[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n))<br>        <span class="hljs-keyword">return</span> ans<br><br></code></pre></td></tr></table></figure><h2 id="（2）单调栈"><a href="#（2）单调栈" class="headerlink" title="（2）单调栈"></a>（2）单调栈</h2><p>维护一个单调栈，单调栈存储的是下标，满足从栈底到栈顶的下标对应的数组 <code>height</code>中的元素递减。</p><p>从左到右遍历<code>height</code>数组，遍历到下标<code>i</code>的时候，如果栈内至少有2个元素，栈顶为<code>top</code>，<code>top</code>下面是<code>left</code>，则一定有<code>height[top]&lt;=height[left]</code>。如果<code>height[i] &gt; height[top]</code>，则可以接到雨水。</p><p>雨水的宽度：<code>i - left -1</code></p><p>雨水的高度：<code>min(height[left],height[i]) - height[top]</code></p><p><strong>循环条件</strong></p><p>为了得到<code>left</code>，需要将<code>top</code>出栈，对<code>top</code>计算能接到的雨水量后，<code>left</code>就变成了新的<code>top</code>，如此重复操作，直到栈为空或者栈顶对应的元素大于或等于<code>height[i]</code>。完成对<code>top</code>和<code>i</code>的计算后，将<code>i</code>入栈，继续遍历。</p><p>时间复杂度：O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">trap</span>(<span class="hljs-params">self, height</span>):<br>        ans = <span class="hljs-number">0</span><br>        stack = <span class="hljs-built_in">list</span>()<br>        n = <span class="hljs-built_in">len</span>(height)<br>        <br>        <span class="hljs-keyword">for</span> i, h <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(height):<br>            <span class="hljs-keyword">while</span> stack <span class="hljs-keyword">and</span> h &gt; height[stack[-<span class="hljs-number">1</span>]]:<br>                top = stack.pop()<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> stack:<br>                    <span class="hljs-keyword">break</span><br>                left = stack[-<span class="hljs-number">1</span>]<br>                currWidth = i - left - <span class="hljs-number">1</span><br>                currHeight = <span class="hljs-built_in">min</span>(height[left], height[i]) - height[top]<br>                ans += currWidth * currHeight<br>            stack.append(i)<br>        <br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h3 id="（3）-双指针"><a href="#（3）-双指针" class="headerlink" title="（3） 双指针"></a>（3） 双指针</h3><p>在动态规划中，需要维护两个数组<code>leftMax</code>和<code>rightMax</code>，因此空间复杂度是O(n)。使用双指针和双变量可以代替两个数组，使得空间复杂度是O(1)。</p><p><strong>初始值：</strong>指针<code>left=0</code>，指针<code>right=len(height)-1</code>,两个变量<code>leftMax=0,rightMax=0</code></p><p>下标<code>i</code>能接的雨水量由<code>leftMax[i]</code>和<code>rightMax[i]</code>的最小值决定。</p><p>指针<code>left</code>只能右移，指针<code>right</code>只能左移，移动指针过程中需要维护两个变量<code>leftMax</code>和<code>rightMax</code>的值。</p><p><strong>当两个指针没有相遇时：</strong><code>（while left &lt; right）</code></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202406171729670.png" alt="image-20240617172305647"></p><p><strong>时间复杂度：</strong>O(n)，其中 n是数组的长度，两个指针的移动总次数不超过 n。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">trap</span>(<span class="hljs-params">self, height</span>):<br>        ans = <span class="hljs-number">0</span><br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(height) - <span class="hljs-number">1</span><br>        leftMax = rightMax = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            leftMax = <span class="hljs-built_in">max</span>(leftMax, height[left])<br>            rightMax = <span class="hljs-built_in">max</span>(rightMax, height[right])<br>            <span class="hljs-keyword">if</span> height[left] &lt; height[right]:<br>                ans += leftMax - height[left]<br>                left += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                ans += rightMax - height[right]<br>                right -= <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>题库</tag>
      
      <tag>双指针</tag>
      
      <tag>单调栈</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT06：部分A+B</title>
    <link href="/2024/05/29/PAT06/"/>
    <url>/2024/05/29/PAT06/</url>
    
    <content type="html"><![CDATA[<h1 id="6-部分A-B"><a href="#6-部分A-B" class="headerlink" title="6.部分A+B"></a>6.部分A+B</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">正整数<span class="hljs-keyword">A</span>的“DA（为<span class="hljs-number">1</span>位整数）部分”定义为由<span class="hljs-keyword">A</span>中所有DA组成的新整数PA。例如：给定<span class="hljs-keyword">A</span> = <span class="hljs-number">3862767</span>，DA = <span class="hljs-number">6</span>，则<span class="hljs-keyword">A</span>的“<span class="hljs-number">6</span>部分”PA是<span class="hljs-number">66</span>，因为<span class="hljs-keyword">A</span>中有<span class="hljs-number">2</span>个<span class="hljs-number">6</span>。<br> <br> 现给定<span class="hljs-keyword">A</span>、DA、B、DB，请编写程序计算PA + PB。<br></code></pre></td></tr></table></figure><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">输入在一行中依次给出<span class="hljs-selector-tag">A</span>、DA、<span class="hljs-selector-tag">B</span>、DB，中间以空格分隔，其中<span class="hljs-number">0</span> &lt; <span class="hljs-selector-tag">A</span>, <span class="hljs-selector-tag">B</span> &lt; <span class="hljs-number">1010</span>。<br></code></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">在一行中输出PA + PB的值。<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题比较简单。需要掌握的是如何在一个整数中统计某个数字的计数。</p><p>方法：转换为字符串，使用字符串的count方法。</p><p>另外，n个相同的数字转换为整数使用range方法作为10的次方求和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:<br>    a,da,b,db = line.strip().split(<span class="hljs-string">&#x27; &#x27;</span>)<br>    num1 = <span class="hljs-built_in">str</span>(a).count(da)<br>    num2 = <span class="hljs-built_in">str</span>(b).count(db)<br>    p1 = <span class="hljs-built_in">sum</span>([<span class="hljs-built_in">int</span>(da) * <span class="hljs-number">10</span> ** i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num1)])<br>    p2 = <span class="hljs-built_in">sum</span>([<span class="hljs-built_in">int</span>(db) * <span class="hljs-number">10</span> ** i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num2)])<br>    res = p1+p2<br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>题库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode06：三数之和</title>
    <link href="/2024/05/16/LeetCode06/"/>
    <url>/2024/05/16/LeetCode06/</url>
    
    <content type="html"><![CDATA[<h1 id="6-三数之和"><a href="#6-三数之和" class="headerlink" title="6.三数之和"></a>6.三数之和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="（一）暴力解法（三重循环）"><a href="#（一）暴力解法（三重循环）" class="headerlink" title="（一）暴力解法（三重循环）"></a>（一）暴力解法（三重循环）</h3><p>使用三层嵌套循环来枚举所有可能的三个数的组合。</p><p><strong>时间复杂度：</strong>对于每个元素a，它都与后面所有可能的b和c元素进行了比较。为O($n^3$)，n是数组的长度。</p><p><strong>空间复杂度：</strong>由于 <code>arr</code> 可能包含大量的三元组，所以这部分的空间复杂度是最高的，为 O($n^3$)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">compareArr</span>(<span class="hljs-params">self,arr</span>):<br>        unique_str = []<br>        res = []<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> arr:<br>            new_str = <span class="hljs-string">&#x27;&#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>,<span class="hljs-built_in">sorted</span>(x)))<br>            <span class="hljs-keyword">if</span> new_str <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> unique_str:<br>                unique_str.append(new_str)<br>                res.append(x)<br>        <span class="hljs-keyword">return</span> res<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self, nums</span>):<br>        arr = []<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i,a <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums[:-<span class="hljs-number">2</span>]):<br>            <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> nums[i+<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> nums[i+<span class="hljs-number">2</span>+count:]:<br>                    <span class="hljs-keyword">if</span> a+b+c == <span class="hljs-number">0</span>:<br>                        arr.append([a,b,c])<br>                count = count + <span class="hljs-number">1</span><br>            count = <span class="hljs-number">0</span><br><br><br>        res = self.compareArr(arr)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="（二）双指针法"><a href="#（二）双指针法" class="headerlink" title="（二）双指针法"></a>（二）双指针法</h3><p>1、排序。先将 <code>nums</code> 排序，时间复杂度为 O(NlogN)。</p><p>2、特判。非数组返回空；数组首元素大于0返回空（因为后面的肯定比它大，和不可能为0）；数组长度小于3返回空；</p><p>3、设置指针。固定最左（最小）元素的指针a ，再使用左右指针指向a后面元素的两端，分别为l,r。</p><p>4、循环条件。</p><ul><li><p>左指针索引j要小于右指针索引k；</p></li><li><p>如果a大于0，则条件一定不能满足，结束循环；</p></li><li><p>如果a和前一个数字相等，说明数字重复，会导致结果重复，跳过；</p></li></ul><p>5、求和。</p><ul><li>如果和等于0，添加到结果列表。左指针右移，右指针左移。在此之前，都需要判断是否下一个元素重复，如果重复就跳过，因为会导致结果重复；</li><li>如果和大于0，右指针左移；</li><li>如果和小于0，左指针右移。（左右移动不需要考虑下一个元素重复，因为我们是在调整指针尝试可能的三元组，不需要担心重复。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self,nums</span>):<br>        nums = <span class="hljs-built_in">sorted</span>(nums)<br>        length = <span class="hljs-built_in">len</span>(nums)<br>        res = []<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums <span class="hljs-keyword">or</span> nums[<span class="hljs-number">0</span>]&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> length&lt;<span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">return</span> []<br>        <span class="hljs-keyword">for</span> i,a <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums[:-<span class="hljs-number">2</span>]):<br>            <span class="hljs-keyword">if</span> a&gt;<span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> res<br>            <span class="hljs-keyword">if</span> i&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i-<span class="hljs-number">1</span>] == a:<br>                <span class="hljs-keyword">continue</span><br>            j = i + <span class="hljs-number">1</span><br>            k = length - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span>(j&lt;k):<br>                l = nums[j]<br>                r = nums[k]<br>                total = a+l+r<br>                <span class="hljs-keyword">if</span> total == <span class="hljs-number">0</span>:<br>                   res.append([a,l,r])<br>                   <span class="hljs-keyword">while</span> j &lt; k <span class="hljs-keyword">and</span> nums[k-<span class="hljs-number">1</span>] == nums[k]:<br>                      k -= <span class="hljs-number">1</span><br>                   <span class="hljs-keyword">while</span> j&lt;k <span class="hljs-keyword">and</span> nums[j+<span class="hljs-number">1</span>]==nums[j]:<br>                      j += <span class="hljs-number">1</span><br>                   k-=<span class="hljs-number">1</span><br>                   j+=<span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> total &gt;=<span class="hljs-number">0</span>:<br>                    k -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> total &lt;= <span class="hljs-number">0</span>:<br>                    j += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202405161909060.png" alt="image-20240516190804739"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202405161909037.png" alt="image-20240516190813879"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202405161909064.png" alt="image-20240516190823405"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202405161909034.png" alt="image-20240516190830238"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202405161909077.png" alt="image-20240516190837075"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202405161909040.png" alt="image-20240516190843531"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202405161909441.png" alt="image-20240516190849453"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202405161909490.png" alt="image-20240516190857189"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202405161909541.png" alt="image-20240516190903303"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202405161909514.png" alt="image-20240516190908873"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202405161909538.png" alt="image-20240516190915484"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202405161909545.png" alt="image-20240516190922452"></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>题库</tag>
      
      <tag>双指针</tag>
      
      <tag>三重循环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT05：德才论</title>
    <link href="/2024/04/17/PAT05/"/>
    <url>/2024/04/17/PAT05/</url>
    
    <content type="html"><![CDATA[<h1 id="5-德才论"><a href="#5-德才论" class="headerlink" title="5.德才论"></a>5.德才论</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之<br> 小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。”<br> <br> 现给出一批考生的德才分数，请根据司马光的理论给出录取排名。<br></code></pre></td></tr></table></figure><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入第<span class="hljs-number">1</span>行给出<span class="hljs-number">3</span>个正整数，分别为：<span class="hljs-built_in">N</span>（&lt;=<span class="hljs-number">105</span>），即考生总数；L（&gt;=<span class="hljs-number">60</span>），为录取最低分数线，即德分和才分均不低于L的考生才有资格<br>被考虑录取；H（&lt;<span class="hljs-number">100</span>），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到<br>但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于H，但是德分不低于才分的考生属于“才德兼<br>亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线L的考生也按总分排序，但排在第三类考生之后。<br><br>随后<span class="hljs-built_in">N</span>行，每行给出一位考生的信息，包括：准考证号、德分、才分，其中准考证号为<span class="hljs-number">8</span>位整数，德才分为区间[<span class="hljs-number">0</span>, <span class="hljs-number">100</span>]内的整数。数字间以空格分隔。<br></code></pre></td></tr></table></figure><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">输出第1行首先给出达到最低分数线的考生人数M，随后M行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人<br>总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><strong>分类</strong></p><p>首先，参加排序的考生需要高于最低分数线，在此基础上分为四类：</p><p>1、德、才均高于优先录取线</p><p>2、德高于优先录取线</p><p>3、德、才均低于优先录取线，但德 &gt; 才</p><p>4、德、才均低于优先录取线，但德 &lt; 才</p><p><strong>排序</strong></p><p>将所有满足条件的考生分类完成，逐类排序。排序规则是：按总分排序，总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。</p><p><strong>输出</strong></p><p>按照输出格式，进行打印。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># 保存输入数据</span><br>inputs = []<br><span class="hljs-comment"># 保存输出数据</span><br>out1 = []<br>out2 = []<br>out3 = []<br>out4 = []<br><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:<br>    inputs.append([<span class="hljs-built_in">int</span>(item) <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> line.split()])<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(inputs) == inputs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">break</span><br><br><span class="hljs-comment"># 最低分数线</span><br>low_score = inputs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br><span class="hljs-comment"># 优先录取线</span><br>high_score = inputs[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">len</span>(inputs)):<br>    total = inputs[i][<span class="hljs-number">1</span>] + inputs[i][<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">if</span> inputs[i][<span class="hljs-number">1</span>] &gt;= high_score <span class="hljs-keyword">and</span> inputs[i][<span class="hljs-number">2</span>] &gt;= high_score:<br>        out1.append(inputs[i])<br>    <span class="hljs-keyword">elif</span> inputs[i][<span class="hljs-number">1</span>] &gt;= high_score <span class="hljs-keyword">and</span> low_score &lt;= inputs[i][<span class="hljs-number">2</span>] &lt; high_score:<br>        out2.append(inputs[i])<br>    <span class="hljs-keyword">elif</span> inputs[i][<span class="hljs-number">1</span>] &gt;= low_score <span class="hljs-keyword">and</span> inputs[i][<span class="hljs-number">2</span>] &gt;= low_score <span class="hljs-keyword">and</span> inputs[i][<span class="hljs-number">1</span>] &gt;= inputs[i][<span class="hljs-number">2</span>]:<br>        out3.append(inputs[i])<br>    <span class="hljs-keyword">elif</span> inputs[i][<span class="hljs-number">1</span>] &gt;= low_score <span class="hljs-keyword">and</span> inputs[i][<span class="hljs-number">2</span>] &gt;= low_score:<br>        out4.append(inputs[i])<br><br>out = [out1,out2,out3,out4]<br>res = []<br><span class="hljs-keyword">for</span> i,lst <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(out):<br>    lst = <span class="hljs-built_in">sorted</span>(lst,key=<span class="hljs-keyword">lambda</span> x:(x[<span class="hljs-number">1</span>]+x[<span class="hljs-number">2</span>],x[<span class="hljs-number">1</span>],-x[<span class="hljs-number">0</span>]),reverse=<span class="hljs-literal">True</span>)<br>    res += lst<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(res))<br><span class="hljs-keyword">for</span> lst <span class="hljs-keyword">in</span> res:<br>    <span class="hljs-built_in">print</span>(*lst,sep=<span class="hljs-string">&#x27; &#x27;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><strong>多条排序规则</strong></p><blockquote><p><code>sorted()</code> 函数在排序时，会针对列表 <code>lst</code> 中的每个元素 <code>x</code> 调用 <code>key</code> 参数指定的函数（此处为 <code>lambda x: (x[1] + x[2], x[1], -x[0])</code>），得到相应的排序键。<code>key</code> 参数的作用是定义一个映射规则，将待排序的元素转化为一个用于排序的值（排序键）。<code>sorted()</code> 函数根据这些排序键进行排序，从而实现对原始元素列表的定制化排序。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">lst = <span class="hljs-built_in">sorted</span>(lst,key=<span class="hljs-keyword">lambda</span> x:(x[<span class="hljs-number">1</span>]+x[<span class="hljs-number">2</span>],x[<span class="hljs-number">1</span>],-x[<span class="hljs-number">0</span>]),reverse=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>题库</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode05：盛最多水的容器</title>
    <link href="/2024/03/29/LeetCode05/"/>
    <url>/2024/03/29/LeetCode05/</url>
    
    <content type="html"><![CDATA[<h1 id="5-盛最多水的容器"><a href="#5-盛最多水的容器" class="headerlink" title="5. 盛最多水的容器"></a>5. 盛最多水的容器</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403292020343.jpeg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="（一）双指针"><a href="#（一）双指针" class="headerlink" title="（一）双指针"></a>（一）双指针</h3><p>这道题的关键是需要理解装的水容量取决于：1、木板之间的距离、2、短木板的高度。</p><p>如图，Left指针和Right指针分别指向起点和终端：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403292020323.png" alt="image-20240329190613762"></p><p>为什么是移动短板：</p><p>因为随着底部距离的减小，如果移动长板，新板高度大于&#x2F;小于&#x2F;等于短板，而容量取决于底部距离 * 短板高度，最终容量只会相等或更小。</p><p>移动短板，直至两个指针相遇，每次计算水的容量，最后取最大容量。</p><p><strong>时间复杂度：</strong>O(n)，双指针总计最多遍历整个数组一次。</p><p><strong>空间复杂度：</strong>O(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params">self, height</span>):<br>        length = <span class="hljs-built_in">len</span>(height)<br>        area = <span class="hljs-number">0</span><br>        i = <span class="hljs-number">0</span><br>        j = length - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i &lt; j:<br>            x = j - i<br>            y = <span class="hljs-built_in">min</span>(height[i],height[j])<br>            area = <span class="hljs-built_in">max</span>(area,x * y)<br>            <span class="hljs-keyword">if</span> height[i] &lt;= height[j]:<br>                 i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                j -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> area<br></code></pre></td></tr></table></figure><h3 id="（二）暴力破解"><a href="#（二）暴力破解" class="headerlink" title="（二）暴力破解"></a>（二）暴力破解</h3><p>双层for循环遍历。</p><p>缺点：非常耗时</p><p><strong>时间复杂度：</strong>O($n^2$)    <code>n</code>是数组的长度</p><p><strong>空间复杂度：</strong>O(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params">self, height</span>):<br>        length = <span class="hljs-built_in">len</span>(height)<br>        max_area = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(length):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,length):<br>                x = j - i<br>                y = <span class="hljs-built_in">min</span>(height[i],height[j])<br>                area = x * y<br>                max_area = <span class="hljs-built_in">max</span>(max_area,area)<br>        <span class="hljs-keyword">return</span> max_area<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>题库</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT04：福尔摩斯的约会</title>
    <link href="/2024/03/27/PAT04/"/>
    <url>/2024/03/27/PAT04/</url>
    
    <content type="html"><![CDATA[<h1 id="4-福尔摩斯的约会"><a href="#4-福尔摩斯的约会" class="headerlink" title="4.福尔摩斯的约会"></a>4.福尔摩斯的约会</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>题目描述</strong></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts">大侦探福尔摩斯接到一张奇怪的字条：“我们约会吧！ <span class="hljs-number">3485</span>djDkxh4hhGE <span class="hljs-number">2984</span>akDfkkkkggEdsb s<span class="hljs-variable">&amp;hgsfdk</span> d<span class="hljs-variable">&amp;</span>Hyscvnm”。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间“星期四 <span class="hljs-number">14</span>:<span class="hljs-number">04</span>”，因为前面两字符串中第<span class="hljs-number">1</span>对相同的大写英文字母（大小写有区分）是第<span class="hljs-number">4</span>个字母<span class="hljs-string">&#x27;D&#x27;</span>，代表星期四；第<span class="hljs-number">2</span>对相同的字符是<span class="hljs-string">&#x27;E&#x27;</span>，那是第<span class="hljs-number">5</span>个英文字母，代表一天里的第<span class="hljs-number">14</span>个钟头（于是一天的<span class="hljs-number">0</span>点到<span class="hljs-number">23</span>点由数字<span class="hljs-number">0</span>到<span class="hljs-number">9</span>、以及大写字母A到N表示）；后面两字符串第<span class="hljs-number">1</span>对相同的英文字母<span class="hljs-string">&#x27;s&#x27;</span>出现在第<span class="hljs-number">4</span>个位置（从<span class="hljs-number">0</span>开始计数）上，代表第<span class="hljs-number">4</span>分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。  <br>（注：两字符串的比较过程必须按照两字符串中对应的下标相同的字符进行比较！）<br> <br></code></pre></td></tr></table></figure><p><strong>输入描述:</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">输入在4行中分别给出4个非空、不包含空格、且长度不超过60的字符串。<br></code></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">在一行中输出约会的时间，格式为“<span class="hljs-built_in">DAY</span> HH:MM”，其中“<span class="hljs-built_in">DAY</span>”是某星期的<span class="hljs-number">3</span>字符缩写，即MON表示星期一，TUE表示星期二，WED表示星期三，THU表示星期<br>四，FRI表示星期五，SAT表示星期六，SUN表示星期日。题目输入保证每个测试存在唯一解。<br></code></pre></td></tr></table></figure><p><strong>输入例子:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-number">3485</span>djDkxh4hhGE<br><span class="hljs-number">2984</span>akDfkkkkggEdsb<br>s<span class="hljs-meta">&amp;hgsfdk</span><br>d<span class="hljs-meta">&amp;Hyscvnm</span><br></code></pre></td></tr></table></figure><p><strong>输出例子:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">THU</span> <span class="hljs-number">14</span>:<span class="hljs-number">04</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="（1）我的解法"><a href="#（1）我的解法" class="headerlink" title="（1）我的解法"></a>（1）我的解法</h3><p>这主要是一道关于字符串索引、判断的题。根据解密的判断逻辑来取出对应位置的字符，还要将字符转换成相应的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dayHour</span>(<span class="hljs-params">str1,str2,min_length</span>):<br>    day_flag = <span class="hljs-literal">True</span><br>    hour_flag = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(min_length):<br>        m = str1[i]<br>        n = str2[i]<br>        <span class="hljs-keyword">if</span> m == n:<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;A&#x27;</span> &lt;= m &lt;=<span class="hljs-string">&#x27;G&#x27;</span>:<br>                <span class="hljs-keyword">if</span> day_flag:<br>                    day = m<br>                    day_flag = <span class="hljs-literal">False</span><br>                    <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> day_flag <span class="hljs-keyword">and</span> hour_flag:<br>                <span class="hljs-keyword">if</span> m.isdigit() <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;A&#x27;</span>&lt;= m &lt;=<span class="hljs-string">&#x27;N&#x27;</span>:<br>                    hour = m<br>                    <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span>(day,hour) <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">minu</span>(<span class="hljs-params">str1,str2,min_length</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(min_length):<br>        m = str1[i]<br>        n = str2[i]<br>        <span class="hljs-keyword">if</span> m == n <span class="hljs-keyword">and</span> m.isalpha() <span class="hljs-keyword">and</span> n.isalpha():<br>            <span class="hljs-keyword">return</span> i<br>              <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_weekday</span>(<span class="hljs-params">letter</span>):<br>    weekdays = &#123;<br>        <span class="hljs-string">&#x27;A&#x27;</span>:<span class="hljs-string">&#x27;MON&#x27;</span>,<br>        <span class="hljs-string">&#x27;B&#x27;</span>:<span class="hljs-string">&#x27;TUE&#x27;</span>,<br>        <span class="hljs-string">&#x27;C&#x27;</span>:<span class="hljs-string">&#x27;WED&#x27;</span>,<br>        <span class="hljs-string">&#x27;D&#x27;</span>:<span class="hljs-string">&#x27;THU&#x27;</span>,<br>        <span class="hljs-string">&#x27;E&#x27;</span>:<span class="hljs-string">&#x27;FRI&#x27;</span>,<br>        <span class="hljs-string">&#x27;F&#x27;</span>:<span class="hljs-string">&#x27;SAT&#x27;</span>,<br>        <span class="hljs-string">&#x27;G&#x27;</span>:<span class="hljs-string">&#x27;SUN&#x27;</span><br>    &#125;            <br>    <span class="hljs-keyword">return</span> weekdays.get(letter) <br>            <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_hour</span>(<span class="hljs-params">char</span>):<br>    <span class="hljs-keyword">if</span> char.isdigit():<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(char)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ord</span>(char) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>) + <span class="hljs-number">10</span>  <br><br><span class="hljs-built_in">all</span> = []<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:<br>    <span class="hljs-built_in">all</span>.append(line.strip())<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">all</span>) == <span class="hljs-number">4</span>:<br>        <span class="hljs-keyword">break</span><br><br>a,b,c,d = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>,<span class="hljs-built_in">all</span>)<br>one = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">len</span>(a),<span class="hljs-built_in">len</span>(b))<br>two = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">len</span>(c),<span class="hljs-built_in">len</span>(d))<br>re1 = dayHour(a,b,one)<br>re2 = minu(c,d,two)<br>day = get_weekday(re1[<span class="hljs-number">0</span>])<br>hour = get_hour(re1[<span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;day&#125;</span> <span class="hljs-subst">&#123;hour:02&#125;</span>:<span class="hljs-subst">&#123;re2:02&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-其他解法"><a href="#2-其他解法" class="headerlink" title="(2)其他解法"></a>(2)其他解法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><br>a, b, c, d = <span class="hljs-built_in">input</span>(), <span class="hljs-built_in">input</span>(), <span class="hljs-built_in">input</span>(), <span class="hljs-built_in">input</span>()<br><br>DAY = &#123;<span class="hljs-string">&#x27;A&#x27;</span>: <span class="hljs-string">&#x27;MON&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>: <span class="hljs-string">&#x27;TUE&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-string">&#x27;WED&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-string">&#x27;THU&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>: <span class="hljs-string">&#x27;FRI&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>: <span class="hljs-string">&#x27;SAT&#x27;</span>, <span class="hljs-string">&#x27;G&#x27;</span>: <span class="hljs-string">&#x27;SUN&#x27;</span>&#125;<br><br>HH = &#123;<span class="hljs-string">&quot;0&quot;</span>: <span class="hljs-string">&quot;00&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;01&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>: <span class="hljs-string">&quot;02&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>: <span class="hljs-string">&quot;03&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>: <span class="hljs-string">&quot;04&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>: <span class="hljs-string">&quot;05&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>: <span class="hljs-string">&quot;06&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>: <span class="hljs-string">&quot;07&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>: <span class="hljs-string">&quot;08&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>: <span class="hljs-string">&quot;09&quot;</span>,<br>      <span class="hljs-string">&quot;A&quot;</span>: <span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>: <span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>: <span class="hljs-string">&quot;12&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>: <span class="hljs-string">&quot;13&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>: <span class="hljs-string">&quot;14&quot;</span>, <span class="hljs-string">&quot;F&quot;</span>: <span class="hljs-string">&quot;15&quot;</span>, <span class="hljs-string">&quot;G&quot;</span>: <span class="hljs-string">&quot;16&quot;</span>, <span class="hljs-string">&quot;H&quot;</span>: <span class="hljs-string">&quot;17&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>: <span class="hljs-string">&quot;18&quot;</span>, <span class="hljs-string">&quot;J&quot;</span>: <span class="hljs-string">&quot;19&quot;</span>,<br>      <span class="hljs-string">&quot;K&quot;</span>: <span class="hljs-string">&quot;20&quot;</span>, <span class="hljs-string">&quot;L&quot;</span>: <span class="hljs-string">&quot;21&quot;</span>, <span class="hljs-string">&quot;M&quot;</span>: <span class="hljs-string">&quot;22&quot;</span>, <span class="hljs-string">&quot;N&quot;</span>: <span class="hljs-string">&quot;23&quot;</span>&#125;<br><br>count = <span class="hljs-number">0</span><br>day = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">if</span> a[count] == b[count]:<br>        <span class="hljs-keyword">if</span> day != <span class="hljs-string">&quot;&quot;</span> <span class="hljs-keyword">and</span> a[count] <span class="hljs-keyword">in</span> HH.keys():<br>            hh = a[count]<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">elif</span> (a[count] <span class="hljs-keyword">in</span> DAY.keys()) <span class="hljs-keyword">and</span> (b[count] <span class="hljs-keyword">in</span> DAY.keys()):<br>            day = a[count]<br>    count += <span class="hljs-number">1</span><br><br>count = <span class="hljs-number">0</span><br>lst_x = <span class="hljs-built_in">range</span>(<span class="hljs-number">97</span>, <span class="hljs-number">123</span>)<br>lst_d = <span class="hljs-built_in">range</span>(<span class="hljs-number">65</span>, <span class="hljs-number">91</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">ord</span>(c[count]) <span class="hljs-keyword">in</span> lst_x <span class="hljs-keyword">or</span> <span class="hljs-built_in">ord</span>(c[count]) <span class="hljs-keyword">in</span> lst_d:<br>        <span class="hljs-keyword">if</span> c[count] == d[count]:<br>            <span class="hljs-keyword">break</span><br>    count += <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(DAY[day], HH[hh] + <span class="hljs-string">&#x27;:&#x27;</span> + <span class="hljs-string">&#x27;%02d&#x27;</span> % (count))<br></code></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><strong>判断数字或字母</strong></p><blockquote><p>1、使用ASCII码</p><ul><li>数字的ASCII码范围是 48 到 57</li><li>大写字母的ASCII码范围是 65 到 90</li><li>小写字母的ASCII码范围是 97 到 122</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">ord</span>(char) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>) + <span class="hljs-number">10</span> <br><span class="hljs-comment"># 意味着赋A值为10开始</span><br><br><span class="hljs-string">&#x27;A&#x27;</span> &lt;= m &lt;=<span class="hljs-string">&#x27;Z&#x27;</span><br><span class="hljs-comment"># 直接判断字母是否在具体的范围</span><br><br>lst_x = <span class="hljs-built_in">range</span>(<span class="hljs-number">97</span>, <span class="hljs-number">123</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">ord</span>(c[count]) <span class="hljs-keyword">in</span> lst_x <br><span class="hljs-comment"># 这个也是根据ASCII判断</span><br></code></pre></td></tr></table></figure><blockquote><p>2、使用内置函数</p><p>可以使用 <code>isdigit()</code> 方法判断是否为数字，使用 <code>isalpha()</code> 方法判断是否为字母。</p><p><code>isupper()</code> 方法判断是否为大写字母 ，<code>islower()</code> 方法判断是否为小写字母。</p><p>3、使用正则表达式</p></blockquote><p><strong>设置选项返回对应值</strong></p><blockquote><p>先根据对应键值对设置字典，再调用字典的<code>get()</code>方法返回值</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">def <span class="hljs-title">get_weekday</span>(<span class="hljs-params">letter</span>):</span><br><span class="hljs-function">    weekdays</span> = &#123;<br>        <span class="hljs-string">&#x27;A&#x27;</span>:<span class="hljs-string">&#x27;MON&#x27;</span>,<br>        <span class="hljs-string">&#x27;B&#x27;</span>:<span class="hljs-string">&#x27;TUE&#x27;</span>,<br>        <span class="hljs-string">&#x27;C&#x27;</span>:<span class="hljs-string">&#x27;WED&#x27;</span>,<br>        <span class="hljs-string">&#x27;D&#x27;</span>:<span class="hljs-string">&#x27;THU&#x27;</span>,<br>        <span class="hljs-string">&#x27;E&#x27;</span>:<span class="hljs-string">&#x27;FRI&#x27;</span>,<br>        <span class="hljs-string">&#x27;F&#x27;</span>:<span class="hljs-string">&#x27;SAT&#x27;</span>,<br>        <span class="hljs-string">&#x27;G&#x27;</span>:<span class="hljs-string">&#x27;SUN&#x27;</span><br>    &#125;            <br>    <span class="hljs-keyword">return</span> weekdays.<span class="hljs-keyword">get</span>(letter) <br></code></pre></td></tr></table></figure><blockquote><p>要判断选项是否在选项里：</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> one_dict.<span class="hljs-built_in">keys</span>()<br></code></pre></td></tr></table></figure><p><strong>字符串格式化</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-string">&#x27;%02d&#x27;</span> <span class="hljs-meta">%</span> <span class="hljs-comment">(count)</span><br></code></pre></td></tr></table></figure><blockquote><ul><li><code>&#39;%02d&#39;</code>：这是一个格式化字符串，其中：<ul><li><code>%d</code> 表示将后面的变量作为整数进行格式化输出。</li><li><code>0</code> 表示在数字前面补0，如果数字不够两位数的话。</li><li><code>2</code> 表示最少输出的字符数为2位。如果不足两位，则在前面补0。</li></ul></li></ul></blockquote><blockquote><ul><li><code>% (count)</code>: 这里的 <code>count</code> 是一个变量，将会填充到前面定义的格式化字符串中。在这个例子中，<code>count</code> 是一个整数类型的变量。</li></ul></blockquote><p><code>&#123;hour:02&#125;</code> 的作用也是将 <code>hour</code> 变量格式化为两位数的整数，不足两位时在前面补0；</p>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>题库</tag>
      
      <tag>字典</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【机器学习算法】10种常见机器学习算法</title>
    <link href="/2024/03/26/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E3%80%9110%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"/>
    <url>/2024/03/26/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E3%80%9110%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="【机器学习算法】10种常见机器学习算法"><a href="#【机器学习算法】10种常见机器学习算法" class="headerlink" title="【机器学习算法】10种常见机器学习算法"></a>【机器学习算法】10种常见机器学习算法</h1><p>一般来说，机器学习主要有三种算法：</p><ul><li><p><strong>1. 监督式学习 — 训练要指定输出标签</strong></p><p>监督式学习算法包括一个目标变量（因变量）和用来预测目标变量的预测变量（自变量）。通过这些变量我们可以搭建一个模型，从而对于一个已知的<strong>预测变量值</strong>，我们可以得到对应的<strong>目标变量值</strong>。重复训练这个模型，直到它能在训练数据集上达到预定的准确度。</p><p>监督式学习是一种机器学习的方法，其中模型从标记的训练数据中学习输入和输出之间的映射关系。在监督式学习中，训练数据包括输入数据和对应的输出标签，模型通过学习这些数据来预测新的、之前未见过的数据。</p><p>属于监督式学习的算法有：<strong>支持向量机（SVM)，回归模型，决策树，随机森林，K邻近算法，逻辑回归</strong>等。这种方法通常用于分类和回归问题。</p></li><li><p><strong>2. 无监督式学习 — 数据不标记</strong></p><p>与监督式学习不同的是，无监督学习中我们没有需要预测或估计的目标变量。无监督式学习是用来对总体对象进行分类的。它在根据某一指标将客户分类上有广泛应用。</p><p>无监督式学习是一种机器学习的方法，其中<strong>模型从未标记的数据中学习模式和结构，而无需指定输出标签</strong>。在无监督式学习中，算法试图发现数据中的隐藏结构或模式，以便对数据进行分类、聚类或降维等操作。</p><p>属于无监督式学习的算法有：<strong>关联规则，K-means聚类算法，主成分分析（PCA）</strong>等。这种方法通常用于发现数据中的潜在模式和关系，而无需预先标记的输出。</p></li><li><p><strong>3. 强化学习 — 智能体与环境互动</strong></p><p>这个算法可以训练程序做出某一决定。程序在某一情况下尝试所有的可能行动，记录不同行动的结果并试着找出最好的一次尝试来做决定。</p><p>强化学习是一种机器学习方法，其目标是让智能体在与环境互动的过程中学习如何做出决策，以使得长期收益最大化。<strong>在强化学习中，智能体通过尝试不同的行为，并观察环境对其行为的反馈来学习。</strong>这种学习方式类似于试错的过程，通过与环境的交互，智能体逐渐学会采取哪些行动以获得最大的奖励。</p><p>强化学习通常涉及定义一个奖励信号，以便智能体可以根据其行为的好坏进行学习。常见的强化学习算法包括<strong>马尔可夫决策过程、Q学习、深度强化学习（DRL）</strong>等。强化学习在许多领域都有应用，如机器人控制、游戏策略、金融交易等。</p></li></ul><h2 id="常见的机器学习算法"><a href="#常见的机器学习算法" class="headerlink" title="常见的机器学习算法"></a>常见的机器学习算法</h2><p>以下是最常用的机器学习算法，大部分数据问题都可以通过它们解决：</p><h3 id="1-线性回归-Linear-Regression"><a href="#1-线性回归-Linear-Regression" class="headerlink" title="1.线性回归 (Linear Regression)"></a>1.线性回归 (Linear Regression)</h3><h4 id="定义：y-ax-b"><a href="#定义：y-ax-b" class="headerlink" title="定义：y&#x3D;ax+b"></a>定义：y&#x3D;ax+b</h4><p>线性回归是利用连续性变量来估计实际数值（例如房价，呼叫次数和总销售额等）。我们通过线性回归算法找出自变量和因变量间的最佳线性关系，图形上可以确定一条最佳直线。这条最佳直线就是回归线。这个回归关系可以用Y&#x3D;aX+b 表示。</p><p>我们可以假想一个场景来理解线性回归。比如你让一个五年级的孩子在不问同学具体体重多少的情况下，把班上的同学按照体重从轻到重排队。这个孩子会怎么做呢？他有可能会通过观察大家的身高和体格来排队。这就是线性回归！这个孩子其实是认为身高和体格与人的体重有某种相关。而这个关系就像是前一段的Y和X的关系。</p><p>在Y&#x3D;aX+b这个公式里：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">Y- 因变量<br>a- 斜率<br>X- 自变量<br>b- 截距<br></code></pre></td></tr></table></figure><h4 id="求a和b：最小二乘法"><a href="#求a和b：最小二乘法" class="headerlink" title="求a和b：最小二乘法"></a>求a和b：最小二乘法</h4><p>a和b可以通过最小化因变量误差的平方和得到（<strong>最小二乘法</strong>）。</p><p>我们可以使用最小二乘法来估计参数 a 和 b。具体步骤如下：</p><blockquote><ol><li>计算<strong>每个样本点到直线的垂直距离，即残差</strong>，表示为 e<del>i</del> &#x3D; y<del>i</del> - (ax<del>i</del> + b)，其中 (x<del>i</del>, y<del>i</del>) 为第 i 个样本点的坐标。</li><li>我们的目标是<strong>最小化所有残差的平方和，</strong>即最小化 S &#x3D; Σ(e<del>i</del>^2^)，其中 i 从 1 到 n，n 为样本点数。</li><li>为了找到最小化 S 的参数 a 和 b，我们对 S 分别关于 a 和 b 求导，然后令导数等于 0，从而得到关于 a 和 b 的方程组。</li><li>解这个方程组，即可得到最优的参数估计值 a 和 b，使得线性回归模型 y &#x3D; ax + b 最优地拟合了观测数据。<br>这样得到的参数估计值 a 和 b，就是使得模型与观测数据拟合最好的直线的斜率和截距。</li></ol></blockquote><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>下图中我们得到的线性回归方程是 y&#x3D;0.2811X+13.9。通过这个方程，我们可以根据一个人的身高得到他的体重信息。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403261707932.png" alt="image-20240325210438846"></p><h4 id="根据自变量个数分为：一元-多元"><a href="#根据自变量个数分为：一元-多元" class="headerlink" title="根据自变量个数分为：一元 &#x2F; 多元"></a>根据自变量个数分为：一元 &#x2F; 多元</h4><p>线性回归主要有两种：一元线性回归和多元线性回归。</p><p>一元线性回归只有一个自变量，而多元线性回归有多个自变量。</p><p>拟合多元线性回归的时候，可以利用<strong>多项式回归（Polynomial Regression）</strong>或**曲线回归 (Curvilinear Regression)**。</p><blockquote><ol><li><strong>多项式回归</strong>：多项式回归是一种线性回归的扩展，通过引入自变量的高次项来拟合非线性关系。例如，对于一个简单的二次多项式回归模型 y &#x3D; a0 + a1<em>x + a2</em>x^2^，这样的模型可以拟合出曲线关系。通过选择合适的多项式次数，可以更好地拟合数据，并捕捉到数据中的非线性关系。</li><li><strong>曲线回归</strong>：曲线回归是一种更加灵活的回归方法，可以拟合各种形状的曲线，而不局限于多项式的形式。曲线回归可以采用不同的函数形式，比如指数函数、对数函数、幂函数等，来拟合数据中的非线性关系。通过选择适当的函数形式，曲线回归可以更好地拟合具有复杂形态的数据。</li></ol></blockquote><h4 id="python代码"><a href="#python代码" class="headerlink" title="python代码"></a>python代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#导入库</span><br><span class="hljs-comment">#导入其他必要的库，如pandas、numpy等</span><br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> linear_model<br><br><span class="hljs-comment">#加载训练和测试数据集</span><br><span class="hljs-comment">#确定特征和响应变量，并确保它们是数字类型和numpy数组</span><br>x_train = 训练数据集中的自变量数值<br>y_train = 训练数据集中的目标变量数值<br>x_test = 测试数据集中的自变量数值<br><br><span class="hljs-comment">#创建线性回归对象</span><br>linear = linear_model.LinearRegression()<br><br><span class="hljs-comment">#使用训练集训练模型并检查得分</span><br>linear.fit(x_train, y_train) <span class="hljs-comment"># 利用训练数据来拟合/训练线性回归模型</span><br>linear.score(x_train, y_train) <span class="hljs-comment"># 返回拟合性的度量，即确定系数。确定系数是衡量因变量的变化有多少百分比可以由自变量的变化来解释。范围在 0 到 1 之间，越接近 1 表示模型拟合得越好。</span><br><br><span class="hljs-comment">#方程系数(斜率)和截距</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;系数: \n&#x27;</span>, linear.coef_)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;截距: \n&#x27;</span>, linear.intercept_)<br><br><span class="hljs-comment">#预测输出</span><br>predicted = linear.predict(x_test)<br></code></pre></td></tr></table></figure><h3 id="2-逻辑回归-Logistic-Regression"><a href="#2-逻辑回归-Logistic-Regression" class="headerlink" title="2.逻辑回归 (Logistic Regression)"></a>2.逻辑回归 (Logistic Regression)</h3><h4 id="定义：是分类算法！预测概率值！"><a href="#定义：是分类算法！预测概率值！" class="headerlink" title="定义：是分类算法！预测概率值！"></a>定义：是分类算法！预测概率值！</h4><p>别被它的名字迷惑了，逻辑回归其实是一个分类算法而不是回归算法。通常是利用已知的自变量来预测一个离散型因变量的值（像二进制值0&#x2F;1，是&#x2F;否，真&#x2F;假）。简单来说，它就是通过拟合一个逻辑函数（logit fuction）来<strong>预测一个事件发生的概率</strong>。所以它预测的是一个概率值，自然，它的输出值应该在0到1之间，表示样本属于某一类的概率。通常情况下，我们可以将输出值大于等于0.5的样本预测为正类（1），将输出值小于0.5的样本预测为负类（0）。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>同样，我们可以用一个例子来理解这个算法。</p><p>假设你的一个朋友让你回答一道题。可能的结果只有两种：你答对了或没有答对。为了研究你最擅长的题目领域，你做了各种领域的题目。那么这个研究的结果可能是这样的：如果是一道十年级的三角函数题，你有70%的可能性能解出它。但如果是一道五年级的历史题，你会的概率可能只有30%。逻辑回归就是给你这样的概率结果。</p><p>回到数学上，事件结果的胜算对数（log odds）可以用预测变量的线性组合来描述：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">odds几率= p/ (1-p) = 事件发生的概率 / 事件不发生的概率<br>ln(odds) = ln(p/(1-p))<br>logit(p) = ln(p/(1-p)) = b0+b1X1+b2X2+b3X3....+bkXk<br></code></pre></td></tr></table></figure><p>在这里，p 是我们感兴趣的事件出现的概率。它通过筛选出特定参数值使得观察到的样本值出现的概率最大化，来估计参数，而不是像普通回归那样最小化误差的平方和。logistic回归主要关注的是事件发生的概率，通过最大化观测样本的概率来确定参数，以便更好地预测事件的发生与否，而不是直接预测具体数值。这种方法对于处理二元分类问题非常有效。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403261707893.png" alt="image-20240325215838298"></p><h4 id="python代码-1"><a href="#python代码-1" class="headerlink" title="python代码"></a>python代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入库</span><br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br><br><span class="hljs-comment"># 假设你有训练数据集的 X（预测变量）和 Y（目标变量），以及测试数据集的 x_test（预测变量）</span><br><br><span class="hljs-comment"># 创建 logistic 回归对象</span><br>model = LogisticRegression()<br><br><span class="hljs-comment"># 使用训练集训练模型并检查得分</span><br>model.fit(X, y)<br>model.score(X, y)<br><br><span class="hljs-comment"># 方程系数和截距</span><br><span class="hljs-comment"># 系数表示特征对目标变量的影响程度，而截距则代表了在没有任何特征影响时的基准值或偏移量。</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;系数: \n&#x27;</span>, model.coef_)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;截距: \n&#x27;</span>, model.intercept_)<br><br><span class="hljs-comment"># 预测输出</span><br>predicted = model.predict(x_test)<br></code></pre></td></tr></table></figure><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p><strong>延伸</strong>：</p><p>以下是一些可以尝试的优化模型的方法：</p><ul><li><p>加入交互项（interaction）</p><blockquote><p>通过添加特征之间的交互项，可以捕获特征之间的复杂关系，从而提高模型的表现。例如，如果有两个特征 x1 和 x2，可以添加一个新的特征 x1*x2 作为交互项。</p></blockquote></li><li><p>减少特征变量</p><blockquote><p>通过特征选择技术，可以剔除对模型预测贡献较小的特征，从而简化模型并提高泛化能力。常用的特征选择方法包括方差选择、单变量特征选择、递归特征消除等。</p></blockquote></li><li><p>正则化（<a href="https://link.zhihu.com/?target=http://www.analyticsvidhya.com/blog/2015/02/avoid-over-fitting-regularization/">regularization</a>）</p><blockquote><p>正则化通过在损失函数中加入惩罚项，可以有效控制模型的复杂度，防止过拟合。常见的正则化方法包括 L1 正则化（Lasso）和 L2 正则化（Ridge）。</p></blockquote></li><li><p>使用非线性模型</p><blockquote><p>对于非线性关系较为复杂的数据，可以尝试使用非线性模型，如支持向量机（SVM）、决策树、随机森林、神经网络等，以更好地拟合数据的非线性结构。</p></blockquote></li></ul><h3 id="3-决策树-Decision-Tree"><a href="#3-决策树-Decision-Tree" class="headerlink" title="3.决策树 (Decision Tree)"></a>3.决策树 (Decision Tree)</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>这是经常使用到的算法。它属于监督式学习，常用来解决分类问题。令人惊讶的是，它既可以运用于类别变量（categorical variables）也可以作用于连续变量。在决策树中，每个内部节点表示一个特征或属性上的测试，每个分支代表一个测试输出，每个叶节点代表一个类别标签（或者在回归任务中代表一个数值）。通过沿着从根节点到叶节点的路径进行测试，最终可以得出针对给定输入实例的预测结果。</p><p>常见的决策树算法包括：ID3、C4.5、CART（Classification And Regression Trees）等。在构建决策树时，算法会根据各种特征的信息增益（或其他指标）来选择合适的特征，并递归地划分数据集，直到达到停止条件为止（如节点包含的样本属于同一类别）。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403261707887.png" alt="image-20240325221749440"></p><p>从上图中我们可以看出，总体人群最终在玩与否的事件上被分成了四个群组。而分组是依据一些特征变量实现的。用来分组的具体指标有很多，比如基尼系数（Gini）、信息增益（Information Gain）、卡方检验（Chi-square）、熵（Entropy）等。</p><p>基尼系数衡量了数据集的不纯度，信息增益衡量了使用某个特征进行分类后带来的纯度提升，卡方检验用于检测特征与类别之间的关联程度，熵衡量了信息的混乱程度。通过这些指标，决策树算法可以选择最优的特征来进行分裂，从而构建出有效的决策树模型。</p><p>理解决策树原理的最好的办法就是玩Jezzball游戏。这是微软的一款经典游戏（见下图）。这个游戏的最终任务是在一个有移动墙壁的房间里，通过建造墙壁来尽可能地将房间分成尽量大的，没有小球的空间。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403261707899.png" alt="image-20240325222118822"></p><p>每一次你用建墙来分割房间，其实就是在将一个总体分成两部分。决策树也是用类似方法将总体分成尽量多的不同组别。</p><h4 id="python代码-2"><a href="#python代码-2" class="headerlink" title="python代码"></a>python代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入库</span><br><span class="hljs-comment"># 导入其他必要的库，如pandas、numpy等...</span><br><br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> tree<br><span class="hljs-comment"># 假设你已经有了训练数据集的预测变量 X 和目标变量 Y，以及测试数据集的预测变量 x_test</span><br><br><span class="hljs-comment"># 创建决策树对象</span><br>model = tree.DecisionTreeClassifier(criterion=<span class="hljs-string">&#x27;gini&#x27;</span>) <span class="hljs-comment"># 用于分类，这里你可以根据需求选择算法为基尼系数（gini）或熵（信息增益），默认为基尼系数</span><br><br><span class="hljs-comment"># model = tree.DecisionTreeRegressor() # 用于回归 与分类器不同，回归树的目标是预测连续型变量而不是离散的类别标签。</span><br><br><span class="hljs-comment"># 使用训练集训练模型并检查得分</span><br>model.fit(X, y)<br>model.score(X, y)<br><br><span class="hljs-comment"># 预测输出</span><br>predicted = model.predict(x_test)<br></code></pre></td></tr></table></figure><h3 id="4-支持向量机（SVM）"><a href="#4-支持向量机（SVM）" class="headerlink" title="4.支持向量机（SVM）"></a>4.支持向量机（SVM）</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>这是一个分类算法。在这个算法中我们将每一个数据作为一个点在一个n维空间上作图（n是特征数），每一个特征值就代表对应坐标值的大小。比如说我们有两个特征：一个人的身高和发长。我们可以将这两个变量在一个二维空间上作图，图上的每个点都有两个坐标值（这些坐标轴也叫做支持向量）。</p><p>支持向量机（Support Vector Machine，SVM）是一种用于分类和回归分析的监督学习模型。其主要思想是找到一个最优的超平面来对数据进行分类或回归，使得两个类别之间的间隔最大化。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403261707841.png" alt="image-20240326162316858"></p><p>现在我们要在图中找到一条直线能最大程度将不同组的点分开。两组数据中距离这条线最近的点到这条线的距离都应该是最远的。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403261707902.png" alt="image-20240326162414749"></p><p>在上图中，黑色的线就是最佳分割线。因为这条线到两组中距它最近的点，点A和B的距离都是最远的。任何其他线必然会使得到其中一个点的距离比这个距离近。这样根据数据点分布在这条线的哪一边，我们就可以将数据归类。</p><p>我们可以把这个算法想成n维空间里的JezzBall游戏，不过有一些变动：</p><ol><li><p>你可以以任何角度画分割线&#x2F;分割面（经典游戏中只有垂直和水平方向）。</p></li><li><p>现在这个游戏的目的是把不同颜色的小球分到不同空间里。</p></li><li><p>小球是不动的。</p></li></ol><h4 id="python代码-3"><a href="#python代码-3" class="headerlink" title="python代码"></a>python代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入库</span><br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> svm<br><br><span class="hljs-comment"># 假设你已经有了训练数据集的预测变量 X 和目标变量 Y，以及测试数据集的预测变量 x_test</span><br><br><span class="hljs-comment"># 创建 SVM 分类对象</span><br>model = svm.SVC()  <span class="hljs-comment"># 这里有各种选项可供选择，这只是一个简单的分类示例。你可以参考链接获取更多详细信息。</span><br><br><span class="hljs-comment"># 使用训练集训练模型并检查得分</span><br>model.fit(X, y)<br>model.score(X, y)<br><br><span class="hljs-comment"># 预测输出</span><br>predicted = model.predict(x_test)<br></code></pre></td></tr></table></figure><h3 id="5-朴素贝叶斯-Naive-Bayes"><a href="#5-朴素贝叶斯-Naive-Bayes" class="headerlink" title="5.朴素贝叶斯 (Naive Bayes)"></a>5.朴素贝叶斯 (Naive Bayes)</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>这个算法是建立在贝叶斯理论上的分类方法。<strong>它的假设条件是自变量之间相互独立。</strong>简言之，朴素贝叶斯假定某一特征的出现与其它特征无关。比如说，如果一个水果它是红色的，圆状的，直径大概7cm左右，我们可能猜测它为苹果。即使这些特征之间存在一定关系，在朴素贝叶斯算法中我们都认为红色，圆状和直径在判断一个水果是苹果的可能性上是相互独立的。</p><p>朴素贝叶斯的模型易于建造，并且在分析大量数据问题时效率很高。虽然模型简单，但很多情况下工作得比非常复杂的分类方法还要好。</p><h4 id="数学理论"><a href="#数学理论" class="headerlink" title="数学理论"></a>数学理论</h4><p>贝叶斯理论告诉我们如何从先验概率P(c),P(x)和条件概率P(x|c)中计算后验概率P(c|x)。</p><blockquote><p>在贝叶斯理论中，P(c) 代表的是先验概率，表示在考虑任何新证据之前对事件 c 发生的信念。换句话说，它是基于以往经验和先前已知信息得出的事件 c 的概率。</p><p>P(x) 则代表边缘似然度（marginal likelihood），也称为证据（evidence），表示在所有可能的类别下观察到数据 x 的概率。这通常是一个归一化因子，用于确保后验概率的总和为1。</p><p>P(x|c) 是条件概率，表示在给定类别 c 下观察到数据 x 的概率。它衡量了特征 x 对于类别 c 的贡献程度。</p><p>有了这些概率，我们可以使用贝叶斯公式计算后验概率 P(c|x)，即在观察到数据 x 后，关于类别 c 的新信念。具体来说，后验概率告诉了我们在观察到数据 x 之后，事件 c 发生的概率。</p><hr><p>P(c|x)是已知特征x而分类为c的后验概率。</p><p>P(c)是种类c的先验概率。</p><p>P(x|c)是种类c具有特征x的可能性。</p><p>P(x)是特征x的先验概率。</p></blockquote><p>算法如下：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403261707457.png" alt="image-20240326163149235"></p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>例子： 以下这组训练集包括了天气变量和目标变量“是否出去玩”。我们现在需要根据天气情况将人们分为两组：玩或不玩。整个过程按照如下步骤进行：</p><p>步骤1：根据已知数据做频率表</p><p>步骤2：计算各个情况的概率制作概率表。</p><p>比如阴天（Overcast）的概率为0.29，此时玩的概率为0.64.</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403261707623.png" alt="image-20240326163518892"></p><p>步骤3：用朴素贝叶斯计算每种天气情况下玩和不玩的后验概率。概率大的结果为预测值。</p><p>提问: 天气晴朗的情况下(sunny)，人们会玩。这句陈述是否正确？</p><p>我们可以用上述方法回答这个问题。P(Yes | Sunny)&#x3D;P(Sunny | Yes) * P(Yes) &#x2F; P(Sunny)。</p><p>这里，P(Sunny |Yes) &#x3D; 3&#x2F;9 &#x3D; 0.33, P(Sunny) &#x3D; 5&#x2F;14 &#x3D; 0.36, P(Yes)&#x3D; 9&#x2F;14 &#x3D; 0.64。</p><p>那么，P (Yes | Sunny) &#x3D; 0.33 * 0.64 &#x2F; 0.36 &#x3D; 0.60&gt;0.5,说明这个概率值更大。</p><p>当有多种类别和多种特征时，预测的方法相似。朴素贝叶斯通常用于文本分类和多类别分类问题。</p><h4 id="python代码-4"><a href="#python代码-4" class="headerlink" title="python代码"></a>python代码</h4><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-comment"># 导入库</span><br>from sklearn.naive_bayes import GaussianNB<br><span class="hljs-comment"># 假设你有训练数据集的 X（特征）和 Y（目标），以及测试数据集的 x_test（特征）</span><br><br><span class="hljs-comment"># 创建高斯朴素贝叶斯分类器对象</span><br><span class="hljs-title">model</span> = GaussianNB() <span class="hljs-comment"># 还有其他分布用于多项分类，比如伯努利朴素贝叶斯，请参考链接</span><br><br><span class="hljs-comment"># 使用训练集训练模型并检查得分</span><br><span class="hljs-title">model</span>.fit(X, y)<br><br><span class="hljs-comment"># 预测输出</span><br>predicted = <span class="hljs-title">model</span>.predict(x_test)<br></code></pre></td></tr></table></figure><h3 id="6-K邻近算法（KNN）"><a href="#6-K邻近算法（KNN）" class="headerlink" title="6.K邻近算法（KNN）"></a>6.K邻近算法（KNN）</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>这个算法既可以解决分类问题，也可以用于回归问题，但工业上用于分类的情况更多。 KNN先记录所有已知数据，再利用一个距离函数，找出已知数据中距离未知事件最近的K组数据，最后按照这K组数据里最常见的类别预测该事件。</p><p>距离函数可以是欧式距离，曼哈顿距离，闵氏距离 (Minkowski Distance), 和汉明距离（Hamming Distance）。前三种用于连续变量，汉明距离用于分类变量。如果K&#x3D;1，那问题就简化为根据最近的数据分类。K值的选取时常是KNN建模里的关键。</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403261707561.png" alt="image-20240326164050505"></p><p>KNN在生活中的运用很多。比如，如果你想了解一个不认识的人，你可能就会从这个人的好朋友和圈子中了解他的信息。</p><p>在用KNN前你需要考虑到：</p><p>(1) KNN的计算成本很高</p><p>(2) 所有特征应该标准化数量级，否则数量级大的特征在计算距离上会有偏移。</p><p>(3) 在进行KNN前预处理数据，例如去除异常值，噪音等。</p><h4 id="python代码-5"><a href="#python代码-5" class="headerlink" title="python代码"></a>python代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入库</span><br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br><br><span class="hljs-comment"># 假设你有训练数据集的 X（特征）和 Y（目标），以及测试数据集的 x_test（特征）</span><br><span class="hljs-comment"># 创建 K 近邻分类器对象</span><br>model = KNeighborsClassifier(n_neighbors=<span class="hljs-number">6</span>) <span class="hljs-comment"># n_neighbors 默认值为 5</span><br><br><span class="hljs-comment"># 使用训练集训练模型并检查得分</span><br>model.fit(X, y)<br><br><span class="hljs-comment"># 预测输出</span><br>predicted = model.predict(x_test)<br></code></pre></td></tr></table></figure><h3 id="7-K-均值算法（K-means）"><a href="#7-K-均值算法（K-means）" class="headerlink" title="7.K-均值算法（K-means）"></a>7.K-均值算法（K-means）</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>这是一种解决聚类问题的非监督式学习算法。这个方法简单地利用了一定数量的集群（假设K个集群）对给定数据进行分类。同一集群内的数据点是同类的，不同集群的数据点不同类。</p><p>具体来说，K均值算法的工作流程如下：</p><ol><li>随机选择 K 个数据点作为初始的聚类中心。</li><li>将数据集中的每个数据点分配到距离其最近的聚类中心所在的组。</li><li>计算每个组的新中心，即取该组内所有数据点的平均值作为新的聚类中心。</li><li>重复步骤2和3，直到聚类中心不再发生变化或者达到预定的迭代次数。</li></ol><p>K均值算法适用于特征空间中的实例点，且需要事先确定要分成的簇数 K。这个算法简单易懂，计算效率高，因此被广泛应用于图像分割、文档分类、市场分析等领域。但是，K均值算法也有一些局限性，比如对初始聚类中心的选择敏感，对异常值敏感等。</p><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><p>还记得你是怎样从墨水渍中辨认形状的么？K均值算法的过程类似，你也要通过观察集群形状和分布来判断集群数量！</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403261707468.png" alt="image-20240326164450301"></p><blockquote><p><strong>K均值算法如何划分集群：</strong></p><ol><li><p>从每个集群中选取K个数据点作为质心（centroids）。</p></li><li><p>将每一个数据点与距离自己最近的质心划分在同一集群，即生成K个新集群。</p></li><li><p>找出新集群的质心，这样就有了新的质心。</p></li><li><p>重复2和3，直到结果收敛，即不再有新的质心出现。</p></li></ol></blockquote><h4 id="确定K值"><a href="#确定K值" class="headerlink" title="确定K值"></a>确定K值</h4><p>如果我们在每个集群中计算集群中所有点到质心的距离平方和，再将不同集群的距离平方和相加，我们就得到了这个集群方案的总平方和。</p><p>我们知道，随着集群数量的增加，总平方和会减少。但是如果用总平方和对K作图，你会发现在某个K值之前总平方和急速减少，但在这个K值之后减少的幅度大大降低，这个值就是最佳的集群数。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403261707567.png" alt="image-20240326164651996"></p><h4 id="python代码-6"><a href="#python代码-6" class="headerlink" title="python代码"></a>python代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入库</span><br><span class="hljs-keyword">from</span> sklearn.cluster <span class="hljs-keyword">import</span> KMeans<br><br><span class="hljs-comment"># 假设你有训练数据集的属性 X 和测试数据集的属性 x_test</span><br><span class="hljs-comment"># 创建 KMeans 分类器对象 model</span><br>model = KMeans(n_clusters=<span class="hljs-number">3</span>, random_state=<span class="hljs-number">0</span>)<br><span class="hljs-comment"># 通过固定随机种子，我们可以确保每次运行算法时使用相同的随机数序列，从而保证初始点的选择是确定的，使得实验结果具有可重复性。</span><br><br><span class="hljs-comment"># 使用训练集训练模型并检查得分</span><br>model.fit(X)<br><br><span class="hljs-comment"># 预测输出</span><br>predicted = model.predict(x_test)<br></code></pre></td></tr></table></figure><h3 id="8-随机森林-Random-Forest"><a href="#8-随机森林-Random-Forest" class="headerlink" title="8.随机森林 (Random Forest)"></a>8.随机森林 (Random Forest)</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>随机森林是对决策树集合的特有名称。随机森林里我们有多个决策树（所以叫“森林”）。为了给一个新的观察值分类，根据它的特征，每一个决策树都会给出一个分类。随机森林算法选出投票最多的分类作为分类结果。</p><p>“随机”体现在两个地方：</p><ol><li>数据的随机性：每棵树只看一部分数据来学习，而不是全部数据。</li><li>特征的随机性：每棵树只看数据中的一部分特征来学习，而不是全部特征。</li></ol><h4 id="怎么生成随机数"><a href="#怎么生成随机数" class="headerlink" title="怎么生成随机数?"></a>怎么生成随机数?</h4><ol><li><p>如果训练集中有N种类别，则有重复地随机选取N个样本。这些样本将组成培养决策树的训练集。</p></li><li><p>如果有M个特征变量，那么选取数m &lt;&lt; M，从而在每个节点上随机选取m个特征变量来分割该节点。m在整个森林养成中保持不变。</p></li><li><p>每个决策树都最大程度上进行分割，没有剪枝。</p></li></ol><h4 id="python代码-7"><a href="#python代码-7" class="headerlink" title="python代码"></a>python代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#导入库</span><br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br><span class="hljs-comment">#假设你有训练数据集的特征X和目标值Y，以及测试数据集的特征x_test</span><br><br><span class="hljs-comment">#创建随机森林对象</span><br>model = RandomForestClassifier()<br><br><span class="hljs-comment">#使用训练集训练模型并检查得分</span><br>model.fit(X, y)<br><br><span class="hljs-comment">#预测输出</span><br>predicted = model.predict(x_test)<br></code></pre></td></tr></table></figure><h3 id="9-降低维度算法（Dimensionality-Reduction-Algorithms）"><a href="#9-降低维度算法（Dimensionality-Reduction-Algorithms）" class="headerlink" title="9.降低维度算法（Dimensionality Reduction Algorithms）"></a>9.降低维度算法（Dimensionality Reduction Algorithms）</h3><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><p>降低维度是指通过保留数据集中最重要的信息来减少特征或变量的数量，从而简化模型并提高计算效率。</p><p>在过去的4-5年里，可获取的数据几乎以指数形式增长。公司&#x2F;政府机构&#x2F;研究组织不仅有了更多的数据来源，也获得了更多维度的数据信息。</p><p>例如：电子商务公司有了顾客更多的细节信息，像个人信息，网络浏览历史，个人喜恶，购买记录，反馈信息等，他们关注你的私人特征，比你天天去的超市里的店员更了解你。</p><p>作为一名数据科学家，我们手上的数据有非常多的特征。虽然这听起来有利于建立更强大精准的模型，但它们有时候反倒也是建模中的一大难题。怎样才能从1000或2000个变量里找到最重要的变量呢？这种情况下降维算法及其他算法，如决策树，随机森林，PCA，因子分析，相关矩阵，和缺省值比例等，就能帮我们解决难题。</p><h4 id="python代码-8"><a href="#python代码-8" class="headerlink" title="python代码"></a>python代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入库</span><br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> decomposition<br><br><span class="hljs-comment"># 假设你有训练数据集和测试数据集，命名为train和test</span><br><span class="hljs-comment"># 创建PCA对象</span><br>pca = decomposition.PCA(n_components=k)  <span class="hljs-comment"># 默认值 k = min(n_sample, n_features)</span><br><span class="hljs-comment"># 这行代码的含义是创建一个PCA（Principal Component Analysis，主成分分析）对象，并指定降维后的维度数量为 k。在这里，k 是一个参数，表示要将数据降维到的目标维度数量。通常情况下，k 的取值是小于或等于原始数据集中的样本数和特征数中较小的那个值。如果不指定 n_components 参数，则默认会保留所有的主成分（特征）。</span><br><br><span class="hljs-comment"># 对训练数据集进行降维处理</span><br>train_reduced = pca.fit_transform(train)<br><br><span class="hljs-comment"># 对测试数据集进行降维处理</span><br>test_reduced = pca.transform(test)<br></code></pre></td></tr></table></figure><h3 id="10-Gradient-Boost和Adaboost算法"><a href="#10-Gradient-Boost和Adaboost算法" class="headerlink" title="10.Gradient Boost和Adaboost算法"></a>10.Gradient Boost和Adaboost算法</h3><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h4><p>GBM和AdaBoost都是在有大量数据时提高预测准确度的boosting算法。Boosting是一种集成学习方法。它通过有序结合多个较弱的分类器&#x2F;估测器的估计结果来提高预测准确度。这些boosting算法在Kaggle，AV Hackthon, CrowdAnalytix等数据科学竞赛中有出色发挥。</p><ol><li><strong>AdaBoost（Adaptive Boosting）</strong>：<ul><li>AdaBoost 通过反复训练弱分类器（通常是决策树桩）来提升整体模型性能。</li><li>在每一轮训练中，它会调整样本的权重，使得之前被错误分类的样本在后续训练中获得更高的权重，以便下一轮能够更关注错分的样本。</li><li>最终的分类器是将所有弱分类器加权组合而成的强分类器。</li></ul></li><li><strong>Gradient Boosting</strong>：<ul><li>Gradient Boosting 通过迭代地训练决策树（或其他基本模型），每次训练的目标是减小上一轮的残差（预测值与实际值的差）。</li><li>在每一轮迭代中，通过梯度下降的方式优化损失函数，使得模型在训练集上拟合得更好。</li><li>最终的模型是将所有基本模型的预测结果加和而得到的。</li></ul></li></ol><h4 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h4><p>主要区别：</p><ul><li><p>AdaBoost 的核心思想是调整样本的权重来重点关注错分的样本，而 Gradient Boosting 通过迭代优化残差来不断改进模型。</p></li><li><p>AdaBoost 每一轮训练都会调整样本的权重，可能会造成过拟合；而 Gradient Boosting 则通过加入正则化项来控制模型的复杂度，更容易防止过拟合。</p></li></ul><h4 id="python代码-9"><a href="#python代码-9" class="headerlink" title="python代码"></a>python代码</h4>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">  <span class="hljs-comment"># 导入库</span><br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> GradientBoostingClassifier<br><br><span class="hljs-comment"># 假设你已经有了训练数据集的预测变量 X 和目标变量 Y，以及测试数据集的预测变量 x_test</span><br><span class="hljs-comment"># 创建 Gradient Boosting 分类器对象</span><br>model = GradientBoostingClassifier(n_estimators=<span class="hljs-number">100</span>, learning_rate=<span class="hljs-number">1.0</span>, max_depth=<span class="hljs-number">1</span>, random_state=<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 创建了一个 GradientBoostingClassifier（梯度提升分类器）的模型对象，并指定了一些参数来配置该模型的训练过程：</span><br><span class="hljs-comment"># n_estimators=100：指定了基础学习器的数量，也就是组成整个集成模型的决策树数量为 100。增加基础学习器的数量可以提高模型性能，但也会增加计算成本。</span><br><span class="hljs-comment"># learning_rate=1.0：学习率控制每棵树对最终结果的贡献程度。较低的学习率意味着每棵树的影响会减弱，通常需要与 n_estimators 结合调参以获得最佳效果。</span><br><span class="hljs-comment"># max_depth=1：每棵决策树的最大深度限制为 1。限制树的深度有助于防止过拟合，提高模型的泛化能力。</span><br><span class="hljs-comment"># random_state=0：随机种子，用于控制随机数生成过程，确保模型的训练过程可复现。设置相同的随机种子可以使实验结果保持一致。</span><br><br><span class="hljs-comment"># 使用训练集训练模型并查看评分</span><br>model.fit(X, y)<br><br><span class="hljs-comment"># 进行预测</span><br>predicted = model.predict(x_test)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AI学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线性回归</tag>
      
      <tag>逻辑回归</tag>
      
      <tag>决策树</tag>
      
      <tag>支持向量机SVM</tag>
      
      <tag>朴素贝叶斯</tag>
      
      <tag>K近邻KNN</tag>
      
      <tag>K均值</tag>
      
      <tag>随机森林</tag>
      
      <tag>降低维度算法</tag>
      
      <tag>Gradient Boost</tag>
      
      <tag>Adaboost</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>北京交通大学-图像处理</title>
    <link href="/2024/03/25/%E5%8C%97%E4%BA%AC%E4%BA%A4%E9%80%9A%E5%A4%A7%E5%AD%A6-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    <url>/2024/03/25/%E5%8C%97%E4%BA%AC%E4%BA%A4%E9%80%9A%E5%A4%A7%E5%AD%A6-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="北京交通大学-图像处理"><a href="#北京交通大学-图像处理" class="headerlink" title="北京交通大学-图像处理"></a>北京交通大学-图像处理</h1><h2 id="I-基本概念"><a href="#I-基本概念" class="headerlink" title="I 基本概念"></a>I 基本概念</h2><h3 id="一、模拟图像"><a href="#一、模拟图像" class="headerlink" title="一、模拟图像"></a>一、模拟图像</h3><p>通过某种连续的物理量，光或电等的强弱变化，记录图像的亮度信息。</p><h3 id="二、数字图像"><a href="#二、数字图像" class="headerlink" title="二、数字图像"></a>二、数字图像</h3><p>采用数字表示方式，记录图像亮度信息，计算机进行存储和处理。</p><h3 id="三、采样和量化"><a href="#三、采样和量化" class="headerlink" title="三、采样和量化"></a>三、采样和量化</h3><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854865.png" alt="image-20240314155530861"></p><blockquote><p>数字图像就是对模拟图像进行了空间采样和亮度量化</p></blockquote><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854881.png" alt="image-20240314155619393"></p><p>**1、数字图像的数学模型$f(x,y)$ **</p><p>$(x,y)$表示像素位置，$f(x,y)$表示像素灰度值。</p><p><strong>2、数字图像可以表示为以像素为元素的矩阵</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854911.png" alt="image-20240314160001472"></p><h3 id="四、空间分辨率"><a href="#四、空间分辨率" class="headerlink" title="四、空间分辨率"></a>四、空间分辨率</h3><p><strong>采样间隔</strong></p><p>图像采样间隔是指在数字图像处理中，采样过程中相邻采样点之间的距离。</p><p>采样间隔决定了图像的分辨率和细节表现能力，间隔越小，图像的细节表现能力越高。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854807.png" alt="image-20240314160222022"></p><blockquote><p>采样间隔4x4通常指的是在图像处理中进行采样时，每隔4个像素点取一个样本。</p></blockquote><h3 id="五、亮度分辨率"><a href="#五、亮度分辨率" class="headerlink" title="五、亮度分辨率"></a>五、亮度分辨率</h3><p>衡量图像亮度的量化精度。</p><p>灰度级是指在数字图像中用来表示每个像素亮度或颜色深浅程度的级别。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854819.png" alt="image-20240314160732528"></p><h3 id="六、图像存储与格式"><a href="#六、图像存储与格式" class="headerlink" title="六、图像存储与格式"></a>六、图像存储与格式</h3><p><strong>1、数字存储比特数</strong></p><blockquote><p>8位图像使用8个比特（bit）来表示每个像素的颜色或亮度，因此可以有2^8 &#x3D; 256个不同的颜色或亮度级别。同样，10位图像使用10个比特来表示每个像素的颜色或亮度，因此可以有2^10&#x3D;1024个不同的颜色或亮度级别。</p></blockquote><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854772.png" alt="image-20240314161631769"></p><p><strong>2、数字图像格式</strong></p><p>数字图像文件存放在记忆卡上的格式、压缩方式（BMP &#x2F; JPEG &#x2F; GIF &#x2F; PNG)</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854981.png" alt="image-20240314162359510"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854529.png" alt="image-20240314162659873"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854548.png" alt="image-20240314162713886"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854740.png" alt="image-20240314162747850"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854514.png" alt="image-20240314165009141"></p><h3 id="七、直方图"><a href="#七、直方图" class="headerlink" title="七、直方图"></a>七、直方图</h3><p>数字图像：以空间位置$(x,y)$为自变量的二维函数$f(x,y)$</p><p>不同灰度级分布构成不同图像，统计灰度级出现的次数（概率）— 灰度直方图</p><h4 id="直方图定义"><a href="#直方图定义" class="headerlink" title="直方图定义"></a>直方图定义</h4><p><strong>1、灰度直方图</strong></p><blockquote><p>灰度级的函数、具有该灰度级的像素个数</p></blockquote><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854519.png" alt="image-20240314230732842"></p><p>示例：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854060.png" alt="image-20240314230829586"></p><p>灰度直方图反映了图像灰度的分布(统计)特征：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854239.png" alt="image-20240314230943679"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854124.png" alt="image-20240314232014758"></p><p><strong>2、灰度直方图归一化</strong></p><blockquote><p>灰度级出现的概率</p></blockquote><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854404.png" alt="image-20240314232100647"></p><h4 id="直方图性质"><a href="#直方图性质" class="headerlink" title="直方图性质"></a>直方图性质</h4><p>直方图表征了图像中灰度级分布特性，一幅图像具有特定的唯一的直方图。</p><p>一个直方图可以对应多副图像。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854345.png" alt="image-20240314232610675"></p><h4 id="直方图应用"><a href="#直方图应用" class="headerlink" title="直方图应用"></a>直方图应用</h4><p><strong>1、图像增强（直方图均衡）</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854678.png" alt="image-20240314232718385"></p><p><strong>2、图像分割（根据直方图获取分割阈值）</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854626.png" alt="image-20240315110528363"></p><p><strong>3、图像分类（直方图对比）</strong></p><p>观测是否有人经过：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854764.png" alt="image-20240315110633267"></p><h2 id="Ⅱ-图像增强"><a href="#Ⅱ-图像增强" class="headerlink" title="Ⅱ 图像增强"></a>Ⅱ 图像增强</h2><p><strong>哪些情况需要增强？</strong></p><p>视觉效果不佳、噪声污染、难以分析理解</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854057.png" alt="image-20240315121435028"></p><blockquote><p>按照特定的需要突出或去除图像中的某些信息</p><p>没有增加图像中的信息量，有可能损失</p><p>没有统一的客观评价标准，特定用途特定方法</p></blockquote><p><strong>如何进行图像增强</strong></p><blockquote><p>通过灰度变换，使得人眼视觉敏感区有灰度级分布</p></blockquote><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854067.png" alt="image-20240315121808223"></p><p>主要方法有：灰度变换、平均代数运算、空间域滤波、频域滤波</p><p>灰度变换、代数运算、空间域滤波直接对像素的灰度级进行操作 — <strong>空间域增强</strong></p><p>频域滤波，图像经过傅里叶变换等，对变换后的系数进行操作 — <strong>频域增强</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854080.png" alt="image-20240315122144072"></p><h3 id="一、空间域增强"><a href="#一、空间域增强" class="headerlink" title="一、空间域增强"></a>一、空间域增强</h3><p>直接对构成图像像素的灰度级操作</p><p>T：对输入图像灰度级的变换（操作）</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854184.png" alt="image-20240315135605655"></p><h4 id="灰度变换"><a href="#灰度变换" class="headerlink" title="灰度变换"></a>灰度变换</h4><p>简单、常用的空间域图像增强方法，输入图像像素的灰度级进行变换</p><p>T：灰度变换函数（线性&#x2F;非线性）</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854287.png" alt="image-20240315135750032"></p><h5 id="1、线性变换"><a href="#1、线性变换" class="headerlink" title="1、线性变换"></a>1、线性变换</h5><p>这里是反转的效果：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854389.png" alt="image-20240315140012783"></p><p>因为 $d&gt;b$ ，相当于把窄的灰度级拉伸了，这里起到了拉伸的效果：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854807.png" alt="image-20240315185109310"></p><p>对很暗和很亮的地方进行灰度压缩，敏感区拉伸，</p><p>突出感兴趣的区间，相对抑制不感兴趣的灰度区域：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854904.png" alt="image-20240315185748512"></p><h5 id="2、非线性变换"><a href="#2、非线性变换" class="headerlink" title="2、非线性变换"></a>2、非线性变换</h5><blockquote><p>包括对数变换、幂次变换、直方图均衡</p></blockquote><ul><li><p>对数变换</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854785.png" alt="image-20240315190049918"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854752.png" alt="image-20240315190115811"></p></li><li><p>幂次变换</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854091.png" alt="image-20240315190143138"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854066.png" alt="image-20240315190213255"></p><p>实际上对窄带也会进行拉伸：</p><p>低灰度输入图像 — 》 宽带 输出图像</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854356.png" alt="image-20240315190237938"></p><p>不同参数效果不同：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854492.png" alt="image-20240315190404061"></p></li><li><p>直方图均衡</p></li></ul><blockquote><p>直方图统计每个灰度级上的像素个数</p></blockquote><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854443.png" alt="image-20240315191556996"></p><p>灰度变换后的图像直方图，是变换前直方图与变换函数导数之比</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854680.png" alt="image-20240315192627621"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854866.png" alt="image-20240315192705656"></p><p>如何实现直方图均衡？</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854711.png" alt="image-20240315192749186"></p><p>计算常数：总像素数除以灰度级别数量</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854036.png" alt="image-20240315193434524"></p><p>目的是找到$f$(D<sub>A</sub>)​</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854025.png" alt="image-20240315195623929"></p><p>示例：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854111.png" alt="image-20240315195940437"></p><p>应用：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854365.png" alt="image-20240315200034466"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854461.png" alt="image-20240315200125815"></p><h4 id="代数运算"><a href="#代数运算" class="headerlink" title="代数运算"></a>代数运算</h4><h5 id="1、加法运算"><a href="#1、加法运算" class="headerlink" title="1、加法运算"></a>1、加法运算</h5><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854468.png" alt="image-20240315200308426"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854618.png" alt="image-20240315200352448"></p><p>如何恢复原始图像$f(x,y)$？ — 求多幅图像均值可以去除叠加性噪声</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854007.png" alt="image-20240315200631436"></p><p>一般求平均的图像越多，去噪效果越好：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854791.png" alt="image-20240315200814661"></p><h5 id="2、减法运算"><a href="#2、减法运算" class="headerlink" title="2、减法运算"></a>2、减法运算</h5><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854103.png" alt="image-20240315201005019"></p><p>分割特定区域：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854025.png" alt="image-20240315205320059"></p><p>检测场景变化：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854269.png" alt="image-20240315205353116"></p><h5 id="3、乘法运算"><a href="#3、乘法运算" class="headerlink" title="3、乘法运算"></a>3、乘法运算</h5><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854180.png" alt="image-20240315205422361"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854005.png" alt="image-20240315205434731"></p><h4 id="空间域滤波"><a href="#空间域滤波" class="headerlink" title="空间域滤波"></a>空间域滤波</h4><blockquote><p>空间域增强是直接对构成图像像素的灰度级操作</p><p>关键是寻求从输入图像到输出图像的变换函数 T </p><p>（上面提到了灰度变换函数，其实也可以通过信号系统分析寻找变换关系）</p></blockquote><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854533.png" alt="image-20240315205601120"></p><h5 id="信号与系统分析"><a href="#信号与系统分析" class="headerlink" title="信号与系统分析"></a>信号与系统分析</h5><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854598.png" alt="image-20240315205741195"></p><p><strong>（1）一维连续线性时不变系统</strong></p><p>一维连续线性时不变系统是指在一维输入和输出场景下，系统具有线性性质并且其参数不随时间变化。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854728.png" alt="image-20240315222829812"></p><p><strong>（2）一维离散线性时不变系统</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854051.png" alt="image-20240315230046412"></p><p>图像 — 》 二维离散系统</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854849.png" alt="image-20240315230123154"></p><p><strong>空间域滤波</strong></p><p>增强效果取决于$h(m,n)$</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854167.png" alt="image-20240315230216862"></p><h5 id="均值滤波器"><a href="#均值滤波器" class="headerlink" title="均值滤波器"></a>均值滤波器</h5><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854209.png" alt="image-20240315231331824"></p><p>经过均值滤波，噪声点削弱：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854288.png" alt="image-20240315231506352"></p><h5 id="高斯滤波器"><a href="#高斯滤波器" class="headerlink" title="高斯滤波器"></a>高斯滤波器</h5><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854482.png" alt="image-20240315231542767"></p><p>图像滤波器应用 — 》 去除噪声</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854773.png" alt="image-20240315231854870"></p><p>图像滤波器应用 — 》 提取感兴趣物体</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854730.png" alt="image-20240315232209812"></p><p>低通滤波 — 》 图像平滑</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854813.png" alt="image-20240315232239456"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854916.png" alt="image-20240321141526883"></p><h5 id="中值滤波器"><a href="#中值滤波器" class="headerlink" title="中值滤波器"></a>中值滤波器</h5><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854903.png" alt="image-20240321141642363"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854042.png" alt="image-20240321141714753"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854452.png" alt="image-20240321141737866"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854506.png" alt="image-20240321141746237"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854487.png" alt="image-20240321141751579"></p><h5 id="高通滤波器"><a href="#高通滤波器" class="headerlink" title="高通滤波器"></a>高通滤波器</h5><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854597.png" alt="image-20240321142130392"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854518.png" alt="image-20240321142140425"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854642.png" alt="image-20240321142233980"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854137.png" alt="image-20240321142545373"></p><p><strong>图像边缘</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403211428113.png" alt="image-20240321142810067"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854239.png" alt="image-20240321142834228"></p><p><strong>基于一阶差分的图像增强</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403211429598.png" alt="image-20240321142924540"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854349.png" alt="image-20240321143007106"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854502.png" alt="image-20240321143037299"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854871.png" alt="image-20240321143054217"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854084.png" alt="image-20240321143101084"></p><p><strong>基于二阶差分的图像增强</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854224.png" alt="image-20240321143138941"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854303.png" alt="image-20240321143203584"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854586.png" alt="image-20240321143211071"></p><p><strong>一阶差分与二阶差分的区别</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854823.png" alt="image-20240321143312664"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854327.png" alt="image-20240321143334420"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854107.png" alt="image-20240321143352892"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854385.png" alt="image-20240321143417116"></p><h3 id="二、频域增强"><a href="#二、频域增强" class="headerlink" title="二、频域增强"></a>二、频域增强</h3><h4 id="一维离散傅里叶变换定义"><a href="#一维离散傅里叶变换定义" class="headerlink" title="一维离散傅里叶变换定义"></a>一维离散傅里叶变换定义</h4><p>傅里叶级数</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854538.png" alt="image-20240321164147630"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854979.png" alt="image-20240321164231072"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854076.png" alt="image-20240321164242383"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854118.png" alt="image-20240321164323604"></p><h4 id="二维离散傅里叶变换定义"><a href="#二维离散傅里叶变换定义" class="headerlink" title="二维离散傅里叶变换定义"></a>二维离散傅里叶变换定义</h4><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854243.png" alt="image-20240321164343891"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854669.png" alt="image-20240321164403481"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854734.png" alt="image-20240321164418029"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854798.png" alt="image-20240321164437280"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854983.png" alt="image-20240321164448740"></p><h4 id="二维离散傅里叶变换性质"><a href="#二维离散傅里叶变换性质" class="headerlink" title="二维离散傅里叶变换性质"></a>二维离散傅里叶变换性质</h4><p>平移特性</p><p>旋转特性</p><p>尺度特性</p><p>卷积特性</p><p>相关特性</p><p>分离特性</p><h4 id="图像滤波器"><a href="#图像滤波器" class="headerlink" title="图像滤波器"></a>图像滤波器</h4><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854251.png" alt="image-20240321173425623"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854337.png" alt="image-20240321173440500"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854379.png" alt="image-20240321173453913"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854649.png" alt="image-20240321173521448"></p><p>（略）</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854881.png" alt="image-20240321173611828"></p><p>（略）</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854910.png" alt="image-20240321173810870"></p><p>（略）</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854149.png" alt="image-20240321173832195"></p><p>（略）</p><h2 id="Ⅲ-形态学处理"><a href="#Ⅲ-形态学处理" class="headerlink" title="Ⅲ 形态学处理"></a>Ⅲ 形态学处理</h2><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854739.png" alt="image-20240325174221566"></p><p><strong>图像数学形态学处理</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854510.png" alt="image-20240325174305792"></p><h3 id="二、集合论基础"><a href="#二、集合论基础" class="headerlink" title="二、集合论基础"></a>二、集合论基础</h3><p>集合论</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854562.png" alt="image-20240325174343623"></p><p>集合论运算：交集、并集、补集、差集</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854805.png" alt="image-20240325174454038"></p><p>集合平移：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854182.png" alt="image-20240325174604773"></p><p>集合反射：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854267.png" alt="image-20240325174636894"></p><h3 id="三、数学形态学处理"><a href="#三、数学形态学处理" class="headerlink" title="三、数学形态学处理"></a>三、数学形态学处理</h3><h4 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h4><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854316.png" alt="image-20240325174901048"></p><p>最后的结果是点集</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854364.png" alt="image-20240325175926717"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854684.png" alt="image-20240325180303531"></p><p>对字符进行低通滤波或者膨胀</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854925.png" alt="image-20240325180452997"></p><h4 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h4><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854872.png" alt="image-20240325181258767"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854899.png" alt="image-20240325181322439"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854131.png" alt="image-20240325181446238"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854784.png" alt="image-20240325181500973"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854490.png" alt="image-20240325181531517"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854155.png" alt="image-20240325181544426"></p><p>应用：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854541.png" alt="image-20240325181612562"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854091.png" alt="image-20240325181630310"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854118.png" alt="image-20240325181709937"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854472.png" alt="image-20240325181718368"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854644.png" alt="image-20240325181735572"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854702.png" alt="image-20240325181849399"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854677.png" alt="image-20240325181854134"></p><h4 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h4><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854111.png" alt="image-20240325181918125"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854185.png" alt="image-20240325181953511"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854200.png" alt="image-20240325182016240"></p><h4 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h4><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854268.png" alt="image-20240325182032148"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854691.png" alt="image-20240325182040587"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854735.png" alt="image-20240325182054950"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854840.png" alt="image-20240325182129744"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854792.png" alt="image-20240325182154074"><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854243.png" alt="image-20240325182250762"></p><h2 id="Ⅳ-图像分割"><a href="#Ⅳ-图像分割" class="headerlink" title="Ⅳ 图像分割"></a>Ⅳ 图像分割</h2><p>感兴趣区域识别</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854231.png" alt="image-20240325183100012"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854217.png" alt="image-20240325183136453"></p><p>（后面的图有点密恐！！！！！小心！！！！）</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854222.png" alt="image-20240325183206679"></p><h3 id="基于阈值"><a href="#基于阈值" class="headerlink" title="基于阈值"></a>基于阈值</h3><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854475.png" alt="image-20240325183252292"></p><p>确定阈值T，大于T保留，小于T视为0</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854554.png" alt="image-20240325183829994">、</p><p>阈值的选取:</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854849.png" alt="image-20240325183841551"></p><p>直方图技术：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854937.png" alt="image-20240325183904512"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854927.png" alt="image-20240325183928904"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854803.png"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854086.png" alt="image-20240325184017714"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854060.png" alt="image-20240325184031251"></p><p>最小误差阈值法（略）</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854391.png" alt="image-20240325184058657"></p><p>最大方差阈值法（略）</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854545.png" alt="image-20240325184145549"></p><h3 id="基于边缘"><a href="#基于边缘" class="headerlink" title="基于边缘"></a>基于边缘</h3><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854538.png" alt="image-20240325183318662"></p><p>点检测：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854750.png" alt="image-20240325184233339"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854686.png" alt="image-20240325184243150"></p><p>线检测：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854003.png" alt="image-20240325184252957"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854092.png" alt="image-20240325184303083"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854128.png" alt="image-20240325184314742"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854392.png" alt="image-20240325184332650"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854313.png" alt="image-20240325184338680"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854463.png" alt="image-20240325184352638"></p><p>霍夫变换：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854748.png" alt="image-20240325184420751"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854669.png" alt="image-20240325184428657"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854243.png" alt="image-20240325184442342"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854012.png" alt="image-20240325184451158"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854020.png" alt="image-20240325184500442"></p><h3 id="基于区域"><a href="#基于区域" class="headerlink" title="基于区域"></a>基于区域</h3><p>（略）</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854158.png" alt="image-20240325183338037"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854295.png" alt="image-20240325184518642"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854446.png" alt="image-20240325184526153"></p><h3 id="基于学习"><a href="#基于学习" class="headerlink" title="基于学习"></a>基于学习</h3><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403251854609.png" alt="image-20240325183405862"></p>]]></content>
    
    
    <categories>
      
      <category>图像处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像增强</tag>
      
      <tag>图像形态学处理</tag>
      
      <tag>图像分割</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迪AI-神经网络基础学习</title>
    <link href="/2024/03/23/%E8%BF%AAAI-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/03/23/%E8%BF%AAAI-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="迪AI-神经网络基础学习"><a href="#迪AI-神经网络基础学习" class="headerlink" title="迪AI-神经网络基础学习"></a>迪AI-神经网络基础学习</h1><h2 id="一、神经网络"><a href="#一、神经网络" class="headerlink" title="一、神经网络"></a>一、神经网络</h2><p><strong>机器学习流程：</strong></p><blockquote><p>数据获取 — 特征工程（核心）— 建立模型 — 评估与应用</p></blockquote><p><strong>特征工程的作用：</strong></p><ul><li><p>数据特征决定了模型的上限</p></li><li><p>预处理和特征提取是最核心的</p></li><li><p>算法和参数选择决定了如何逼近这个上限</p></li></ul><p><strong>特征如何提取？</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947883.png" alt="image-20240321195233298"></p><p><strong>传统特征提取方法：</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947563.png" alt="image-20240321195318340"></p><p><strong>深度学习</strong></p><p>比较麻烦，这就是为什么需要深度学习：</p><p>相当于黑盒子，通过学习提取一系列最合适的特征：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947518.png" alt="image-20240321195433086"></p><p>深度学习的应用：无人驾驶（目标检测和识别）、人脸识别、医学应用、视频换脸、图像修复</p><p><strong>数据集IMAGENET：</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947941.png" alt="image-20240321202043785"></p><p>数据规模越大，深度学习算法效果越好：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947619.png" alt="image-20240321202214294"></p><p><strong>计算机视觉-图像分类任务</strong></p><p>3颜色通道RGB</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947592.png" alt="image-20240321202335768"></p><p><strong>面临的挑战：</strong></p><p>照射角度、形状改变、部分遮蔽、背景混入</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947165.png" alt="image-20240321202448792"></p><p><strong>机器学习常规套路</strong></p><ul><li>收集数据、给定标签</li><li>训练一个分类器</li><li>测试、评估</li></ul><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947271.png" alt="image-20240321202638832"></p><p><strong>K近邻</strong></p><p>问圆圈属于什么类别？看周围的类别谁多分类成谁</p><p>K等于几就是画几个在圈里：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947253.png" alt="image-20240321203518694"></p><p>计算流程：</p><ul><li>计算已知类别数据集中的点与当前点距离</li><li>按照距离依次排序</li><li>选取与当前点距离最小的K个点</li><li>确定前K个点所在类别的出现频率</li><li>返回前K个点出现频率最高的类别作为当前点预测分类</li></ul><p>K近邻分析：</p><ul><li><p>KNN算法简单有效，是一种lazy-learning算法</p></li><li><p>分类器不需要使用训练集进行训练，训练时间复杂度为0</p></li><li><p>KNN分类的计算复杂度和训练集中的文档数目成正比，也就是说，如果训练集中的文档总数为n，那么KNN的分类时间复杂度为O(n)</p></li><li><p>K值的选择，距离度量和分类决策规则是该算法的三个基本要素</p></li></ul><p><strong>CIFAR-10 数据库简介：</strong></p><p>数据小，32x32x3</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947518.png" alt="image-20240321205957826"></p><p><strong>距离计算：</strong></p><p>和训练集中的5w张图像，分别逐像素相减，取绝对值，然后求和</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947881.png" alt="image-20240321210509541"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947138.png" alt="image-20240321210703137"></p><p>问题：没有区分主体和背景</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947053.png" alt="image-20240321211446688"></p><p><strong>交叉验证：</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947044.png" alt="image-20240321210809493"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947909.png" alt="image-20240321210904342"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947574.png" alt="image-20240321211248857"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947664.png" alt="image-20240321210924072"></p><p><strong>神经网络基础</strong></p><p>线性函数，从输入到输出的映射</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947195.png" alt="image-20240321212441827"></p><p><strong>数学表示：</strong></p><p>计算属于每个类别对应的得分，每种动物有自己的权重W，因此W要有10个</p><p>3072由32x32x3得到，每个类别在每个像素点的权重参数</p><p>b是微调，是偏置参数，对于10个类别得到的分数都要进行微调</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947825.png" alt="image-20240321213137771"></p><p><strong>计算方法：</strong></p><p>权重参数越大，表明相应的像素越重要</p><p> <img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947272.png" alt="image-20240321213340108"></p><p><strong>W如何得到的？</strong></p><p>X数据是不会变的，因此神经网络是寻找合适的W</p><p>W初始是随机的，根据某些优化方法，不断改进W</p><p><strong>决策边界</strong></p><p>W是控制着决策边界的，b只是做微调</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947201.png" alt="image-20240321213812143"></p><p><strong>损失函数</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947308.png" alt="image-20240321213939143"></p><p>损失函数为0的时候 等于没有损失</p><p>用错误类别的分数减去正确类别的分数</p><p>+1的作用 相当于容忍程度 错误类别的分数和正确类别的差距至少要大于1分</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403212140249.png" alt="image-20240321214028180"></p><p>不是 模型A和模型B关注的不一样 </p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947599.png" alt="image-20240322000626595"></p><p><strong>正则化：</strong></p><p>惩罚项，由权重参数带来的损失</p><p>λ为惩罚系数，λ越大表示不希望过拟合，正则化惩罚更大，如果小点就是意思意思一下</p><p>因为神经网络的缺点就是过于强大，过拟合的风险很大</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947768.png" alt="image-20240322000825710"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947775.png" alt="image-20240322004702274"></p><p><strong>Softmax分类器</strong></p><p>随意输入一个数x都可以压缩到0-1之间，恰好把分数转化成了概率值</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947957.png" alt="image-20240322004755210"></p><p>将分数x做exp操作，放大差异，转化为概率值就是做归一化：</p><p>就是把自己的分数除以所有分数的和</p><p>归一化之后，用对数函数求损失，希望正确类别的概率离1越近越好 而损失值就越小</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947911.png" alt="image-20240322005341917"></p><p>回归任务 – 得分值</p><p>分类任务 – 概率值</p><p><strong>前向传播</strong></p><p>由x和w怎么得到一个损失</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947178.png" alt="image-20240322005555783"></p><p><strong>反向传播</strong></p><p>根据loss调整w</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947500.png" alt="image-20240322005627191"></p><p>在前向传播中，得分函数往往是多次变换组合，多个W一起去做 ，每一步关注的不一样</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947494.png" alt="image-20240322151332773"></p><p><strong>梯度下降：</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947437.png"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947589.png"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947866.png" alt="image-20240322152145853"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947172.png" alt="image-20240322152213537"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947491.png" alt="image-20240322152302055"></p><p>希望损失函数的值越低越好 分别求偏导（相当于对结果做了多少贡献）</p><p>先是f对z求偏导 就知道z对结果的影响</p><p>而x经过了2步，先让f对q做偏导 再乘以q对x求的偏导 — 链式求导</p><p>y同理 逐层计算</p><p>反向传播中就是逐层计算</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947540.png" alt="image-20240322152647722"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947883.png" alt="image-20240322152714770"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947449.png" alt="image-20240322152758276"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947836.png" alt="image-20240322152806729"></p><p>可以</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947997.png" alt="image-20240322155459089"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947129.png" alt="image-20240322155603832"></p><p><strong>整体架构：</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947135.png" alt="image-20240322162532669"></p><ul><li><p>层次结构：一层一层办事，在前者的基础上做事</p></li><li><p>神经元： 输入数据的特征数 有多少圈代表有多少输入特征</p></li><li><p>全连接：每个圆圈都连在一起</p></li><li><p>中间层：人类不好理解 计算机可以 </p></li><li><p>权重：线条就是权重 把3个特征转换到4个特征 权重参数 [3,4]</p></li></ul><p>W1 W2W3</p><ul><li>非线性：在每一步矩阵计算后的激活函数</li></ul><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947662.png" alt="image-20240322162850601"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947633.png" alt="image-20240322163512866"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947789.png" alt="image-20240322163522369"></p><p>神经元个数对结果的影响：理论上越多越好，但是出现过拟合</p><p>增加一个神经元、实际上是增加了一组参数</p><p><strong>正则化的作用：</strong></p><p>惩罚力度越小，越符合训练的结果。加大惩罚力度，要平滑的多</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947776.png" alt="image-20240322213718026"></p><p><strong>参数个数对结果的影响：</strong></p><p>神经元个数就是希望转化的特征数量，常见的是64 128 256…</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947434.png" alt="image-20240322213939919"></p><p><strong>激活函数：</strong></p><p>就是非线性变换</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947664.png" alt="image-20240322214049262"></p><p>sigmoid极端处会出现梯度消失 如果梯度为0 会导致后续的梯度也为0 因为是乘法操作</p><p>Relu更实用 没有梯度消失现象</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947022.png" alt="image-20240322220832806"></p><p><strong>数据预处理：</strong></p><p>数据要做预处理 例如中心化（减去均值）、归一化（除以标准差）</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947442.png" alt="image-20240323105624533"></p><p><strong>参数初始化：</strong></p><p>权重参数矩阵给随机的值 随机策略 生成随机参数</p><p>0.01 初始化结果就都比较小</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947493.png" alt="image-20240323105606217"></p><p>防止过拟合，还可以使用<strong>DROP-OUT:</strong></p><p>完整的神经网络 全连接 B图就是在训练中 每一层随机杀死神经元 每次训练都是随机选择一部分</p><p>每次训练 架构都简单些 </p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947134.png" alt="image-20240323111955383"></p><p><strong>神经网络：</strong></p><p>就是找权重参数 什么权重参数最适合网络</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947149.png" alt="image-20240323112247340"></p><p>​                                              </p><h2 id="二、卷积神经网络CNN"><a href="#二、卷积神经网络CNN" class="headerlink" title="二、卷积神经网络CNN"></a>二、卷积神经网络CNN</h2><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947169.png" alt="image-20240323113605752"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947509.png" alt="image-20240323113709657"></p><p><strong>检索：</strong>判断图片是什么 再寻找相似度高的图片出来</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947827.png" alt="image-20240323113717080"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947057.png" alt="image-20240323113814780"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947516.png" alt="image-20240323113827821"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947008.png" alt="image-20240323113840520"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947334.png" alt="image-20240323113922498"></p><p><strong>卷积与传统神经网络nn的区别</strong>：</p><p>输入数据不是一列向量 是三维的 长方体</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947538.png" alt="image-20240323113955554"></p><p><strong>卷积：</strong>提取特征 </p><p><strong>池化：</strong>压缩特征</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947724.png" alt="image-20240323114107526"></p><p><strong>卷积做了什么？</strong></p><ul><li><p>把一张图像分成很多份，比如猫的眼睛 鼻子 嘴 不同的地方进行处理</p></li><li><p>每一块不止一个像素点 例如3x3的区域 对当前区域使用权重参数得到特征值</p></li><li><p>不同区域得到的特征不一样 选择一种计算方法 计算每个区域的特征值</p></li><li><p>找最好的权重参数 最适合的权重参数</p></li></ul><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947738.png" alt="image-20240323120136530"></p><p><strong>图像颜色通道：</strong></p><p>做计算的时候，每个颜色通道都要分别计算 – RGB</p><p>最后要进行加法操作 把3个通道的结果加起来</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947062.png" alt="image-20240323120351228"></p><p><strong>Filter的通道数</strong>必须和输入数据的通道数相同 </p><p><strong>核：</strong>就是选择多大的区域对应于一个特征值</p><p>做的是内积计算 各元素相乘 每个通道做内积最后加起来得到一个特征值 记得加上b偏置</p><p>最终是得到一个特征图</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947371.png" alt="image-20240323120847575"></p><p>核可以是多个 f1-f6 得到丰富的特征 <strong>结果的通道数就是特征图的个数</strong></p><p>同一个卷积层 核的大小必须是相同的</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947385.png" alt="image-20240323123639001"></p><p>卷积得到的特征图再做卷积</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947481.png" alt="image-20240323124033635"></p><p>6个卷积核 卷积核的通道数一定和输入数据的通道数相同</p><p>10个卷积核 </p><p>…</p><p>经过多次卷积提取有用的特征</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947480.png" alt="image-20240323131330271"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947915.png" alt="image-20240323131749989"></p><p><strong>不同步长</strong>得到的特征图大小不一样</p><p>步长比较小的时候 细粒度越高  特征图更丰富</p><p>图像任务的时候步长一般为1  效率比较低</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947933.png" alt="image-20240323131800029"></p><p><strong>卷积核尺寸</strong>是选择区域的大小 卷积核越小 细粒度越高 </p><p>因为卷积的时候 边界点没有中间点利用的次数多  因此通过填充 让边界信息利用充分</p><p>用0填充 不会对结果产生负面影响</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947052.png" alt="image-20240323132346943"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947004.png" alt="image-20240323132522253"></p><p><strong>卷积核个数</strong> 对应的是得到的特征图的个数</p><p><strong>计算：</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947670.png" alt="image-20240323132728711"></p><p>H1 原始输入 FH 是核的高度 P是padding 填充0的圈数</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947643.png" alt="image-20240323132708946"></p><p><strong>例子：</strong></p><p>特征图大小可能不变</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947983.png" alt="image-20240323143545183"></p><p><strong>卷积参数共享：</strong></p><p>每个卷积区域 用相同的核</p><p>每一个卷积核有一个对应的偏置参数</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947013.png" alt="image-20240323144202538"></p><p><strong>池化：</strong></p><p>压缩作用 进行筛选 通道数不变 宽高可以改变</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947226.png" alt="image-20240323144555454"></p><p><strong>最大池化：（常用）</strong></p><p>每个区域选择最大值</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947322.png" alt="image-20240323144656961"></p><p><strong>平均池化：</strong></p><p>每个区域求平均值</p><p><strong>卷积神经网络：</strong></p><p>卷积层+激活函数是一个必须的组合</p><p>两次卷积、一个池化…</p><p><strong>如何将特征图长方体进行分类任务？</strong>还得是全连接层。</p><p>拉成特征向量，输入到全连接层，得到分类结果</p><p><strong>通常是带参数计算的 叫做一层（卷积层、全连接层）</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947695.png" alt="image-20240323144807170"></p><p><strong>特征图变化：</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947687.png" alt="image-20240323145055610"></p><p><strong>经典网络：</strong></p><ul><li><strong>ALEXNET</strong></li></ul><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947899.png" alt="image-20240323145543624"></p><p>pool之后 会损失信息 用特征图个数弥补损失 翻倍了</p><ul><li><strong>VGG</strong></li></ul><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947914.png" alt="image-20240323145620441"></p><p>用更深的网络层数去做 效果不一定更好</p><ul><li><strong>RESNET</strong></li></ul><p>利用同等映射 如果表现不好 如果B不好 把B的权重参数全部置为0 A和C直接连接</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947893.png" alt="image-20240323145823746"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947401.png" alt="image-20240323150116911"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947446.png" alt="image-20240323150137949"></p><p><strong>任务是分类还是回归 取决于损失函数和最后的连接</strong></p><p>把resnet当做特征提取 是一种通用的网络结构</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947597.png" alt="image-20240323150220415"></p><p><strong>感受野：</strong></p><p>无论中间多少层 最后感受到的是原始输入的野</p><p>最后的值是前面多少个值得到的</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947022.png" alt="image-20240323150342629"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947604.png" alt="image-20240323162233484"></p><p>为什么：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947589.png" alt="image-20240323162548862"></p><h2 id="三、递归神经网络RNN"><a href="#三、递归神经网络RNN" class="headerlink" title="三、递归神经网络RNN"></a>三、递归神经网络RNN</h2><p>预测结果的时候 可以把中间和前面的结果考虑进来</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947095.png" alt="image-20240323164311174">CNN 主要用于计算机视觉</p><p>RNN 主要用于自然语言处理</p><p>不同时刻，人为区分的，h0 h1 h2..代表中间结果</p><p>ht表示综合之前所有特征 一般只选最后结果</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947122.png" alt="image-20240323165912756"></p><h2 id="四、LSTM网络"><a href="#四、LSTM网络" class="headerlink" title="四、LSTM网络"></a>四、LSTM网络</h2><p>RNN网络记忆好 把之前所有结果记忆下来</p><p>LSTM可以健忘一些 </p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947305.png" alt="image-20240323170019110"></p><p>C决定保留和遗忘</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947270.png" alt="image-20240323170034459"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947326.png" alt="image-20240323170042587"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947857.png" alt="image-20240323170059371"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947862.png" alt="image-20240323170108477"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947616.png" alt="image-20240323170153092"></p><p>LSTM是在RNN基础上改进的，加上了C控制参数，控制当前模型复杂度</p><p>可以进行信息的过滤</p><p><strong>架构：</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947963.png" alt="image-20240323170310004"></p><h2 id="五、自然语言处理-词向量模型-Word2Vec"><a href="#五、自然语言处理-词向量模型-Word2Vec" class="headerlink" title="五、自然语言处理-词向量模型-Word2Vec"></a>五、自然语言处理-词向量模型-Word2Vec</h2><p>文本向量化后计算机才认识</p><p>基本的出发点：构建词向量</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947113.png" alt="image-20240323174458965"></p><p>通常，数据的维度越高，能提供的信息也就越多，从而计算结果的可靠性就更值得信赖（50-300维）</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947153.png" alt="image-20240323174546034"></p><p>50维 很难解释 只有计算机认识</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947433.png" alt="image-20240323174807095"></p><p><strong>热度图：</strong></p><p>相近的词位置是相似的</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947503.png" alt="image-20240323174842511"></p><p>如何训练词向量？— 词要如何写成一个向量</p><p>预测下一个词</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947689.png" alt="image-20240323175120105"></p><p>和神经网络的多分类挺像的 预测下一个词哪个词的概率更高</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947672.png" alt="image-20240323175448074"></p><p>先把词在词库中匹配向量 随机初始向量组 然后迭代更新输入变量使损失更小 能够更精准预测下一个词</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947042.png" alt="image-20240323175750416"></p><p><strong>训练数据：</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947079.png" alt="image-20240323180029606"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947106.png" alt="image-20240323180151241"></p><p>平移 指定滑动窗口 扫描 得到输入输出</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947168.png" alt="image-20240323180210049"></p><p><strong>不同模型对比：</strong></p><ul><li><strong>CBOW</strong></li></ul><p>输入是上下文，输出中间的词</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947182.png" alt="image-20240323180806133"></p><p>t是输出：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947585.png" alt="image-20240323180826507"></p><ul><li><strong>Skipgram</strong></li></ul><p>输入是中间的词 输出是上下文的预测</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947708.png" alt="image-20240323180856994"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947660.png" alt="image-20240323180939569"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947736.png" alt="image-20240323181000582"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947748.png" alt="image-20240323181025369"></p><p>不仅要更新权重 还要更新数据</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947046.png" alt="image-20240323183800079"></p><p>庞大的语言库 最终希望得到的正确分类概率越高越好 </p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947096.png" alt="image-20240323181132200"></p><p>把原来的输出也放到输入</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947169.png" alt="image-20240323183908065"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947285.png" alt="image-20240323184013420"></p><p>自己添加标签 target为0的 负样本 人为创造的 推荐5个</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947380.png"></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947593.png"></p><p><strong>词向量训练过程：</strong></p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947604.png" alt="image-20240323184307862"></p><p>找对应的矩阵：</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947735.png" alt="image-20240323184444998"></p><p>in out都要进行更新的</p><p>最终得到词向量模型</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202403231947819.png" alt="image-20240323184506669"></p>]]></content>
    
    
    <categories>
      
      <category>AI学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>神经网络</tag>
      
      <tag>CNN</tag>
      
      <tag>RNN</tag>
      
      <tag>LSTM</tag>
      
      <tag>Word2Vec</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode04：移动零</title>
    <link href="/2024/03/13/LeetCode04/"/>
    <url>/2024/03/13/LeetCode04/</url>
    
    <content type="html"><![CDATA[<h1 id="4-移动零"><a href="#4-移动零" class="headerlink" title="4.移动零"></a>4.移动零</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: nums = <span class="hljs-string">[0,1,0,3,12]</span><br>输出: <span class="hljs-string">[1,3,12,0,0]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[0]</span><br>输出: <span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="（1）我的解法"><a href="#（1）我的解法" class="headerlink" title="（1）我的解法"></a>（1）我的解法</h3><p>通过循环数组的<code>remove</code>操作依次将0移除，移除次数为填0次数，最后在数组末尾填充相应次数的0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">moveZeroes</span>(<span class="hljs-params">self, nums</span>):<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-number">0</span> <span class="hljs-keyword">in</span> nums:<br>            nums.remove(<span class="hljs-number">0</span>)<br>            count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(count):<br>            nums.append(<span class="hljs-number">0</span>)                <br>        <span class="hljs-keyword">return</span> nums<br></code></pre></td></tr></table></figure><h3 id="（2）官方题解"><a href="#（2）官方题解" class="headerlink" title="（2）官方题解"></a>（2）官方题解</h3><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>左右指针都在索引起始处，先判断右指针位置的元素是否为0，如果为0，右指针继续走一步；如果不为0，将左右指针的元素对换，左指针继续往前一步。右指针继续走一步，继续处理，直到右指针走到最末。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">moveZeroes</span>(<span class="hljs-params">self, nums</span>):<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        left = right = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> right &lt; n:<br>            <span class="hljs-keyword">if</span> nums[right] != <span class="hljs-number">0</span>:<br>                nums[left], nums[right] = nums[right], nums[left]<br>                left += <span class="hljs-number">1</span><br>            right += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> nums<br></code></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><strong>双指针法的时间与空间复杂度</strong></p><blockquote><p>时间复杂度：O(n)，其中 n 为序列长度。每个位置至多被遍历两次。</p><p>空间复杂度：O(1)。只需要常数的空间存放若干变量。</p></blockquote><p><strong>双指针元素兑换</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">nums[left], nums[right] = nums[right], nums[left]<br></code></pre></td></tr></table></figure><p><strong>数组操作</strong></p><blockquote><ol><li>创建数组：使用方括号 <code>[]</code> 来创建数组，例如 <code>my_list = [1, 2, 3, 4, 5]</code>。</li><li>访问元素：通过索引来访问数组中的元素，索引从 0 开始，例如 <code>my_list[0]</code> 返回数组的第一个元素。</li><li>切片操作：可以使用切片来获取数组中的子数组，例如 <code>my_list[1:3]</code> 返回索引 1 到 2 的子数组。</li><li>添加元素：使用 <code>append()</code> 方法向数组末尾添加新元素，例如 <code>my_list.append(6)</code>。</li><li>插入元素：使用 <code>insert()</code> 方法在指定位置插入元素，例如 <code>my_list.insert(2, 7)</code> 在索引 2 处插入元素 7。</li><li>删除元素：使用 <code>remove()</code> 方法删除指定元素，例如 <code>my_list.remove(3)</code> 删除元素 3。</li><li>弹出元素：使用 <code>pop()</code> 方法弹出指定索引的元素，例如 <code>my_list.pop(1)</code> 弹出索引 1 处的元素。</li><li>查找元素：使用 <code>index()</code> 方法查找指定元素的索引，例如 <code>my_list.index(4)</code> 返回元素 4 的索引。</li><li>数组长度：使用 <code>len()</code> 函数获取数组的长度，例如 <code>len(my_list)</code> 返回数组的长度。</li><li>排序数组：使用 <code>sort()</code> 方法对数组进行排序，例如 <code>my_list.sort()</code> 对数组进行升序排序。</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>题库</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT03：数素数</title>
    <link href="/2024/03/13/PAT03/"/>
    <url>/2024/03/13/PAT03/</url>
    
    <content type="html"><![CDATA[<h1 id="3-数素数"><a href="#3-数素数" class="headerlink" title="3.数素数"></a>3.数素数</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>题目描述</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">令Pi表示第i（i从<span class="hljs-number">1</span>开始计数）个素数。现任给两个正整数M &lt;<span class="hljs-operator">=</span> N &lt;<span class="hljs-operator">=</span> <span class="hljs-number">10000</span>，请输出PM到PN的所有素数。<br></code></pre></td></tr></table></figure><p><strong>输入描述:</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入在一行中给出M和<span class="hljs-built_in">N</span>，其间以空格分隔。<br></code></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">输出从PM到PN的所有素数，每10个数字占1行，其间以空格分隔，但行末不得有多余空格。<br></code></pre></td></tr></table></figure><p><strong>输入例子:</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">27</span><br></code></pre></td></tr></table></figure><p><strong>输出例子:</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">11 </span><span class="hljs-number">13</span> <span class="hljs-number">17</span> <span class="hljs-number">19</span> <span class="hljs-number">23</span> <span class="hljs-number">29</span> <span class="hljs-number">31</span> <span class="hljs-number">37</span> <span class="hljs-number">41</span> <span class="hljs-number">43</span><br><span class="hljs-symbol">47 </span><span class="hljs-number">53</span> <span class="hljs-number">59</span> <span class="hljs-number">61</span> <span class="hljs-number">67</span> <span class="hljs-number">71</span> <span class="hljs-number">73</span> <span class="hljs-number">79</span> <span class="hljs-number">83</span> <span class="hljs-number">89</span><br><span class="hljs-symbol">97 </span><span class="hljs-number">101</span> <span class="hljs-number">103</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="1-我的解法"><a href="#1-我的解法" class="headerlink" title="(1)我的解法"></a>(1)我的解法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">suShu</span>(<span class="hljs-params">num</span>):<br>    <span class="hljs-keyword">if</span> num &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    n = <span class="hljs-built_in">int</span>(num**<span class="hljs-number">0.5</span>) + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> num % i == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> num != i:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">outNum</span>(<span class="hljs-params">nums</span>):<br>    <span class="hljs-keyword">for</span> i,num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums,start=<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> i % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(num)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(nums):<br>                <span class="hljs-built_in">print</span>(num,end=<span class="hljs-string">&#x27;&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(num,end=<span class="hljs-string">&#x27; &#x27;</span>)<br>    <br><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:<br>    res = []<br>    m,n = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,line.split())<br>    num = <span class="hljs-number">1</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        num += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> suShu(num):<br>            count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> m&lt;=count&lt;=n:<br>                res.append(num)<br>            <span class="hljs-keyword">elif</span> count &gt; n:<br>                <span class="hljs-keyword">break</span><br>    outNum(res)<br><br></code></pre></td></tr></table></figure><h3 id="（2）其他解法"><a href="#（2）其他解法" class="headerlink" title="（2）其他解法"></a>（2）其他解法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">isPrime</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">int</span>(sqrt(x))+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> x % i == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:<br>    no = line.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>    m, n = <span class="hljs-built_in">int</span>(no[<span class="hljs-number">0</span>]), <span class="hljs-built_in">int</span>(no[<span class="hljs-number">1</span>])<br>    i,count = <span class="hljs-number">2</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> count &lt; n :<br>        <span class="hljs-keyword">if</span> isPrime(i):<br>            count += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> count &gt;= m:<br>                <span class="hljs-keyword">if</span> (count-m+<span class="hljs-number">1</span>)%<span class="hljs-number">10</span> != <span class="hljs-number">0</span>:<br>                    <span class="hljs-built_in">print</span>(i,end=<span class="hljs-string">&#x27; &#x27;</span>),<br>                <span class="hljs-keyword">else</span> :<br>                    <span class="hljs-built_in">print</span>(i)<br>        i += <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><strong>素数（质数）</strong></p><blockquote><p>指在大于1的<a href="https://baike.baidu.com/item/%E8%87%AA%E7%84%B6%E6%95%B0/385394?fromModule=lemma_inlink">自然数</a>中，除了1和它本身以外不再有其他<a href="https://baike.baidu.com/item/%E5%9B%A0%E6%95%B0/9539111?fromModule=lemma_inlink">因数</a>的自然数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">isPrime</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">int</span>(sqrt(x))+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> x % i == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>打印分隔符</strong></p><blockquote><p>打印结束时使用的行尾符号，默认是换行符 <code>\n</code>。</p></blockquote><p><code>sep</code>是间隔中有符号，末尾不会有符号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(item1, item2, item3, sep=<span class="hljs-string">&#x27; 分隔符 &#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>end</code>是每个元素后面都有符号，末尾也会有</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(item1, item2, end=<span class="hljs-string">&#x27; 结尾符 &#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>每10个处理一次</strong></p><blockquote><p>1、结果列表中的元素索引 % 10 &#x3D;&#x3D; 0</p><p>2、（输出序数-输出开始数+1）%10 &#x3D;&#x3D; 0</p></blockquote><p><strong>开根</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">num**<span class="hljs-number">0.5</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt<br>sqrt(num)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>题库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode03：最长连续序列</title>
    <link href="/2024/03/08/LeetCode03/"/>
    <url>/2024/03/08/LeetCode03/</url>
    
    <content type="html"><![CDATA[<h1 id="3-最长连续序列"><a href="#3-最长连续序列" class="headerlink" title="3.最长连续序列"></a>3.最长连续序列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[100,4,200,1,3,2]</span><br>输出：<span class="hljs-number">4</span><br>解释：最长数字连续序列是 <span class="hljs-string">[1, 2, 3, 4]</span>。它的长度为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,3,7,2</span>,<span class="hljs-number">5,8,4,6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="（1）官方题解"><a href="#（1）官方题解" class="headerlink" title="（1）官方题解"></a>（1）官方题解</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>考虑枚举数组中的每个数<code>x</code>，考虑以其为起点，不断尝试寻找<code>x+1</code>,<code>x+2</code>…是否存在。假设匹配到了<code>x+y</code>，那么以<code>x</code>为起点的最长连续序列为<code>x</code>,<code>x+1</code>,<code>x+2</code>…<code>x+y</code>，其长度为<code>y+1</code>，不断枚举并更新答案即可。</p><p>对于匹配的过程，<strong>暴力匹配</strong>是O(n)遍历数组去看是否存在这个数，<strong>更高效的匹配</strong>是用一个哈希表存储数组中的数，查看一个数是否存在，优化到O(1)的时间复杂度。</p><p>仅仅是这样，算法时间复杂度最坏情况下还是会达到O($n^2$)（即外层需要枚举O(n)个数，内层需要暴力匹配O(n)次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，已知有一个<code>x</code>,<code>x+1</code>,<code>x+2</code>…<code>x+y</code>的连续序列，而重新从<code>x+1</code>,<code>x+2</code>…<code>x+y</code>处开始匹配，得到的结果一定不会优于枚举<code>x</code>为起点的答案，因此，需要跳过。</p><p>判断是否跳过：要枚举的数<code>x</code>一定是在数组中不存在前驱数 <code>x-1</code>的。</p><p><strong>时间复杂度：</strong>外层循环需要O(n)的时间复杂度，只有当一个数是连续序列的第一个数的情况下才会进入内层循环，然后在内层循环中匹配连续序列中的数，因此数组中的每个数只会进入内层循环一次。根据上述分析可知，总时间复杂度为 O(n)。</p><p><strong>空间复杂度：</strong>O(n)。哈希表存储数组中所有的数需要 O(n)的空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestConsecutive</span>(<span class="hljs-params">self,nums</span>):<br>        longest_streak = <span class="hljs-number">0</span><br>        num_set = <span class="hljs-built_in">set</span>(nums)<br>        <br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> num_set:<br>            <span class="hljs-keyword">if</span> num - <span class="hljs-number">1</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> num_set:<br>                current_num = num<br>                current_streak = <span class="hljs-number">1</span><br>                <br>                <span class="hljs-keyword">while</span> current_num + <span class="hljs-number">1</span> <span class="hljs-keyword">in</span> num_set:<br>                    current_num += <span class="hljs-number">1</span><br>                    current_streak += <span class="hljs-number">1</span><br>                <br>                longest_streak = <span class="hljs-built_in">max</span>(longest_streak,current_streak)<br>        <span class="hljs-keyword">return</span> longest_streak<br></code></pre></td></tr></table></figure><h3 id="（2）我的解法"><a href="#（2）我的解法" class="headerlink" title="（2）我的解法"></a>（2）我的解法</h3><p><strong>时间复杂度：</strong><br>排序：首先，算法中使用了排序，其时间复杂度为 O(n log n)，其中 n 是数组 nums 的长度。这是因为大多数比较排序算法（如快速排序、归并排序等）的时间复杂度都是 O(n log n)。</p><p>遍历：排序之后，算法遍历了排序后的数组一次以计算最长连续序列的长度。这个遍历的时间复杂度是 O(n)，因为每个元素都被访问一次。</p><p>因此，算法的总体时间复杂度主要由排序这一步骤决定，即 O(n log n)。虽然遍历也涉及到数组中的所有元素，但其时间复杂度 O(n) 在排序的时间复杂度 O(n log n) 面前可以忽略不计。</p><p><strong>空间复杂度：</strong></p><p>算法的空间复杂度主要取决于排序算法的空间复杂度。在 Python 中，排序通常使用 Timsort 算法，其最坏情况下的空间复杂度为 O(n)。除此之外，还使用了一个列表 res 来存储每个连续序列的长度，以及几个用于记录状态的变量（如 max_len）。因此，总体空间复杂度也是 O(n)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestConsecutive</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-keyword">if</span> nums == []:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        nums = <span class="hljs-built_in">sorted</span>(nums)<br>        res = []<br>        max_len = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i,num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            <span class="hljs-keyword">if</span> i&lt;<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>: <br>                <span class="hljs-keyword">if</span> nums[i+<span class="hljs-number">1</span>] - num == <span class="hljs-number">1</span>:<br>                    max_len +=<span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> nums[i+<span class="hljs-number">1</span>] == num:<br>                    <span class="hljs-keyword">pass</span><br>                <span class="hljs-keyword">else</span>:<br>                    res.append(max_len)<br>                    max_len = <span class="hljs-number">1</span><br>        res.append(max_len)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(res)   <br></code></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><strong>使用哈希表的优势</strong></p><blockquote><p>如果输入数组非常大，排序可能会成为性能瓶颈。与之相比，使用哈希表的方法虽然在理论上最坏情况下的时间复杂度也是 O(n)，但在实际应用中往往能够更高效地解决问题，尤其是当数据量大且数组中包含大量连续序列时。</p></blockquote><p><strong>集合set()方法</strong></p><blockquote><p><code>set()</code>方法在Python中用于创建一个无序且不重复的元素集合。这是一种基本的数据结构，适用于去除重复元素以及执行各种集合操作（如并集、交集、差集等）。<code>set()</code>可以接收一个可迭代对象作为输入，比如列表、元组、字典等，然后将其转换成一个集合。如果不提供任何参数，<code>set()</code>会创建一个空集合。</p><ul><li>集合中的元素必须是不可变类型（如整数、浮点数、字符串、元组），不能是可变类型（如列表、字典）。</li><li>使用<code>&#123;&#125;</code>可以创建集合，但如果没有提供任何元素，Python会将其解释为一个空字典而不是空集合。因此，创建空集合必须使用<code>set()</code>。</li><li><code>set()</code>创建的集合是无序的，所以无法保证每次遍历集合时元素的顺序相同。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>题库</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT02：数字分类</title>
    <link href="/2024/03/07/PAT02/"/>
    <url>/2024/03/07/PAT02/</url>
    
    <content type="html"><![CDATA[<h1 id="2-数字分类"><a href="#2-数字分类" class="headerlink" title="2.数字分类"></a>2.数字分类</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字：<br> A1 &#x3D; 能被5整除的数字中所有偶数的和；</p><p> A2 &#x3D; 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4…；</p><p> A3 &#x3D; 被5除后余2的数字的个数；</p><p> A4 &#x3D; 被5除后余3的数字的平均数，精确到小数点后1位；</p><p> A5 &#x3D; 被5除后余4的数字中最大数字。</p><p><strong>输入：</strong>每个输入包含1个测试用例。<br>每个测试用例先输入一个不超过1000的正整数N。<br>然后给出N个不超过1000的待分类的正整数。数字间以空格分隔。</p><p><strong>输出：</strong>对给定的N个正整数，按题目要求计算A1~A5并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。若其中某一类数字不存在，则在相应位置输出“N”。</p><p><strong>输入例子:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">13</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">20</span> <span class="hljs-number">16</span> <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p><strong>输出例子:</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">30 </span><span class="hljs-number">11</span> <span class="hljs-number">2</span> <span class="hljs-number">9.7</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="（1）我的解法"><a href="#（1）我的解法" class="headerlink" title="（1）我的解法"></a>（1）我的解法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:<br>    a1 = []<br>    a2 = []<br>    a3 = []<br>    a4 = []<br>    a5 = []<br>    nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,line.split(<span class="hljs-string">&#x27; &#x27;</span>)))    <br>    n = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums[<span class="hljs-number">1</span>:]:<br>        <span class="hljs-keyword">if</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>            a1.append(i)<br>        <span class="hljs-keyword">if</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">1</span>:<br>            a2.append(i)<br>        <span class="hljs-keyword">if</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">2</span>:<br>            a3.append(i)<br>        <span class="hljs-keyword">if</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">3</span>:<br>            a4.append(i)<br>        <span class="hljs-keyword">if</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">4</span>:<br>            a5.append(i)<br>    <span class="hljs-keyword">if</span> a1:<br>        A1 = <span class="hljs-built_in">sum</span>(a1)<br>    <span class="hljs-keyword">else</span>:<br>        A1 = <span class="hljs-string">&#x27;N&#x27;</span>    <br>    <br>    A2 = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> a2:<br>        <span class="hljs-keyword">for</span> i,num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a2):<br>            A2 += -((-<span class="hljs-number">1</span>)**(i+<span class="hljs-number">1</span>)*num)<br>    <span class="hljs-keyword">else</span>:<br>        A2 = <span class="hljs-string">&#x27;N&#x27;</span><br><br>    <span class="hljs-keyword">if</span> a3:<br>        A3 = <span class="hljs-built_in">len</span>(a3) <br>    <span class="hljs-keyword">else</span>:<br>        A3 = <span class="hljs-string">&#x27;N&#x27;</span>                <br><br>    <span class="hljs-keyword">if</span> a4:<br>        A4 = <span class="hljs-built_in">round</span>(<span class="hljs-built_in">sum</span>(a4) / <span class="hljs-built_in">len</span>(a4),<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">else</span>:<br>        A4 = <span class="hljs-string">&#x27;N&#x27;</span><br>                 <br>    <span class="hljs-keyword">if</span> a5:<br>        A5 = <span class="hljs-built_in">max</span>(a5)<br>    <span class="hljs-keyword">else</span>:<br>        A5 = <span class="hljs-string">&#x27;N&#x27;</span>          <br>    <br>    <span class="hljs-built_in">print</span>(A1,A2,A3,A4,A5,sep=<span class="hljs-string">&#x27; &#x27;</span>)    <br>   <br></code></pre></td></tr></table></figure><h3 id="（2）其他解法"><a href="#（2）其他解法" class="headerlink" title="（2）其他解法"></a>（2）其他解法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">ary = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>n, ary = ary[<span class="hljs-number">0</span>], ary[<span class="hljs-number">1</span>:]<br>A1, A2, A4 = [], [], []<br>A3, A5 = <span class="hljs-number">0</span>, -<span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ary:<br>    <span class="hljs-keyword">if</span> i % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>:<br>        A1.append(i)<br>    <span class="hljs-keyword">elif</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">1</span>:<br>        A2.append(i)<br>    <span class="hljs-keyword">elif</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">2</span>:<br>        A3 += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">3</span>:<br>        A4.append(i)<br>    <span class="hljs-keyword">elif</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">4</span>:<br>        <span class="hljs-keyword">if</span> i &gt; A5:<br>            A5 = i<br>A1 = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">sum</span>(A1)) <span class="hljs-keyword">if</span> A1 <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;N&#x27;</span><br>A2 = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">sum</span>(A2[::<span class="hljs-number">2</span>]) - <span class="hljs-built_in">sum</span>(A2[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>])) <span class="hljs-keyword">if</span> A2 <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;N&#x27;</span><br>A3 = <span class="hljs-built_in">str</span>(A3) <span class="hljs-keyword">if</span> A3 <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;N&#x27;</span><br>A4 = <span class="hljs-string">&#x27;&#123;:.1f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">sum</span>(A4) / <span class="hljs-built_in">len</span>(A4)) <span class="hljs-keyword">if</span> A4 <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;N&#x27;</span><br>A5 = <span class="hljs-built_in">str</span>(A5) <span class="hljs-keyword">if</span> A5 != -<span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;N&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27; &#x27;</span>.join((A1, A2, A3, A4, A5)))<br></code></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><strong>切片操作</strong></p><blockquote><p>在Python中，对列表进行切片操作时，可以使用<code>[start:stop:step]</code>的形式来指定切片的开始、结束和步长。这里的<code>start</code>表示起始索引，<code>stop</code>表示结束索引（不包含该索引处的元素），<code>step</code>表示步长。计算交错求和的时候，可以计算奇数索引位置上的数字之和减去偶数索引位置上的数字之和。<code>sum(A2[::2])</code>表示求取<code>A2</code>列表中所有偶数索引位置上的数字之和，<code>sum(A2[1::2])</code>表示求取<code>A2</code>列表中所有奇数索引位置上的数字之和。</p></blockquote><p><strong>格式化字符串</strong></p><blockquote><p><code>&#39;&#123;:.1f&#125;&#39;</code> 是一个格式化字符串，它表示将要格式化的值为浮点数，并保留一位小数。这样的格式化字符串会将浮点数格式化为带有一位小数的字符串。</p><ul><li><code>&#123;&#125;</code> 表示一个占位符，用于接受要格式化的值。</li><li><code>:</code> 表示格式说明符的开始。</li><li><code>.1</code> 表示精度为1，即保留一位小数。</li><li><code>f</code> 表示格式化为浮点数。</li></ul><p><code>.format()</code> 方法用于对字符串进行格式化，它可以将指定的值插入到格式化字符串中的大括号处。</p></blockquote><p><strong><code>&#39; &#39;.join()</code>和 <code>sep=&#39; &#39;</code></strong></p><blockquote><p><code>&#39; &#39;.join()</code> 方法的作用是将序列中的元素以指定的字符连接起来形成一个字符串。根据需要在 <code>&#39; &#39;</code> 中间放置任何你想要的分隔符。<code>sep=&#39; &#39;</code> 是 <code>print()</code> 函数的一个参数，用于指定多个要打印内容之间的分隔符</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>题库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode02：字母异位词分组</title>
    <link href="/2024/03/06/LeetCode02/"/>
    <url>/2024/03/06/LeetCode02/</url>
    
    <content type="html"><![CDATA[<h1 id="2-字母异位词分组"><a href="#2-字母异位词分组" class="headerlink" title="2.字母异位词分组"></a>2.字母异位词分组</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: strs = [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;bat&quot;</span>],[<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],[<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>]]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;a&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;a&quot;]]</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="（1）字母排序"><a href="#（1）字母排序" class="headerlink" title="（1）字母排序"></a>（1）字母排序</h3><p>1、首先需要理解什么是字母异位词（相同的字母不同的排列顺序组成的单词）</p><p>2、根据特征进行归类，考虑使用哈希表</p><p>3、构造单词的字符排序，作为键；分组结果，作为值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collections<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-params">self, strs</span>):<br>        mp = collections.defaultdict(<span class="hljs-built_in">list</span>)<br><br>        <span class="hljs-keyword">for</span> st <span class="hljs-keyword">in</span> strs:<br>            key = <span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">sorted</span>(st))<br>            mp[key].append(st)<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(mp.values())<br></code></pre></td></tr></table></figure><h3 id="（2）字符计数"><a href="#（2）字符计数" class="headerlink" title="（2）字符计数"></a>（2）字符计数</h3><p>1、观察发现，每个字符出现的次数完全相同</p><p>2、根据特征进行归类，考虑使用哈希表</p><p>3、“#1#3…#0”构造各字母出现次数的特征字符串，作为键；具有相同特征字符串的单词放在一组，作为值</p><h4 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><strong>官方题解</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collections<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-params">self,strs</span>):<br>        mp = collections.defaultdict(<span class="hljs-built_in">list</span>)<br>        <br>        <span class="hljs-keyword">for</span> st <span class="hljs-keyword">in</span> strs:<br>            counts = [<span class="hljs-number">0</span>] *<span class="hljs-number">26</span><br>            <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> st:<br>                counts[<span class="hljs-built_in">ord</span>(ch)-<span class="hljs-built_in">ord</span>(<span class="hljs-string">&quot;a&quot;</span>)] += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 需要将list转换为tuple才可以进行哈希</span><br>            mp[<span class="hljs-built_in">tuple</span>(counts)].append(st)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(mp.values())<br></code></pre></td></tr></table></figure><h4 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a><strong>我的解法</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-params">self, strs</span>):<br>        total_dict = &#123;&#125;<br>        same_map = &#123;&#125;<br>        res = []<br>        <span class="hljs-keyword">for</span> index,word <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(strs):<br>            word_dict = &#123;&#125;<br>            <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> word:<br>                word_dict[s] = word_dict.get(s,<span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br>            total_dict[index] = <span class="hljs-built_in">sorted</span>(word_dict.items())<br>        <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> total_dict.items():<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">tuple</span>(val) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> same_map:<br>                same_map[<span class="hljs-built_in">tuple</span>(val)] = [key]<br>            <span class="hljs-keyword">else</span>:<br>                same_map[<span class="hljs-built_in">tuple</span>(val)].append(key)<br>        <span class="hljs-keyword">for</span> tar <span class="hljs-keyword">in</span> same_map.values():<br>            target = [strs[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tar]<br>            res.append(target)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li><strong>时间与空间复杂度</strong></li></ul><blockquote><p>1、字母排序：N是单词的个数，K是单词的最大长度。遍历每个单词的时间复杂度是O(N)，对于每个单词的排序时间复杂度为O(Klog(K))。综合以上两点，时间复杂度为O(NKlog(K))。空间上需要O(NK)存储所有单词。</p><p>2、字符计数：因为需要遍历每个单词的每个字符，时间复杂度为O(NK)，空间复杂度为O(NK)。</p></blockquote><ul><li><strong><code>defaultdict</code></strong></li></ul><blockquote><p><code>collections.defaultdict(list)</code> 是 Python 中 <code>collections</code> 模块提供的一个类，它是字典的一个子类，用于创建默认值为指定类型（这里是列表）的字典。在使用 <code>defaultdict</code> 时，如果访问一个不存在的键，它会自动创建该键，并将其对应的值初始化为指定类型的默认值。</p></blockquote><ul><li><strong><code>ord()</code> 函数</strong></li></ul><blockquote><p><code>ord()</code> 函数用于返回表示单个字符的 Unicode 字符编码。对于小写字母，<code>ord(&quot;a&quot;)</code> 返回的是 97，<code>ord(&quot;b&quot;)</code> 返回的是 98，依此类推。<code>ord(ch) - ord(&quot;a&quot;)</code>：假设当前字符是小写字母，通过将当前字符的 Unicode 编码减去小写字母 “a” 的 Unicode 编码（即 97），可以得到一个从 0 到 25 的索引值，用来表示该字符在英文字母中的位置，例如 a 对应 0，b 对应 1，依此类推。</p></blockquote><ul><li><strong>字典（dictionary）</strong></li></ul><blockquote><p>在Python中，字典（dictionary）是一种无序的数据类型，用于存储键值对。字典是一种非常灵活和强大的数据结构，常用于存储和操作各种类型的数据。</p></blockquote><p>以下是关于字典的一些常见用法：</p><ol><li><p>创建字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict = &#123;<span class="hljs-string">&#x27;A&#x27;</span>: <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;B&#x27;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-number">300</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p>添加或更新键值对：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict[<span class="hljs-string">&#x27;D&#x27;</span>] = <span class="hljs-number">400</span>  <span class="hljs-comment"># 添加新的键值对</span><br>my_dict[<span class="hljs-string">&#x27;A&#x27;</span>] = <span class="hljs-number">500</span>  <span class="hljs-comment"># 更新已有键的值</span><br></code></pre></td></tr></table></figure></li><li><p>访问字典中的元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">value = my_dict[<span class="hljs-string">&#x27;A&#x27;</span>]  <span class="hljs-comment"># 获取键为&#x27;A&#x27;的值</span><br></code></pre></td></tr></table></figure></li><li><p>删除键值对：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> my_dict[<span class="hljs-string">&#x27;B&#x27;</span>]  <span class="hljs-comment"># 删除键为&#x27;B&#x27;的键值对</span><br></code></pre></td></tr></table></figure></li><li><p>遍历字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> my_dict.items():<br>    <span class="hljs-built_in">print</span>(key, value)<br></code></pre></td></tr></table></figure></li><li><p>检查键是否存在：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-keyword">in</span> my_dict:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;A exists in the dictionary&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>获取所有键或所有值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">keys = my_dict.keys()  <span class="hljs-comment"># 获取所有键</span><br>values = my_dict.values()  <span class="hljs-comment"># 获取所有值</span><br></code></pre></td></tr></table></figure></li><li><p>获取默认值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">value = my_dict.get(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">0</span>)  <span class="hljs-comment"># 获取键&#x27;A&#x27;的值，如果不存在则返回默认值0</span><br></code></pre></td></tr></table></figure></li><li><p>使用字典推导式创建字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">squares = &#123;x: x*x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)&#125;  <span class="hljs-comment"># 创建包含1到5的平方的字典</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>题库</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT01：A+B和C</title>
    <link href="/2024/03/02/PAT01/"/>
    <url>/2024/03/02/PAT01/</url>
    
    <content type="html"><![CDATA[<h1 id="1-A-B和C"><a href="#1-A-B和C" class="headerlink" title="1.A+B和C"></a>1.A+B和C</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定区间[-231, 231]内的3个整数A、B和C，请判断A+B是否大于C。</p><p><strong>输入：</strong>输入第1行给出正整数T(&lt;&#x3D;10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。</p><p><strong>输出：</strong>对每组测试用例，在一行中输出“Case #X: true”如果A+B&gt;C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。</p><p><strong>输入例子：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2147483647 </span><span class="hljs-number">0</span> <span class="hljs-number">2147483646</span><br><span class="hljs-symbol">0 </span>-<span class="hljs-number">2147483648</span> -<span class="hljs-number">2147483647</span><br></code></pre></td></tr></table></figure><p><strong>输出例子：</strong></p><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cal"><span class="hljs-keyword">Case</span> <span class="hljs-string">#1</span>: <span class="hljs-literal">false</span><br><span class="hljs-keyword">Case</span> <span class="hljs-string">#2</span>: <span class="hljs-literal">true</span><br><span class="hljs-keyword">Case</span> <span class="hljs-string">#3</span>: <span class="hljs-literal">true</span><br><span class="hljs-keyword">Case</span> <span class="hljs-string">#4</span>: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="（1）我的解法"><a href="#（1）我的解法" class="headerlink" title="（1）我的解法"></a>（1）我的解法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br>index = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:<br>    index +=<span class="hljs-number">1</span><br>    a = line.split()<br>    a = [<span class="hljs-built_in">int</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a]<br>    <span class="hljs-keyword">if</span> index == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Case #<span class="hljs-subst">&#123;index-<span class="hljs-number">1</span>&#125;</span>: <span class="hljs-subst">&#123;<span class="hljs-built_in">str</span>(a[<span class="hljs-number">0</span>]+a[<span class="hljs-number">1</span>]&gt;a[<span class="hljs-number">2</span>]).lower()&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="（2）其他解法"><a href="#（2）其他解法" class="headerlink" title="（2）其他解法"></a>（2）其他解法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    a,b,c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,<span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Case #&#x27;</span>+<span class="hljs-built_in">str</span>((i+<span class="hljs-number">1</span>))+<span class="hljs-string">&#x27;: true&#x27;</span> <span class="hljs-keyword">if</span> a+b&gt;c <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;Case #&#x27;</span>+<span class="hljs-built_in">str</span>((i+<span class="hljs-number">1</span>))+<span class="hljs-string">&#x27;: false&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li><code>sys.stdin</code></li></ul><blockquote><p><code>sys.stdin</code>是Python中<code>sys</code>模块的一个属性，代表了标准输入流。在计算机程序中，标准输入流是一个用于接收输入数据的通道，通常情况下它是与键盘输入关联的，但也可以通过重定向或管道从文件或其他程序接收输入。</p><p>在Python程序中，使用<code>sys.stdin</code>可以读取来自命令行（或任何被重定向为标准输入源的数据）的输入。<code>sys.stdin</code>本质上是一个文件对象，因此可以对它使用文件操作的方法，如<code>read()</code>, <code>readline()</code>和<code>readlines()</code>等，来读取输入的数据。</p><p>1、<code>sys.stdin.read()</code>: 读取并返回所有剩余的输入数据，直到遇到EOF（文件结束符）。</p><p>2、<code>sys.stdin.readline()</code>: 每次调用读取一行输入，包括行尾的换行符，如果已经到达EOF，则返回一个空字符串。</p><p>3、<code>sys.stdin.readlines()</code>: 读取所有剩余的输入行，并将它们作为字符串列表返回。</p><p><code>for line in sys.stdin:</code>循环会逐行读取标准输入直到EOF。这种方式特别适合处理不确定数量的输入行。</p><p>在命令行环境中，通常可以通过<code>Ctrl+D</code>（在Unix&#x2F;Linux&#x2F;macOS系统中）或<code>Ctrl+Z</code>然后回车（在Windows系统中）来发送EOF信号。此外，<code>sys.stdin</code>也常被用于从文件中读取输入，通过命令行重定向操作，例如<code>python script.py &lt; inputfile.txt</code>，这时<code>inputfile.txt</code>的内容会被作为标准输入传递给脚本。</p></blockquote><ul><li><strong>三元运算符</strong></li></ul><blockquote><p><code>print(&quot;Case #&quot;+str(i+1)+&quot;: true&quot; if b+c&gt;d else &quot;Case #&quot;+str(i+1)+&quot;: false&quot;)</code>: </p><p>使用条件表达式（三元操作符）简化逻辑判断，而且字符串不能直接拼接整数，需要先对整数进行<code>str()</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>题库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode01：两数之和</title>
    <link href="/2024/03/02/LeetCode01/"/>
    <url>/2024/03/02/LeetCode01/</url>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="（1）暴力枚举"><a href="#（1）暴力枚举" class="headerlink" title="（1）暴力枚举"></a>（1）暴力枚举</h3><p>枚举数组中的每一个数<code>x</code>，寻找数组中是否存在<code>target-x</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self,nums,target</span>):<br>        n = <span class="hljs-built_in">len</span>(nums)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,n):<br>                <span class="hljs-keyword">if</span> nums[i] + nums[j] == target:<br>                    <span class="hljs-keyword">return</span> [i,j]<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h3 id="（2）哈希表"><a href="#（2）哈希表" class="headerlink" title="（2）哈希表"></a>（2）哈希表</h3><p>对于数组中的每一个数<code>x</code>，首先查询哈希表中是否存在<code>target-x</code>，如果存在则返回结果，不存在就将<code>x</code>插入到哈希表中，保证不会让<code>x</code>和自己匹配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">self,nums,target</span>):<br>        hashtable = <span class="hljs-built_in">dict</span>()<br>        <span class="hljs-keyword">for</span> i,num <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(nums):<br>            num2 = target - num <br>            <span class="hljs-built_in">print</span>(num,num2)<br>            <span class="hljs-keyword">if</span> num2 <span class="hljs-keyword">in</span> hashtable:<br>                <span class="hljs-keyword">return</span> [i,hashtable[num2]]<br>            hashtable[num] = i<br>            <span class="hljs-built_in">print</span>(hashtable)<br>        <span class="hljs-keyword">return</span> []    <br></code></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li><p><strong>是否会报超出索引异常</strong></p><blockquote><p>在方法一的双层for循环中，假设<code>nums</code>为5个元素，当for的外层循环遍历到最后一个元素时，<code>i</code>为4，内层循环涉及到<code>for j in range(5,5)</code>，生成的序列将是空的。因此，<code>for j in range(5,5)</code> 实际上不会执行循环体内的任何代码，也不存在报错。在 Python 中，尝试访问超出数组（列表）索引的元素会引发错误。具体来说，如果尝试访问一个不存在的索引位置，Python 会抛出 <code>IndexError</code> 异常。</p></blockquote></li><li><p><strong>时间与空间复杂度</strong></p><blockquote><p>1、使用暴力枚举，时间复杂度为O($n^2$​)，因为需要使用两层循环来检查数组中每对不同的元素，看它们的和是否等于 <code>target</code>；空间复杂度为O(1)，因为除了输入和输出之外，只需要有限的额外空间。</p><p>2、使用哈希表，时间复杂度为O(n)，因为只需要遍历数组一次，对于每个元素，可以在 O(1) 的时间内通过哈希表检查 <code>target - num</code> 是否存在；空间复杂度为O(n)，因为最坏的情况下，可能需要将数组中的所有元素都存储在哈希表中。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>题库</tag>
      
      <tag>哈希表</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Test</title>
    <link href="/2024/02/28/Test/"/>
    <url>/2024/02/28/Test/</url>
    
    <content type="html"><![CDATA[<h1 id="欢迎你"><a href="#欢迎你" class="headerlink" title="欢迎你"></a>欢迎你</h1><p>这是一篇测试文章。</p><p>我是一个很懒的人，做到这一步已经很棒了。</p><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202402281629110.jpeg" alt="有什么特别可爱猫猫的动态图或表情包吗？ - 知乎"></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>乱七八糟</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
