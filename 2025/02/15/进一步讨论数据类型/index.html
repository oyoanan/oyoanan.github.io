

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202402281732273.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="An">
  <meta name="keywords" content="">
  
    <meta name="description" content="进一步讨论数据类型 1、原始数据类型和引用数据类型的区别原始数据类型：  不可变性：原始数据类型的值一旦被创建就不能改变，例如，对字符串的操作总是返回一个新的字符串，不会修改原来的字符串。  字符串池：字符串池（String Pool）是一种内存优化机制。当创建一个新的字符串字面量时，JavaScript 引擎会先检查字符串池中是否已经存在相同内容的字符串。如果存在，则直接返回池中字符串的引用，而">
<meta property="og:type" content="article">
<meta property="og:title" content="进一步讨论数据类型">
<meta property="og:url" content="http://example.com/2025/02/15/%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%AE%A8%E8%AE%BA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/index.html">
<meta property="og:site_name" content="An&#96;s Blog">
<meta property="og:description" content="进一步讨论数据类型 1、原始数据类型和引用数据类型的区别原始数据类型：  不可变性：原始数据类型的值一旦被创建就不能改变，例如，对字符串的操作总是返回一个新的字符串，不会修改原来的字符串。  字符串池：字符串池（String Pool）是一种内存优化机制。当创建一个新的字符串字面量时，JavaScript 引擎会先检查字符串池中是否已经存在相同内容的字符串。如果存在，则直接返回池中字符串的引用，而">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502152349481.jpg">
<meta property="article:published_time" content="2025-02-15T15:50:07.000Z">
<meta property="article:modified_time" content="2025-02-15T15:57:04.512Z">
<meta property="article:author" content="An">
<meta property="article:tag" content="原始数据类型">
<meta property="article:tag" content="引用数据类型">
<meta property="article:tag" content="数据类型检测">
<meta property="article:tag" content="判断数组的方式">
<meta property="article:tag" content="null和undefined的区别">
<meta property="article:tag" content="isNaN 和 Number.isNaN 的区别">
<meta property="article:tag" content="类型转换规则">
<meta property="article:tag" content="与或操作符">
<meta property="article:tag" content="包装类型">
<meta property="article:tag" content="深拷贝和浅拷贝">
<meta property="article:tag" content="如何判断一个对象是空对象">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502152349481.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>进一步讨论数据类型 - An`s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>An</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="进一步讨论数据类型"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-02-15 23:50" pubdate>
          2025年2月15日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.1k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          43 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">进一步讨论数据类型</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="进一步讨论数据类型"><a href="#进一步讨论数据类型" class="headerlink" title="进一步讨论数据类型"></a>进一步讨论数据类型</h1><p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502152350420.jpeg" srcset="/img/loading.gif" lazyload alt="1669368848696729"></p>
<h2 id="1、原始数据类型和引用数据类型的区别"><a href="#1、原始数据类型和引用数据类型的区别" class="headerlink" title="1、原始数据类型和引用数据类型的区别"></a>1、原始数据类型和引用数据类型的区别</h2><p><strong>原始数据类型：</strong></p>
<ul>
<li><p>不可变性：原始数据类型的值一旦被创建就不能改变，例如，对字符串的操作总是返回一个新的字符串，不会修改原来的字符串。</p>
<blockquote>
<p>字符串池：字符串池（String Pool）是一种内存优化机制。当创建一个新的字符串字面量时，JavaScript 引擎会先检查字符串池中是否已经存在相同内容的字符串。如果存在，则直接返回池中字符串的引用，而不是创建一个新的实例。</p>
</blockquote>
</li>
<li><p>存储方式：直接存储在栈内存，因此复制变量的时候，复制的是实际的值。</p>
</li>
<li><p>传递方式：赋值、作为函数参数传递时，是按值传递，传递的是值的副本。</p>
<blockquote>
<p>换句话说，原始变量和目标变量在内存中是完全独立的。</p>
</blockquote>
</li>
<li><p>比较方式：直接比较值的内容。</p>
</li>
</ul>
<p><strong>引用数据类型：</strong></p>
<ul>
<li><p>可变性：引用类型的值（对象）是可变的，可以动态增加、删除、修改属性。</p>
</li>
<li><p>存储方式：引用类型的数据存储在堆内存，变量的引用（内存地址）存储在栈内存。</p>
</li>
<li><p>传递方式：赋值、作为函数参数传递时，是按引用传递。这意味着多个变量可能指向的是同一个对象，修改其中一个变量所指向的对象会影响到其他变量。</p>
</li>
<li><p>比较方式：比较的是对象的引用（内存地址）。</p>
</li>
</ul>
<p><strong>？</strong> 为什么这样区别设计二者的存储方式</p>
<blockquote>
<p>根据原始数据类型的不可变性、大小固定的特点，存储在栈内存，分配速度快，适合存储固定大小、生命周期短的数据，可以高效进行内存分配和回收。</p>
<p>根据引用数据类型的可变性、大小不固定的特点，堆内存适合存储大小不固定或者需要动态分配内存的数据，空间大，而且灵活。变量中存储的是对实际数据的引用，使得传递对象时不需要复制整个对象，只需要复制引用，提高了效率。</p>
<p><strong>栈内存</strong>：分配和回收速度快，但适用于简单、固定大小的数据。</p>
<p><strong>堆内存</strong>：灵活且容量大，但分配和垃圾回收的成本相对较高。</p>
</blockquote>
<h2 id="2、它们的垃圾回收是如何进行的，有区别吗"><a href="#2、它们的垃圾回收是如何进行的，有区别吗" class="headerlink" title="2、它们的垃圾回收是如何进行的，有区别吗"></a>2、它们的垃圾回收是如何进行的，有区别吗</h2><p><strong>原始数据类型</strong>：当函数执行结束或变量离开其作用域时，存储在栈中的原始数据会被自动释放，不需要额外的垃圾回收机制介入。</p>
<p><strong>？</strong> 离开作用域是指</p>
<blockquote>
<p>作用域决定了程序哪些部分可以访问某个变量或者函数。常见的作用域有全局作用域、函数作用域、块级作用域（使用 let 或者 const 声明）</p>
<p>当代码执行进入一个新的块或者函数时，就创建了一个新的作用域，其中声明的变量就只能在这个作用域内使用。当函数执行完毕或者代码块执行结束后，之前在该作用域内声明的变量就会离开作用域。如果没有其他引用，就会成为垃圾回收的候选，内存可以被释放。</p>
</blockquote>
<p><strong>引用数据类型</strong>：JS引擎会定期运行垃圾回收器，标记并清除不再被引用的对象。</p>
<blockquote>
<p><strong>引用计数垃圾回收：</strong>如果没有指向该对象的引用，那么该对象称作“垃圾”或者可回收的。</p>
<p>（<strong>备注：</strong> 现代 JavaScript 引擎不再使用引用计数进行垃圾回收，因为存在循环引用问题。）</p>
<p><strong>标记清除算法：</strong>这个算法将“对象不再需要”这个定义简化为“对象不可达”。在 JavaScript 中，根是全局对象。垃圾回收器将定期从这些根开始，找到从这些根能引用到的所有对象，然后找到从这些对象能引用到的所有对象，等等。从根开始，垃圾回收器将找到所有<em>可到达</em>的对象并收集所有不能到达的对象。</p>
<p>（<strong>备注：</strong> 当前，所有现代的引擎搭载的是标记清除垃圾回收器。）</p>
<p><strong>优化：</strong>分代&#x2F;增量&#x2F;并行垃圾回收</p>
</blockquote>
<h2 id="3、-数据类型检测的方式有哪些"><a href="#3、-数据类型检测的方式有哪些" class="headerlink" title="3、 数据类型检测的方式有哪些"></a>3、 数据类型检测的方式有哪些</h2><p><strong><code>typeof</code> 运算符</strong></p>
<p>对于 <code>null</code> 会返回 <code>&quot;object&quot;</code>，这是历史遗留问题。</p>
<p>对于数组和其他对象，都会返回 <code>&quot;object&quot;</code></p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> <span class="hljs-number">42</span>);          <span class="hljs-comment">// &quot;number&quot;</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> <span class="hljs-string">&quot;Hello&quot;</span>);     <span class="hljs-comment">// &quot;string&quot;</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> <span class="hljs-literal">true</span>);        <span class="hljs-comment">// &quot;boolean&quot;</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> <span class="hljs-literal">undefined</span>);   <span class="hljs-comment">// &quot;undefined&quot;</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> Symbol());    <span class="hljs-comment">// &quot;symbol&quot;</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;);<span class="hljs-comment">// &quot;function&quot; ★</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> &#123;&#125;);          <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> []);          <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> <span class="hljs-literal">null</span>);        <span class="hljs-comment">// &quot;object&quot;（注意）★</span><br></code></pre></td></tr></table></figure>

<p><strong><code>instanceof</code> 运算符</strong></p>
<p>检测一个对象是否是某个构造函数的实例，用于引用类型检测。</p>
<p>如果涉及到跨 iframe 或 window 时，可能会出现问题，因为不同全局环境下的构造函数不相等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>);           <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);           <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>);     <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p><strong><code>Object.prototype.toString.call()</code> 方法</strong></p>
<p>获取一个标准格式的类型字符串。</p>
<p>能够准确检测绝大多数数据类型，包括内置对象、数组、null、undefined 等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-number">42</span>));           <span class="hljs-comment">// &quot;[object Number]&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&quot;Hello&quot;</span>));      <span class="hljs-comment">// &quot;[object String]&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">true</span>));         <span class="hljs-comment">// &quot;[object Boolean]&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>));    <span class="hljs-comment">// &quot;[object Undefined]&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>));         <span class="hljs-comment">// &quot;[object Null]&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>([]));           <span class="hljs-comment">// &quot;[object Array]&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(&#123;&#125;));           <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;)); <span class="hljs-comment">// &quot;[object Function]&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));   <span class="hljs-comment">// &quot;[object Date]&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong><code>Array.isArray()</code> 方法</strong></p>
<p>专门用于检测某个值是否为数组。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Array</span>.isArray([]));      <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Array</span>.isArray(&#123;&#125;));      <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p><strong><code>constructor</code>判断</strong></p>
<p>通过访问对象的 <code>constructor</code> 属性来判断对象是由哪个构造函数创建的。</p>
<p>仅限于对象（引用类型）</p>
<p>通过常规创建方式得到的对象，其原型链会提供一个 <code>constructor</code> 属性。如果使用 <code>Object.create(null)</code> 或手动修改原型后，对象可能没有 <code>constructor</code> 属性。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const obj <span class="hljs-operator">=</span> &#123;&#125;<span class="hljs-comment">;</span><br>console.log(obj.constructor <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> Object)<span class="hljs-comment">; // true</span><br><br>const arr <span class="hljs-operator">=</span> []<span class="hljs-comment">;</span><br>console.log(arr.constructor <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> Array)<span class="hljs-comment">;  // true</span><br></code></pre></td></tr></table></figure>

<h2 id="4、判断数组的方式有哪些"><a href="#4、判断数组的方式有哪些" class="headerlink" title="4、判断数组的方式有哪些"></a>4、判断数组的方式有哪些</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Array.isArrray(obj)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span><br></code></pre></td></tr></table></figure>

<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Object</span>.proto<span class="hljs-keyword">type</span>.toString.call(obj).slice(8,-1) === &#x27;<span class="hljs-type">Array&#x27;</span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">obj.__proto__ <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> Array.prototype<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Object.getPrototypeOf(obj) <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> Array.prototype<br></code></pre></td></tr></table></figure>

<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Array</span>.proto<span class="hljs-keyword">type</span>.isPrototypeOf(obj)<br></code></pre></td></tr></table></figure>

<p>我根据对原型的理解，画了一张图：</p>
<p><strong>prototype</strong>：<br>是构造函数的属性，用于为新创建的对象提供共享的属性和方法。</p>
<p>**<strong>proto</strong>**：<br>是对象的内部属性（或访问器），指向该对象的原型。对象在创建时，会把构造函数的 <code>prototype</code> 赋值给其 <code>__proto__</code>。</p>
<p><img src="https://an-hexo-blog.oss-cn-beijing.aliyuncs.com/img/202502152350401.png" srcset="/img/loading.gif" lazyload alt="image-20250215211233974"></p>
<h2 id="5、null和undefined区别"><a href="#5、null和undefined区别" class="headerlink" title="5、null和undefined区别"></a>5、null和undefined区别</h2><p><strong>undefined</strong>：表示变量已声明但尚未赋值。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let a;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a); <span class="hljs-comment">// 输出：undefined</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(foo()); <span class="hljs-comment">// 输出：undefined，因为没有显式返回值</span><br></code></pre></td></tr></table></figure>

<p><strong>null</strong>：表示“空”或“无值”，是一种有意的赋值，表示变量应当为空。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let b = <span class="hljs-literal">null</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b); <span class="hljs-comment">// 输出：null</span><br></code></pre></td></tr></table></figure>

<p><strong>严格比较</strong>（&#x3D;&#x3D;&#x3D;）：</p>
<ul>
<li><code>undefined === null</code> 返回 <code>false</code>，因为它们类型不同。</li>
</ul>
<p><strong>非严格比较</strong>（&#x3D;&#x3D;）：</p>
<ul>
<li><code>undefined == null</code> 返回 <code>true</code>，这是因为在非严格比较中，JavaScript 会认为它们都表示“无”的概念。</li>
</ul>
<h2 id="6、intanceof-操作符的实现原理及实现"><a href="#6、intanceof-操作符的实现原理及实现" class="headerlink" title="6、intanceof 操作符的实现原理及实现"></a>6、intanceof 操作符的实现原理及实现</h2><p><strong>底层原理</strong>：检查该构造函数的 <code>prototype</code> 属性是否出现在对象的原型链中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkPro</span>(<span class="hljs-params">con, ins</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> con !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;con must be a function&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> proto = ins.<span class="hljs-property">__proto__</span>;<br>  <span class="hljs-keyword">let</span> prototype = con.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>  <span class="hljs-keyword">while</span> (proto !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (proto == prototype) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 示例：</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">const</span> alice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">checkPro</span>(<span class="hljs-title class_">Person</span>, alice)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">checkPro</span>(<span class="hljs-title class_">Array</span>, alice)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<h2 id="7、为什么0-1-0-2-0-3，如何让其相等"><a href="#7、为什么0-1-0-2-0-3，如何让其相等" class="headerlink" title="7、为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等"></a>7、为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等</h2><p>在 JavaScript 中，数字采用 IEEE 754 双精度浮点数表示法，这种表示法无法精确地表示所有小数，特别是像 0.1 和 0.2 这样的数。在二进制表示中，0.1 和 0.2 都是无限循环的，因此它们只能被近似表示，导致在进行加法运算时出现微小的舍入误差。</p>
<p> <strong>Math.round</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Math</span>.round((<span class="hljs-number">0</span>.<span class="hljs-number">1</span>+<span class="hljs-number">0</span>.<span class="hljs-number">2</span>)*<span class="hljs-number">100</span>)/<span class="hljs-number">100</span><br></code></pre></td></tr></table></figure>

<p><strong>toFixed</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Number</span>((<span class="hljs-number">0</span>.<span class="hljs-number">1</span>+<span class="hljs-number">0</span>.<span class="hljs-number">2</span>).toFixed(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure>

<h2 id="8、如何使用安全的-undefined-值"><a href="#8、如何使用安全的-undefined-值" class="headerlink" title="8、如何使用安全的 undefined 值"></a>8、如何使用安全的 undefined 值</h2><p>在某些旧版 JavaScript 环境中，<code>undefined</code> 可能被意外地重写，为了确保得到真正的 <code>undefined</code> 值，有以下几种“安全”的方式：</p>
<p><strong>使用 <code>void</code> 运算符</strong></p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> safeUndefined = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(safeUndefined); <span class="hljs-comment">// 输出：undefined</span><br></code></pre></td></tr></table></figure>

<p><strong>利用 IIFE 的参数 立即执行函数表达式</strong></p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">(<span class="hljs-keyword">function</span> (<span class="hljs-params">undefined</span>) &#123;<br>  <span class="hljs-comment">// 在这个函数作用域中，变量 undefined 是一个局部变量</span><br>  <span class="hljs-comment">// 且没有被赋予任何值，所以它的值就是原始的 undefined</span><br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// 输出：undefined</span><br><br>  <span class="hljs-comment">// 这里就可以放心地使用 undefined，而不用担心全局 undefined 被修改</span><br>&#125;)();<br></code></pre></td></tr></table></figure>

<h2 id="9、typeof-NaN-的结果是什么？"><a href="#9、typeof-NaN-的结果是什么？" class="headerlink" title="9、typeof NaN 的结果是什么？"></a>9、typeof NaN 的结果是什么？</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span>(<span class="hljs-literal">NaN</span>)); <span class="hljs-comment">// number</span><br></code></pre></td></tr></table></figure>

<p>NaN 是一个特殊值，用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p>
<p>NaN 和自身不相等。因为如果两个计算都得到了 <code>NaN</code>，这并不意味着它们表示相同的错误或同样的情况。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-literal">NaN</span> === <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// false</span><br><span class="hljs-literal">NaN</span> !== <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<h2 id="10、isNaN-和-Number-isNaN-函数的区别？"><a href="#10、isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="10、isNaN 和 Number.isNaN 函数的区别？"></a>10、isNaN 和 Number.isNaN 函数的区别？</h2><p>主要区别在于是否进行类型转换！</p>
<p><strong>全局 isNaN() 函数</strong>：会先将参数转换为数字，再判断是否为 <code>NaN</code>，因此可能导致一些非数字类型的数据也被误判为 <code>NaN</code>。</p>
<p><strong>ES6 的 Number.isNaN() 方法</strong>：不会进行类型转换，仅当值严格为 <code>NaN</code> 时才返回 <code>true</code>，因此更为精确和安全。</p>
<p>★推荐Number.isNaN 函数</p>
<h2 id="11、Number-其他值到数字值的转换规则？"><a href="#11、Number-其他值到数字值的转换规则？" class="headerlink" title="11、Number 其他值到数字值的转换规则？"></a>11、Number 其他值到数字值的转换规则？</h2><p><strong>undefined</strong> → <code>NaN</code></p>
<p><strong>null</strong> → <code>0</code></p>
<p><strong>boolean</strong>：<code>true</code> → <code>1</code>，<code>false</code> → <code>0</code></p>
<p><strong>字符串</strong>：合法数值字符串转换为对应数字，不合法的返回 <code>NaN</code>；空字符串返回 <code>0</code></p>
<p><strong>对象</strong>：先转换为原始值，再按照原始值的规则转换（通常返回 <code>NaN</code>，除非对象自定义了转换逻辑）</p>
<p><strong>Symbol</strong>：不能转换为数字，会抛出错误</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// NaN ★</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>)); <span class="hljs-comment">// 0 ★</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>)); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>)); <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;&quot;</span>)); <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;  &quot;</span>)); <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;123&quot;</span>)); <span class="hljs-comment">// 123</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;123.45  &quot;</span>)); <span class="hljs-comment">// 123.45 ★</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;123abc&quot;</span>)); <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(&#123;&#125;)); <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(&#123; <span class="hljs-attr">value</span>: <span class="hljs-number">123</span> &#125;)); <span class="hljs-comment">// NaN</span><br><span class="hljs-comment">// 自定义对象转换</span><br>const obj = &#123;<br>    valueOf() &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>    &#125;<br>  &#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(obj)); <span class="hljs-comment">// 42 ★</span><br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Number</span>(Symbol(<span class="hljs-string">&quot;id&quot;</span>))); <span class="hljs-comment">// Uncaught TypeError ★</span><br></code></pre></td></tr></table></figure>

<h2 id="12、String-其他值到字符串的转换规则？"><a href="#12、String-其他值到字符串的转换规则？" class="headerlink" title="12、String 其他值到字符串的转换规则？"></a>12、String 其他值到字符串的转换规则？</h2><p><strong>undefined</strong> → <code>&quot;undefined&quot;</code></p>
<p><strong>null</strong> → <code>&quot;null&quot;</code></p>
<p><strong>Boolean</strong>：<code>true</code> → <code>&quot;true&quot;</code>；<code>false</code> → <code>&quot;false&quot;</code></p>
<p><strong>Number</strong>：转换为其对应的数字字符（特殊数字如 <code>NaN</code>、<code>Infinity</code> 有专门的字符串表示）</p>
<p><strong>String</strong>：本身不变</p>
<p><strong>Object</strong>：调用对象的 <code>toString()</code>（或内部 ToPrimitive 算法）转换为字符串，默认普通对象为 <code>&quot;[object Object]&quot;</code>，数组和函数有各自的表现形式</p>
<p><strong>Symbol</strong>：必须显式转换（<code>String(symbol)</code> 或 <code>symbol.toString()</code>），否则隐式转换会报错</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stata">console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(undefined)); <span class="hljs-comment">// &quot;undefined&quot;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(null)); <span class="hljs-comment">// &quot;null&quot;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(true)); <span class="hljs-comment">// &quot;true&quot;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(false)); <span class="hljs-comment">// &quot;false&quot;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(123));<span class="hljs-comment">// &quot;123&quot;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(0));<span class="hljs-comment">// &quot;0&quot;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(-45)); <span class="hljs-comment">// &quot;-45&quot;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(NaN));<span class="hljs-comment">// &quot;NaN&quot;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(Infinity));<span class="hljs-comment">// &quot;Infinity&quot;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(-Infinity));<span class="hljs-comment">// &quot;-Infinity&quot;</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(&#123;&#125;));<span class="hljs-comment">// &quot;[object Object]&quot; ★</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>([1,2,3])); <span class="hljs-comment">// &quot;1,2,3&quot;  ★</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(function()&#123;&#125;));<span class="hljs-comment">// &quot;function()&#123;&#125;&quot; ★</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">String</span>(Symbol(<span class="hljs-string">&quot;id&quot;</span>)));<span class="hljs-comment">// &quot;Symbol(id)&quot; ★</span><br></code></pre></td></tr></table></figure>

<h2 id="13、Boolean-其他值到布尔类型的值的转换规则？"><a href="#13、Boolean-其他值到布尔类型的值的转换规则？" class="headerlink" title="13、Boolean 其他值到布尔类型的值的转换规则？"></a>13、Boolean 其他值到布尔类型的值的转换规则？</h2><p><strong>Falsy 值</strong>：<code>undefined</code>、<code>null</code>、<code>false</code>、<code>+0</code>、<code>-0</code>、<code>NaN</code> 和 <code>&quot;&quot;</code> 转换为 <code>false</code>。</p>
<p><strong>Truthy 值</strong>：除了上述 falsy 值之外，所有其他值转换为 <code>true</code>。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">console.log(<span class="hljs-type">Boolean</span>(undefined)); // <span class="hljs-keyword">false</span><br>console.log(<span class="hljs-type">Boolean</span>(<span class="hljs-keyword">null</span>));// <span class="hljs-keyword">false</span><br>console.log(<span class="hljs-type">Boolean</span>(<span class="hljs-number">0</span>));// <span class="hljs-keyword">false</span> ★<br>console.log(<span class="hljs-type">Boolean</span>(<span class="hljs-number">-0</span>));// <span class="hljs-keyword">false</span><br>console.log(<span class="hljs-type">Boolean</span>(<span class="hljs-keyword">NaN</span>));// <span class="hljs-keyword">false</span><br>console.log(<span class="hljs-type">Boolean</span>(&quot;&quot;));// <span class="hljs-keyword">false</span>  ★<br>console.log(<span class="hljs-type">Boolean</span>(&quot;0&quot;));// <span class="hljs-keyword">true</span> ★<br>console.log(<span class="hljs-type">Boolean</span>(&quot;hello&quot;));// <span class="hljs-keyword">true</span><br>console.log(<span class="hljs-type">Boolean</span>(&quot;&#123;&#125;&quot;));// <span class="hljs-keyword">true</span> ★<br>console.log(<span class="hljs-type">Boolean</span>(&quot;[]&quot;));// <span class="hljs-keyword">true</span> ★<br>console.log(<span class="hljs-type">Boolean</span>(&quot;function()&#123;&#125;&quot;));// <span class="hljs-keyword">true</span> ★<br>console.log(<span class="hljs-type">Boolean</span>(&quot;Symbol(&#x27;id&#x27;)&quot;));// <span class="hljs-keyword">true</span> <br></code></pre></td></tr></table></figure>

<h2 id="14、-和-操作符的返回值"><a href="#14、-和-操作符的返回值" class="headerlink" title="14、 || 和 &amp;&amp; 操作符的返回值"></a>14、 || 和 &amp;&amp; 操作符的返回值</h2><p><strong>逻辑或（<code>||</code>）</strong></p>
<ul>
<li><strong>返回规则</strong>：<br>对于表达式 <code>a || b</code>，如果 <code>a</code> 是 truthy（真值），则直接返回 <code>a</code>；否则返回 <code>b</code>。</li>
<li><strong>工作过程</strong>：<ol>
<li>先计算 <code>a</code>。</li>
<li>如果 <code>a</code> 为 truthy，则整个表达式的值为 <code>a</code>（并且不再计算 <code>b</code>）。</li>
<li>如果 <code>a</code> 为 falsy，则计算 <code>b</code>，并返回 <code>b</code> 的值。</li>
</ol>
</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Hello&quot;</span> || <span class="hljs-string">&quot;World&quot;</span>); <span class="hljs-comment">// 返回 &quot;Hello&quot;，因为 &quot;Hello&quot; 为 truthy</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;&quot;</span> || <span class="hljs-string">&quot;World&quot;</span>);      <span class="hljs-comment">// 返回 &quot;World&quot;，因为 &quot;&quot; 为 falsy</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">0</span> || <span class="hljs-number">42</span>);            <span class="hljs-comment">// 返回 42，因为 0 为 falsy</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-literal">null</span> || <span class="hljs-literal">undefined</span>);  <span class="hljs-comment">// 返回 undefined，因为 null 和 undefined 都为 falsy，返回最后一个操作数</span><br></code></pre></td></tr></table></figure>

<p><strong>逻辑与（<code>&amp;&amp;</code>）</strong></p>
<ul>
<li><strong>返回规则</strong>：<br>对于表达式 <code>a &amp;&amp; b</code>，如果 <code>a</code> 是 falsy（假值），则直接返回 <code>a</code>；否则返回 <code>b</code>。</li>
<li><strong>工作过程</strong>：<ol>
<li>先计算 <code>a</code>。</li>
<li>如果 <code>a</code> 为 falsy，则整个表达式的值为 <code>a</code>（并且不再计算 <code>b</code>）。</li>
<li>如果 <code>a</code> 为 truthy，则计算 <code>b</code>，并返回 <code>b</code> 的值。</li>
</ol>
</li>
</ul>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">console.<span class="hljs-meta">log</span>(<span class="hljs-string">&quot;Hello&quot;</span> <span class="hljs-variable">&amp;&amp;</span> <span class="hljs-string">&quot;World&quot;</span>); // 返回 <span class="hljs-string">&quot;World&quot;</span>，因为 <span class="hljs-string">&quot;Hello&quot;</span> 为 truthy，所以返回第二个操作数<br>console.<span class="hljs-meta">log</span>(<span class="hljs-string">&quot;&quot;</span> <span class="hljs-variable">&amp;&amp;</span> <span class="hljs-string">&quot;World&quot;</span>);      // 返回 <span class="hljs-string">&quot;&quot;</span>，因为 <span class="hljs-string">&quot;&quot;</span> 为 falsy，直接返回第一个操作数<br>console.<span class="hljs-meta">log</span>(42 <span class="hljs-variable">&amp;&amp;</span> 0);            // 返回 0，因为 42 为 truthy，但 0 为 falsy<br>console.<span class="hljs-meta">log</span>(<span class="hljs-keyword">null</span> <span class="hljs-variable">&amp;&amp;</span> <span class="hljs-string">&quot;Test&quot;</span>);     // 返回 <span class="hljs-keyword">null</span>，因为 <span class="hljs-keyword">null</span> 为 falsy<br></code></pre></td></tr></table></figure>

<p><strong>这种行为使得逻辑运算符不仅可以用于条件判断，还可以用来设置默认值或进行短路求值。</strong></p>
<blockquote>
<p>1、设置默认值</p>
<p>利用 <code>||</code> 的短路特性，可以在一个表达式中为变量指定默认值。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">let <span class="hljs-keyword">user</span>Name = <span class="hljs-string">&quot;&quot;</span>;<br>// 如果 <span class="hljs-keyword">user</span>Name 为 falsy（例如空字符串），则使用 <span class="hljs-string">&quot;defaultName&quot;</span> 作为默认值<br>let name = <span class="hljs-keyword">user</span>Name || <span class="hljs-string">&quot;defaultName&quot;</span>;<br>console.<span class="hljs-keyword">log</span>(name); // 输出 <span class="hljs-string">&quot;defaultName&quot;</span><br></code></pre></td></tr></table></figure>

<p>2、短路求值</p>
<p>利用 <code>&amp;&amp;</code> 的短路特性，可以控制在某个条件为真时才继续执行某些操作。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> isLoggedIn = <span class="hljs-literal">true</span>;<br>// 如果 isLoggedIn 为 <span class="hljs-literal">true</span>，则继续执行后面的操作，否则直接返回 <span class="hljs-literal">false</span><br>isLoggedIn &amp;&amp; console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;User is logged in&quot;</span>);<br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="15、-Object-is-与比较操作符-、-的区别？"><a href="#15、-Object-is-与比较操作符-、-的区别？" class="headerlink" title="15、 Object.is() 与比较操作符===、==的区别？"></a>15、 Object.is() 与比较操作符<code>===</code>、<code>==</code>的区别？</h2><p><strong><code>==</code>（宽松相等）</strong>：在比较前会进行类型转换（隐式转换）。</p>
<p><strong><code>===</code>（严格相等）</strong>：比较时要求两边的值类型必须相同，且值也必须相等。</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">**特殊情况**：<br>- `NaN === NaN` 返回 `false`。<br>- `+<span class="hljs-number">0</span> === -<span class="hljs-number">0</span>` 返回 `true`。<br></code></pre></td></tr></table></figure>

<p> **<code>Object.is()</code>**：<code>Object.is()</code> 基本上与 <code>===</code> 类似，但处理特殊值时有不同的行为。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Object.is(<span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-literal">NaN</span> === <span class="hljs-literal">NaN</span>);         <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Object.is(+<span class="hljs-number">0</span>, <span class="hljs-number">-0</span>));   <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(+<span class="hljs-number">0</span> === <span class="hljs-number">-0</span>);           <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<h2 id="16、什么是-JavaScript-中的包装类型"><a href="#16、什么是-JavaScript-中的包装类型" class="headerlink" title="16、什么是 JavaScript 中的包装类型"></a>16、什么是 JavaScript 中的包装类型</h2><p>包装类型：原始数据类型对应的对象形式！</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs openscad"><span class="hljs-built_in">let</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span>.toUpperCase()); <span class="hljs-comment">// &quot;HELLO&quot;</span><br></code></pre></td></tr></table></figure>

<p>当对原始值调用属性或方法时，JavaScript 会在后台临时创建一个对应的对象包装器（例如 <code>String</code>、<code>Number</code>、<code>Boolean</code> 对象），使得能够访问原始值的方法。</p>
<p><strong>包装类型的工作原理</strong></p>
<p>当试图访问原始值的属性或方法时，JavaScript 会进行以下操作：</p>
<ol>
<li>根据原始值的类型（例如字符串）创建对应的包装对象（例如 <code>new String(&quot;hello&quot;)</code>）。</li>
<li>在这个包装对象上查找所请求的方法或属性（例如 <code>toUpperCase</code>）。</li>
<li>调用方法或访问属性，然后丢弃这个包装对象。</li>
</ol>
<p><strong>包装类型的特点</strong></p>
<ul>
<li><p>临时性</p>
</li>
<li><p>类型差异性</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 当没有访问方法或属性时，str 依然是一个原始字符串</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> str);        <span class="hljs-comment">// &quot;string&quot;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>可以使用<code>valueOf</code>方法将包装类型倒转成基本类型：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-keyword">var</span> b = Object(a)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b); <span class="hljs-comment">// String &#123;&#x27;abc&#x27;&#125;</span><br><span class="hljs-keyword">var</span> c = b.valueOf() <span class="hljs-comment">// &#x27;abc&#x27;</span><br></code></pre></td></tr></table></figure>

<p>试试打印这个：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>( <span class="hljs-literal">false</span> );<br><span class="hljs-keyword">if</span> (!a) &#123;<br>	<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( <span class="hljs-string">&quot;Oops&quot;</span> ); <span class="hljs-comment">// never runs</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>什么都不会打印，因为包装类型是对象。</p>
<h2 id="17、JavaScript-中如何进行隐式类型转换？"><a href="#17、JavaScript-中如何进行隐式类型转换？" class="headerlink" title="17、JavaScript 中如何进行隐式类型转换？"></a>17、JavaScript 中如何进行隐式类型转换？</h2><p>隐式类型转换：不显示调用转换函数，JS引擎自动将一种数据类型转换为另一种数据类型。</p>
<p> <strong>算术运算符中的隐式转换</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;5&quot;</span> - <span class="hljs-number">2</span>;      <span class="hljs-regexp">//</span> 数字: <span class="hljs-number">3</span>，字符串 <span class="hljs-string">&quot;5&quot;</span> 被转换为数字 <span class="hljs-number">5</span><br><span class="hljs-string">&quot;10&quot;</span> * <span class="hljs-string">&quot;2&quot;</span>;   <span class="hljs-regexp">//</span> 数字: <span class="hljs-number">20</span>，两个字符串都被转换为数字<br><span class="hljs-string">&quot;10&quot;</span> <span class="hljs-regexp">/ 2;     /</span>/ 数字: <span class="hljs-number">5</span><br><span class="hljs-string">&quot;abc&quot;</span> - <span class="hljs-number">2</span>;    <span class="hljs-regexp">//</span> NaN，因为 <span class="hljs-string">&quot;abc&quot;</span> 不能转换为数字<br><br><span class="hljs-regexp">//</span> 加号运算符 `+` 的特殊情况<br><span class="hljs-string">&quot;5&quot;</span> + <span class="hljs-number">2</span>;      <span class="hljs-regexp">//</span> 字符串: <span class="hljs-string">&quot;52&quot;</span><br><span class="hljs-number">2</span> + <span class="hljs-string">&quot;3&quot;</span>;      <span class="hljs-regexp">//</span> 字符串: <span class="hljs-string">&quot;23&quot;</span><br><span class="hljs-number">2</span> + <span class="hljs-number">3</span>;        <span class="hljs-regexp">//</span> 数字: <span class="hljs-number">5</span>（两个都是数字，不发生字符串转换）<br></code></pre></td></tr></table></figure>

<p><strong>比较运算符中的隐式转换</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">1</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-comment">;         // true，因为 &quot;1&quot; 转换为数字 1</span><br><span class="hljs-attribute">true</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;        // true，true 被转换为数字 1</span><br><span class="hljs-attribute">false</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;       // true，false 被转换为数字 0</span><br><span class="hljs-attribute">null</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> undefined<span class="hljs-comment">;// true（这是个特殊情况）</span><br><br>// 严格模式，不进行隐式转换：<br><span class="hljs-number">1</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span><span class="hljs-comment">;        // false</span><br><span class="hljs-attribute">true</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;       // false</span><br></code></pre></td></tr></table></figure>

<p><strong>布尔上下文中的隐式转换</strong></p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 转换为false:</span><br><span class="hljs-literal">undefined</span><br><span class="hljs-literal">null</span><br><span class="hljs-literal">false</span><br>+<span class="hljs-number">0</span>、<span class="hljs-number">-0</span><br><span class="hljs-literal">NaN</span><br><span class="hljs-string">&quot;&quot;</span>（空字符串）<br></code></pre></td></tr></table></figure>

<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span> 其他都转换为<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<p><strong>对象转换为原始类型</strong></p>
<p>当对象参与运算或比较时，内部会先调用 <strong>ToPrimitive</strong> 抽象操作，通常会先调用对象的 <code>valueOf()</code> 方法，如果返回的是原始值，则使用该值；否则再调用 <code>toString()</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-title function_">valueOf</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>  &#125;,<br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj + <span class="hljs-number">2</span>); <span class="hljs-comment">// 44，因为 obj 转换为数字 42，再加上 2</span><br></code></pre></td></tr></table></figure>

<h2 id="18、-操作符什么时候用于字符串的拼接？"><a href="#18、-操作符什么时候用于字符串的拼接？" class="headerlink" title="18、+ 操作符什么时候用于字符串的拼接？"></a>18、+ 操作符什么时候用于字符串的拼接？</h2><p><strong>字符串拼接</strong>：当至少有一个操作数是字符串或隐式转换为字符串时，<code>+</code> 执行字符串拼接。</p>
<p><strong>对象的情况</strong>：当操作数是对象时，会先通过内部的 ToPrimitive 操作（通常先调用 <code>valueOf()</code>，再调用 <code>toString()</code>）转换为原始值。如果转换结果为字符串，则触发字符串拼接；如果转换结果为数字，则进行加法运算。</p>
<p><strong>？</strong> 隐式转换为字符串的情况有</p>
<blockquote>
<p>1、当 <code>+</code> 运算符的一侧是字符串时，另一侧的操作数会自动转换为字符串；</p>
<p>2、在模板字符串中，通过 <code>$&#123;&#125;</code> 嵌入的表达式会自动调用 <code>String()</code> 转换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">let</span> message = <span class="hljs-string">`Age: <span class="hljs-subst">$&#123;age&#125;</span>`</span>; <span class="hljs-comment">// 结果为 &quot;Age: 30&quot;</span><br></code></pre></td></tr></table></figure>

<p>3、对象在字符串上下文中</p>
<p>当对象出现在需要字符串的地方（例如在字符串连接、打印输出、或作为对象的属性名时），JavaScript 会自动调用对象的 <code>toString()</code> 方法（或者在某些情况下调用 <code>valueOf()</code> 后再转换为字符串）：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;User: &quot;</span> + obj); <span class="hljs-comment">// 结果通常为 &quot;User: [object Object]&quot;</span><br><span class="hljs-comment">// 如果重写了 toString() 方法</span><br>obj.toString = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> this.name; &#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;User: &quot;</span> + obj); <span class="hljs-comment">// 结果为 &quot;User: Alice&quot;</span><br></code></pre></td></tr></table></figure>

<p>4、其他需要字符串的上下文</p>
<p>某些 API 或操作要求传入字符串参数时，如果传入的值不是字符串，JavaScript 也会自动进行转换：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 例如在 DOM 操作中传入非字符串参数时：<br>document.getElementById(<span class="hljs-number">123</span>); <span class="hljs-regexp">//</span> <span class="hljs-number">123</span> 会被转换为 <span class="hljs-string">&quot;123&quot;</span><br></code></pre></td></tr></table></figure>


</blockquote>
<h2 id="19、object-assign和扩展运算符是深拷贝还是浅拷贝"><a href="#19、object-assign和扩展运算符是深拷贝还是浅拷贝" class="headerlink" title="19、object.assign和扩展运算符是深拷贝还是浅拷贝"></a>19、object.assign和扩展运算符是深拷贝还是浅拷贝</h2><p>都是浅拷贝。</p>
<p><strong>浅拷贝</strong>：只复制对象的第一层属性。如果属性值是原始值（如字符串、数字、布尔值），则直接复制；如果属性值是引用类型（如对象、数组等），则只复制引用地址，拷贝后的对象和原对象共享同一个引用的子对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> original = &#123; <br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <br>  <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> &#125; <br>&#125;;<br><br><span class="hljs-comment">// 使用 Object.assign 进行浅拷贝</span><br><span class="hljs-keyword">const</span> copy1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, original);<br><br><span class="hljs-comment">// 使用扩展运算符进行浅拷贝</span><br><span class="hljs-keyword">const</span> copy2 = &#123; ...original &#125;;<br><br><span class="hljs-comment">// 修改嵌套对象的属性</span><br>copy1.<span class="hljs-property">b</span>.<span class="hljs-property">c</span> = <span class="hljs-number">42</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(original.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>); <span class="hljs-comment">// 输出 42，说明 original 和 copy1 的 b 属性指向同一个对象</span><br></code></pre></td></tr></table></figure>

<p><strong>？</strong> 如何进行深拷贝</p>
<ul>
<li><strong>深拷贝</strong>：会递归复制所有嵌套对象，确保新对象与原对象完全独立。</li>
<li>实现方法包括：<ul>
<li>使用 <code>JSON.parse(JSON.stringify(obj))</code>（注意这种方式有局限性，如无法处理函数、undefined、Symbol、循环引用等）</li>
<li>使用递归手写深拷贝函数</li>
<li>使用第三方库，比如 Lodash 的 <code>_.cloneDeep()</code></li>
</ul>
</li>
</ul>
<h2 id="20、如何判断一个对象是空对象"><a href="#20、如何判断一个对象是空对象" class="headerlink" title="20、如何判断一个对象是空对象"></a>20、如何判断一个对象是空对象</h2><p><strong>使用 <code>Object.keys()</code></strong></p>
<p>返回一个包含对象自身可枚举属性名称的数组。但不会遍历原型链属性。</p>
<p>如果数组长度为 0，则说明对象为空。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">isEmptyObject</span>(obj) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">Object.keys(obj).length</span> === <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>使用 <code>for...in</code> 循环结合 <code>hasOwnProperty</code></strong></p>
<p>使用 <code>for...in</code> 循环遍历对象所有可枚举属性，并结合 <code>hasOwnProperty</code> 过滤掉原型链上的属性。如果循环体内没有执行任何操作，则说明对象为空。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">function</span> isEmptyObject(obj) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span><span class="hljs-built_in"> key</span> <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (obj.hasOwnProperty<span class="hljs-built_in">(key</span>)) &#123;<br>      <span class="hljs-keyword">return</span><span class="hljs-built_in"> false</span>; // 如果有任意自有属性，返回<span class="hljs-built_in"> false</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span><span class="hljs-built_in"> true</span>; // 没有自有属性，返回<span class="hljs-built_in"> true</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p> <strong>使用 JSON 序列化</strong></p>
<p>将对象序列化成 JSON 字符串，如果结果是 <code>&quot;&#123;&#125;&quot;</code>，则说明对象为空。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">isEmptyObject</span>(obj) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">JSON.stringify(obj)</span> === &#x27;&#123;&#125;&#x27;;<br>&#125;<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/JavaScript/" class="category-chain-item">JavaScript</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="print-no-link">#原始数据类型</a>
      
        <a href="/tags/%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="print-no-link">#引用数据类型</a>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B/" class="print-no-link">#数据类型检测</a>
      
        <a href="/tags/%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E5%BC%8F/" class="print-no-link">#判断数组的方式</a>
      
        <a href="/tags/null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB/" class="print-no-link">#null和undefined的区别</a>
      
        <a href="/tags/isNaN-%E5%92%8C-Number-isNaN-%E7%9A%84%E5%8C%BA%E5%88%AB/" class="print-no-link">#isNaN 和 Number.isNaN 的区别</a>
      
        <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99/" class="print-no-link">#类型转换规则</a>
      
        <a href="/tags/%E4%B8%8E%E6%88%96%E6%93%8D%E4%BD%9C%E7%AC%A6/" class="print-no-link">#与或操作符</a>
      
        <a href="/tags/%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/" class="print-no-link">#包装类型</a>
      
        <a href="/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="print-no-link">#深拷贝和浅拷贝</a>
      
        <a href="/tags/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E7%A9%BA%E5%AF%B9%E8%B1%A1/" class="print-no-link">#如何判断一个对象是空对象</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/02/15/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="JavaScript中的数据类型">
                        <span class="hidden-mobile">JavaScript中的数据类型</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://oyoanan.github.io/" target="_blank" rel="nofollow noopener"><span>AN</span></a> <i class="iconfont icon-love"></i> <a href="https://d4n-sec.github.io/#/" target="_blank" rel="nofollow noopener"><span>DM</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
